<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Batch PRO - Édition Claude Ultimate (Option C - Compromis Qualité/Taille)</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        :root {
            --mer: #8FAFB1;
            --vert-sauge: #C8D0C3;
            --beige-sable: #D8CDBB;
            --sable: #E6D7C3;
            --blanc: #FFFFFF;
            --gris-texte: #333333;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Montserrat', 'Segoe UI', sans-serif;
            background: var(--blanc);
            min-height: 100vh;
            padding: 30px 20px;
            color: var(--gris-texte);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: var(--blanc);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.15);
        }

        h1 {
            color: var(--mer);
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.8em;
            font-weight: 700;
        }

        .subtitle {
            text-align: center;
            color: var(--gris-texte);
            margin-bottom: 25px;
            font-size: 1.1em;
        }

        .claude-badge {
            background: linear-gradient(135deg, var(--mer), var(--vert-sauge));
            color: var(--blanc);
            padding: 12px 30px;
            border-radius: 30px;
            font-weight: 700;
            display: inline-block;
            margin: 0 auto 30px;
            box-shadow: 0 6px 20px rgba(143, 175, 177, 0.4);
            font-size: 1.15em;
            text-align: center;
        }

        .optimization-badge {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: var(--blanc);
            padding: 8px 20px;
            border-radius: 20px;
            font-weight: 600;
            display: inline-block;
            margin-left: 10px;
            font-size: 0.85em;
        }

        .phase {
            background: var(--sable);
            padding: 35px;
            border-radius: 15px;
            margin: 30px 0;
            border-left: 6px solid var(--mer);
        }

        .phase-title {
            color: var(--mer);
            font-size: 2em;
            font-weight: 700;
            margin-bottom: 25px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .form-group {
            margin-bottom: 25px;
        }

        label {
            display: block;
            font-weight: 600;
            margin-bottom: 10px;
            color: var(--gris-texte);
            font-size: 1.05em;
        }

        input[type="text"], input[type="number"], select {
            width: 100%;
            padding: 14px;
            border: 2px solid var(--vert-sauge);
            border-radius: 10px;
            font-family: 'Montserrat', sans-serif;
            font-size: 16px;
            background: var(--blanc);
            transition: all 0.3s;
        }

        input[type="text"]:focus, input[type="number"]:focus, select:focus {
            outline: none;
            border-color: var(--mer);
            box-shadow: 0 0 0 3px rgba(143, 175, 177, 0.1);
        }

        .checkbox-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 15px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .checkbox-item input[type="checkbox"] {
            width: 22px;
            height: 22px;
            cursor: pointer;
            accent-color: var(--mer);
        }

        .btn {
            background: linear-gradient(135deg, var(--mer) 0%, var(--vert-sauge) 100%);
            color: var(--blanc);
            border: none;
            padding: 18px 45px;
            border-radius: 12px;
            font-size: 1.15em;
            font-weight: 700;
            cursor: pointer;
            width: 100%;
            transition: all 0.3s;
            box-shadow: 0 4px 20px rgba(143, 175, 177, 0.4);
            font-family: 'Montserrat', sans-serif;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(143, 175, 177, 0.5);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: var(--beige-sable);
            color: var(--gris-texte);
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .btn-small {
            padding: 12px 25px;
            font-size: 0.95em;
            width: auto;
        }

        .btn-generate {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            animation: pulse-green 2s infinite;
        }

        @keyframes pulse-green {
            0%, 100% { box-shadow: 0 4px 20px rgba(40, 167, 69, 0.4); }
            50% { box-shadow: 0 8px 30px rgba(40, 167, 69, 0.6); }
        }

        .info-box {
            background: linear-gradient(135deg, var(--sable), var(--beige-sable));
            border: 3px solid var(--mer);
            border-radius: 12px;
            padding: 25px;
            margin: 25px 0;
        }

        .info-box-title {
            font-weight: 700;
            color: var(--mer);
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .info-box ul {
            margin-left: 25px;
            line-height: 2;
        }

        .split-summary {
            background: var(--blanc);
            border: 3px solid var(--vert-sauge);
            border-radius: 12px;
            padding: 25px;
            margin: 25px 0;
        }

        .part-card {
            background: var(--blanc);
            border: 3px solid var(--vert-sauge);
            border-radius: 15px;
            padding: 30px;
            margin: 25px 0;
            transition: all 0.3s;
        }

        .part-card:hover {
            border-color: var(--mer);
            box-shadow: 0 8px 25px rgba(143, 175, 177, 0.3);
        }

        .part-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .part-title {
            color: var(--mer);
            font-size: 1.8em;
            font-weight: 700;
        }

        .part-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .part-info-item {
            background: var(--sable);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .part-info-label {
            font-weight: 600;
            color: #666;
            font-size: 0.9em;
            margin-bottom: 8px;
        }

        .part-info-value {
            font-size: 1.4em;
            font-weight: 700;
            color: var(--mer);
        }

        .prompt-box {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 25px;
            border-radius: 12px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            white-space: pre-wrap;
            margin: 20px 0;
            max-height: 400px;
            overflow-y: auto;
            line-height: 1.6;
        }

        .action-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .json-textarea {
            width: 100%;
            min-height: 200px;
            padding: 15px;
            border: 2px solid var(--vert-sauge);
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            resize: vertical;
            background: #f8f9fa;
            transition: all 0.3s;
        }

        .json-textarea:focus {
            outline: none;
            border-color: var(--mer);
            box-shadow: 0 0 0 3px rgba(143, 175, 177, 0.1);
        }

        .download-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 25px;
            margin-top: 30px;
        }

        .download-item {
            background: var(--blanc);
            border: 3px solid var(--vert-sauge);
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            transition: all 0.3s;
        }

        .download-item:hover {
            border-color: var(--mer);
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(143, 175, 177, 0.3);
        }

        .download-icon {
            font-size: 4em;
            margin-bottom: 20px;
        }

        .hidden {
            display: none;
        }

        .footer {
            text-align: center;
            margin-top: 60px;
            padding-top: 30px;
            border-top: 3px solid var(--beige-sable);
            font-family: 'Montserrat', sans-serif;
            font-size: 11px;
            font-weight: 400;
            color: #000000;
        }

        .progress-indicator {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 40px 0;
            flex-wrap: wrap;
        }

        .progress-step {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .progress-circle {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--beige-sable);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 1.3em;
            color: #666;
            border: 3px solid var(--vert-sauge);
        }

        .progress-step.active .progress-circle {
            background: linear-gradient(135deg, var(--mer), var(--vert-sauge));
            color: var(--blanc);
            border-color: var(--mer);
            box-shadow: 0 4px 15px rgba(143, 175, 177, 0.4);
        }

        .progress-step.completed .progress-circle {
            background: var(--vert-sauge);
            color: var(--blanc);
            border-color: var(--mer);
        }

        .progress-label {
            font-size: 0.9em;
            font-weight: 600;
            color: #666;
        }

        .progress-step.active .progress-label {
            color: var(--mer);
            font-weight: 700;
        }

        /* Nouveau: Indicateur de mémoire */
        .memory-indicator {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border: 2px solid var(--vert-sauge);
            border-radius: 10px;
            padding: 15px 20px;
            margin: 20px 0;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .memory-bar {
            flex: 1;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
        }

        .memory-fill {
            height: 100%;
            background: linear-gradient(90deg, #28a745, #ffc107, #dc3545);
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        .memory-text {
            font-weight: 600;
            font-size: 0.9em;
            min-width: 120px;
            text-align: right;
        }

        /* Nouveau: Status de génération lazy */
        .lazy-status {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: 600;
        }

        .lazy-status.pending {
            background: #fff3cd;
            color: #856404;
        }

        .lazy-status.generating {
            background: #cce5ff;
            color: #004085;
            animation: pulse-blue 1.5s infinite;
        }

        .lazy-status.ready {
            background: #d4edda;
            color: #155724;
        }

        @keyframes pulse-blue {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* Spinner */
        .spinner {
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid var(--mer);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            display: inline-block;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .container {
                padding: 25px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            .phase {
                padding: 25px;
            }

            .part-info {
                grid-template-columns: 1fr;
            }

            .action-buttons {
                grid-template-columns: 1fr;
            }

            .download-grid {
                grid-template-columns: 1fr;
            }
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 4px 20px rgba(143, 175, 177, 0.4);
            }
            50% {
                transform: scale(1.02);
                box-shadow: 0 8px 30px rgba(143, 175, 177, 0.6);
            }
        }

        #fusionBtn {
            animation: pulse 2s infinite;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>PDF Batch PRO</h1>
        <p class="subtitle">Édition Claude Ultimate - Option C : Compromis Qualité/Taille (-35%)</p>
        
        <div style="text-align: center;">
            <span class="claude-badge">Optimisé Claude Sonnet 4.5</span>
            <span class="optimization-badge">25 Mo / partie</span>
            <span class="optimization-badge" style="background: linear-gradient(135deg, #6f42c1, #9b59b6);">~80% Qualité</span>
        </div>

        <!-- Indicateur de progression -->
        <div class="progress-indicator">
            <div class="progress-step active" id="stepIndicator1">
                <div class="progress-circle">1</div>
                <div class="progress-label">Configuration</div>
            </div>
            <div class="progress-step" id="stepIndicator2">
                <div class="progress-circle">2</div>
                <div class="progress-label">Extraction</div>
            </div>
            <div class="progress-step" id="stepIndicator3">
                <div class="progress-circle">3</div>
                <div class="progress-label">Résultats</div>
            </div>
        </div>

        <!-- PHASE 1 : Configuration -->
        <div class="phase" id="phase1">
            <div class="phase-title">Configuration du Document</div>
            
            <div class="info-box">
                <div class="info-box-title">Option C : Compromis Qualité/Taille (-35% taille, ~80% qualité)</div>
                <p style="line-height: 1.8;">
                    Cette version optimise l'équilibre entre <strong>qualité d'extraction</strong> et 
                    <strong>prévention de la troncature</strong>. Paramètres clés :
                </p>
                <ul>
                    <li><strong>PDF 25 Mo max</strong> : Plus de pages par partie (~30-35 pages)</li>
                    <li><strong>description_detaillee</strong> : 400 caractères max (au lieu de 691)</li>
                    <li><strong>contexte_therapeutique</strong> : 100 caractères max (préservé !)</li>
                    <li><strong>2-3 contenus par page</strong> : Granularité préservée</li>
                    <li><strong>6 mots-clés max</strong> : Termes essentiels conservés</li>
                    <li><strong>Index auto-reconstruits</strong> : Supprimés du JSON (gain de taille)</li>
                </ul>
                <p style="margin-top: 15px; padding: 12px; background: linear-gradient(135deg, rgba(111, 66, 193, 0.1), rgba(155, 89, 182, 0.1)); border-radius: 8px; border-left: 4px solid #6f42c1;">
                    <strong>Anti-troncature intégré :</strong> Le prompt demande explicitement à Claude de 
                    terminer proprement le JSON même s'il approche de sa limite de tokens.
                </p>
            </div>

            <!-- Indicateur mémoire -->
            <div class="memory-indicator" id="memoryIndicator" style="display: none;">
                <span>Mémoire utilisée :</span>
                <div class="memory-bar">
                    <div class="memory-fill" id="memoryFill" style="width: 0%;"></div>
                </div>
                <span class="memory-text" id="memoryText">0 Mo / estimé</span>
            </div>

            <div class="form-group">
                <label for="fileInput">Sélectionner votre PDF</label>
                <input type="file" id="fileInput" accept=".pdf" style="padding: 10px;">
            </div>

            <div id="fileInfo" class="hidden" style="margin: 25px 0;">
                <div class="split-summary" id="fileDetails"></div>
            </div>

            <div class="form-group">
                <label for="titleInput">Titre du document</label>
                <input type="text" id="titleInput" placeholder="Ex: La Thérapie de Couple - Approche Imago">
            </div>

            <div class="form-group">
                <label for="authorsInput">Auteurs (séparés par des virgules)</label>
                <input type="text" id="authorsInput" placeholder="Ex: Harville Hendrix, Helen LaKelly Hunt">
            </div>

            <div class="form-group">
                <label for="yearInput">Année de publication</label>
                <input type="number" id="yearInput" placeholder="2024" min="1900" max="2100">
            </div>

            <div class="form-group">
                <label for="domainInput">Domaine d'expertise</label>
                <select id="domainInput">
                    <option value="Thérapie de couple">Thérapie de couple</option>
                    <option value="Psychologie clinique">Psychologie clinique</option>
                    <option value="Thérapie familiale">Thérapie familiale</option>
                    <option value="Sexologie">Sexologie</option>
                    <option value="Psychothérapie">Psychothérapie</option>
                    <option value="Coaching relationnel">Coaching relationnel</option>
                </select>
            </div>

            <div class="form-group">
                <label>Approches thérapeutiques présentes</label>
                <div class="checkbox-group">
                    <div class="checkbox-item">
                        <input type="checkbox" id="app1" value="Imago">
                        <label for="app1">Imago</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="app2" value="Gottman">
                        <label for="app2">Gottman</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="app3" value="Systémique">
                        <label for="app3">Systémique</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="app4" value="EFT">
                        <label for="app4">EFT (Émotionnelle)</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="app5" value="Attachement">
                        <label for="app5">Attachement</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="app6" value="CNV">
                        <label for="app6">CNV</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="app7" value="Analyse Transactionnelle">
                        <label for="app7">Analyse Transactionnelle</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="app8" value="TCC">
                        <label for="app8">TCC</label>
                    </div>
                </div>
            </div>

            <div class="form-group">
                <label for="langInput">Langue du document</label>
                <select id="langInput">
                    <option value="Français">Français</option>
                    <option value="Anglais">Anglais</option>
                    <option value="Espagnol">Espagnol</option>
                    <option value="Italien">Italien</option>
                </select>
            </div>

            <button class="btn" onclick="validatePhase1()">Valider et Préparer les Parties</button>
        </div>

        <!-- PHASE 2 : Extraction avec Claude -->
        <div class="phase hidden" id="phase2">
            <div class="phase-title">Phase 2 : Extraction et Validation</div>
            
            <div class="split-summary" id="splitSummary"></div>

            <div class="info-box">
                <div class="info-box-title">Workflow Optimisé - Génération à la Demande</div>
                <p style="line-height: 1.8; margin-bottom: 15px;">
                    <strong>Mode économie mémoire activé :</strong> Les PDF des parties ne sont générés que 
                    lorsque vous cliquez sur "Générer et Télécharger". Cela permet de traiter des fichiers 
                    très volumineux sans saturer votre navigateur.
                </p>
                <ol style="margin-left: 25px; line-height: 2;">
                    <li>Cliquez sur <strong>"Générer et Télécharger PDF"</strong> pour créer la partie</li>
                    <li>Ouvrez Claude (claude.ai) et uploadez le PDF généré</li>
                    <li>Copiez-collez le prompt dans Claude</li>
                    <li>Attendez la génération du JSON (2-5 min)</li>
                    <li>Collez le JSON dans la zone prévue et validez</li>
                    <li>Passez à la partie suivante</li>
                </ol>
            </div>

            <div id="partsContainer"></div>

            <div class="info-box" id="fusionReady" style="display: none; background: linear-gradient(135deg, var(--vert-sauge), var(--mer)); border-color: var(--mer); color: white;">
                <div style="font-size: 1.5em; font-weight: 700; margin-bottom: 15px; text-align: center;">
                    Toutes les parties sont validées !
                </div>
                <p style="text-align: center; font-size: 1.1em;">
                    Vous pouvez maintenant fusionner tous les JSON en une base de connaissances unique.
                </p>
            </div>

            <button class="btn" id="fusionBtn" onclick="mergeAndGenerate()" style="margin-top: 30px; display: none; font-size: 1.3em; padding: 20px;">
                Fusionner Tous les JSON et Générer la Base de Connaissances
            </button>
        </div>

        <!-- PHASE 3 : Téléchargements Finaux -->
        <div class="phase hidden" id="phase3">
            <div class="phase-title">Phase 3 : Base de Connaissances Générée</div>
            
            <div class="info-box">
                <div class="info-box-title">Extraction Terminée avec Succès !</div>
                <p style="line-height: 1.8;">
                    Votre base de connaissances thérapeutique a été générée avec succès. Vous disposez maintenant 
                    de plusieurs formats exploitables pour intégrer ce contenu dans vos outils de travail, 
                    formations ou systèmes de gestion des connaissances.
                </p>
            </div>

            <div style="text-align: center; margin: 30px 0;">
                <button class="btn" onclick="downloadAllAsZip()" style="max-width: 500px; font-size: 1.2em;">
                    Télécharger Tout en ZIP
                </button>
            </div>

            <h3 style="color: var(--mer); margin: 40px 0 25px; text-align: center; font-size: 1.8em;">
                Fichiers Disponibles
            </h3>

            <div class="download-grid" id="finalDownloads"></div>

            <div style="text-align: center; margin-top: 40px;">
                <button class="btn btn-secondary" onclick="reset()">Traiter un Nouveau Document</button>
            </div>
        </div>

        <div class="footer">
            Bilan de Compétences du couple© - Marie-Christine Abatte Psychologue
        </div>
    </div>

    <script>
        // Configuration PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        const MAX_SIZE_BYTES = 25 * 1024 * 1024; // 25 MB cible - Option C optimisée
        const MAX_PAGES_PER_PART = 20; // Réduit à 20 pages par partie
        const RENDER_SCALE = 1.0; // Échelle 1.0 = 72 DPI (suffisant pour OCR)
        const JPEG_QUALITY = 0.60; // Qualité JPEG 60% (bon compromis taille/lisibilité)

        // État global de l'application
        const state = {
            pdfFile: null,
            pdfArrayBuffer: null, // Stocké une seule fois
            pdfDocument: null,    // Document PDF.js chargé
            fileSize: 0,
            totalPages: 0,
            parts: [],
            metadata: {
                titre: '',
                auteurs: [],
                annee: null,
                domaine: '',
                approches: [],
                langue: ''
            },
            uploadedJSONs: [],
            finalData: null,
            isGenerating: false
        };

        // Utilitaire: Estimation mémoire
        function updateMemoryIndicator() {
            const indicator = document.getElementById('memoryIndicator');
            const fill = document.getElementById('memoryFill');
            const text = document.getElementById('memoryText');
            
            if (!state.pdfFile) {
                indicator.style.display = 'none';
                return;
            }

            indicator.style.display = 'flex';
            
            // Estimation: fichier original + marge pour traitement
            const baseMemory = state.fileSize;
            const estimatedTotal = baseMemory * 2.5; // Estimation avec marge
            const usedMemory = state.pdfArrayBuffer ? state.fileSize : 0;
            
            const percentage = Math.min((usedMemory / estimatedTotal) * 100, 100);
            fill.style.width = percentage + '%';
            
            const usedMB = (usedMemory / (1024 * 1024)).toFixed(1);
            const totalMB = (estimatedTotal / (1024 * 1024)).toFixed(0);
            text.textContent = `${usedMB} Mo / ~${totalMB} Mo`;
        }

        // PHASE 1 : Chargement du fichier
        document.getElementById('fileInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file || file.type !== 'application/pdf') {
                alert('Veuillez sélectionner un fichier PDF valide.');
                return;
            }

            state.pdfFile = file;
            state.fileSize = file.size;

            // Lecture du fichier UNE SEULE FOIS
            try {
                state.pdfArrayBuffer = await file.arrayBuffer();
                
                // Charger le document PDF.js et le conserver
                const loadingTask = pdfjsLib.getDocument({ data: state.pdfArrayBuffer.slice(0) });
                state.pdfDocument = await loadingTask.promise;
                state.totalPages = state.pdfDocument.numPages;

                displayFileInfo();
                updateMemoryIndicator();
            } catch (error) {
                console.error('Erreur de chargement:', error);
                alert('Erreur lors du chargement du PDF: ' + error.message);
            }
        });

        function displayFileInfo() {
            document.getElementById('fileInfo').classList.remove('hidden');
            const sizeMB = (state.fileSize / (1024 * 1024)).toFixed(2);
            const avgMBPerPage = (state.fileSize / state.totalPages / (1024 * 1024)).toFixed(2);
            
            // Calcul simple: max 25 pages par partie
            const pagesPerPart = Math.min(MAX_PAGES_PER_PART, state.totalPages);
            const estimatedParts = Math.ceil(state.totalPages / pagesPerPart);
            
            // Estimation ~0.15-0.25 Mo par page en JPEG 60% à 72 DPI
            const estimatedPartSize = (pagesPerPart * 0.2).toFixed(1);
            
            const infoHTML = `
                <div style="background: #d4edda; border: 2px solid #28a745; border-radius: 8px; padding: 15px; margin-top: 15px;">
                    <strong style="color: #155724;">Méthode de découpage optimisée (Rendu Image Compressé)</strong>
                    <p style="margin: 10px 0 0; color: #155724; font-size: 0.9em;">
                        Les pages sont rendues en images JPEG compressées (72 DPI, qualité 60%) puis reconverties en PDF.
                        Taille estimée : <strong>~0.15-0.25 Mo/page</strong>.
                    </p>
                    <p style="margin: 10px 0 0; color: #155724; font-size: 0.9em;">
                        <strong>${estimatedParts} parties</strong> de ~${pagesPerPart} pages 
                        (~${estimatedPartSize} Mo estimé par partie).
                    </p>
                </div>
            `;
            
            const details = document.getElementById('fileDetails');
            details.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px;">
                    <div class="part-info-item">
                        <div class="part-info-label">Taille originale</div>
                        <div class="part-info-value">${sizeMB} MB</div>
                    </div>
                    <div class="part-info-item">
                        <div class="part-info-label">Pages totales</div>
                        <div class="part-info-value">${state.totalPages}</div>
                    </div>
                    <div class="part-info-item">
                        <div class="part-info-label">Parties prévues</div>
                        <div class="part-info-value">${estimatedParts}</div>
                    </div>
                    <div class="part-info-item">
                        <div class="part-info-label">Pages/partie</div>
                        <div class="part-info-value">~${pagesPerPart}</div>
                    </div>
                    <div class="part-info-item">
                        <div class="part-info-label">Qualité</div>
                        <div class="part-info-value">72 DPI</div>
                    </div>
                    <div class="part-info-item">
                        <div class="part-info-label">Taille estimée</div>
                        <div class="part-info-value" style="color: #28a745;">~${estimatedPartSize} MB</div>
                    </div>
                </div>
                ${infoHTML}
            `;
        }

        async function validatePhase1() {
            const titre = document.getElementById('titleInput').value.trim();
            const auteurs = document.getElementById('authorsInput').value.trim();
            const annee = document.getElementById('yearInput').value;
            const domaine = document.getElementById('domainInput').value;
            const langue = document.getElementById('langInput').value;

            if (!state.pdfFile) {
                alert('Veuillez sélectionner un fichier PDF.');
                return;
            }

            if (!titre || !auteurs) {
                alert('Veuillez remplir au minimum le titre et les auteurs.');
                return;
            }

            state.metadata = {
                titre: titre,
                auteurs: auteurs.split(',').map(a => a.trim()),
                annee: annee ? parseInt(annee) : null,
                domaine: domaine,
                approches: [],
                langue: langue
            };

            const approches = [];
            document.querySelectorAll('.checkbox-item input[type="checkbox"]:checked').forEach(cb => {
                approches.push(cb.value);
            });
            state.metadata.approches = approches;

            calculateOptimalSplit();
            displaySplitResults();

            updateProgressIndicator(2);
            document.getElementById('phase1').classList.add('hidden');
            document.getElementById('phase2').classList.remove('hidden');
            document.getElementById('phase2').scrollIntoView({ behavior: 'smooth' });
        }

        function calculateOptimalSplit() {
            // Simple: maximum 25 pages par partie
            const pagesPerPart = Math.min(MAX_PAGES_PER_PART, state.totalPages);
            const numParts = Math.ceil(state.totalPages / pagesPerPart);
            
            // Recalculer pour distribution équitable
            const actualPagesPerPart = Math.ceil(state.totalPages / numParts);

            state.parts = [];

            for (let i = 0; i < numParts; i++) {
                const startPage = i * actualPagesPerPart + 1;
                const endPage = Math.min((i + 1) * actualPagesPerPart, state.totalPages);
                const numPages = endPage - startPage + 1;
                
                // Estimation ~0.2 Mo par page en JPEG 60%
                const estimatedSize = numPages * 0.2;

                state.parts.push({
                    partNum: i + 1,
                    totalParts: numParts,
                    startPage: startPage,
                    endPage: endPage,
                    numPages: numPages,
                    estimatedSizeMB: estimatedSize.toFixed(1),
                    status: 'pending',
                    blob: null,
                    blobUrl: null
                });
            }

            state.uploadedJSONs = new Array(state.parts.length).fill(null);
            
            console.log(`Split: ${numParts} parties de ~${actualPagesPerPart} pages`);
        }

        function displaySplitResults() {
            const summary = document.getElementById('splitSummary');
            const avgPartSize = state.parts.length > 0 ? state.parts[0].estimatedSizeMB : '?';
            
            summary.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px; margin-bottom: 20px;">
                    <div class="part-info-item">
                        <div class="part-info-label">Taille totale</div>
                        <div class="part-info-value">${(state.fileSize / (1024 * 1024)).toFixed(2)} MB</div>
                    </div>
                    <div class="part-info-item">
                        <div class="part-info-label">Nombre de parties</div>
                        <div class="part-info-value">${state.parts.length}</div>
                    </div>
                    <div class="part-info-item">
                        <div class="part-info-label">Pages par partie</div>
                        <div class="part-info-value">~${state.parts.length > 0 ? state.parts[0].numPages : '?'}</div>
                    </div>
                    <div class="part-info-item">
                        <div class="part-info-label">Taille estimée/partie</div>
                        <div class="part-info-value" style="color: #28a745;">~${avgPartSize} MB</div>
                    </div>
                    <div class="part-info-item">
                        <div class="part-info-label">Garantie</div>
                        <div class="part-info-value" style="color: #28a745;">&lt; 30 MB</div>
                    </div>
                </div>
            `;

            const container = document.getElementById('partsContainer');
            container.innerHTML = '';

            state.parts.forEach(part => {
                const card = document.createElement('div');
                card.className = 'part-card';
                card.id = `partCard${part.partNum}`;
                card.innerHTML = createPartCardHTML(part);
                container.appendChild(card);
            });
        }

        function createPartCardHTML(part) {
            return `
                <div class="part-header">
                    <div class="part-title">Partie ${part.partNum}/${part.totalParts}</div>
                    <div id="partValidated${part.partNum}" style="font-size: 2em; display: none;">✅</div>
                </div>

                <div class="part-info">
                    <div class="part-info-item">
                        <div class="part-info-label">Pages</div>
                        <div class="part-info-value">${part.startPage}-${part.endPage}</div>
                    </div>
                    <div class="part-info-item">
                        <div class="part-info-label">Quantité</div>
                        <div class="part-info-value">${part.numPages} p.</div>
                    </div>
                    <div class="part-info-item">
                        <div class="part-info-label">Taille estimée</div>
                        <div class="part-info-value" style="color: #28a745;">~${part.estimatedSizeMB} MB</div>
                    </div>
                    <div class="part-info-item">
                        <div class="part-info-label">Statut PDF</div>
                        <div class="part-info-value" id="status${part.partNum}">
                            <span class="lazy-status pending">En attente</span>
                        </div>
                    </div>
                </div>

                <div style="background: var(--sable); padding: 20px; border-radius: 10px; margin: 20px 0;">
                    <h4 style="color: var(--mer); margin-bottom: 15px; font-size: 1.2em;">Prompt pour Claude</h4>
                    <div class="prompt-box" id="prompt${part.partNum}">${generateClaudePrompt(part)}</div>
                    <div class="action-buttons" style="margin-top: 15px;">
                        <button class="btn btn-secondary" onclick="copyPrompt(${part.partNum})">Copier Prompt</button>
                        <button class="btn btn-secondary" onclick="downloadPromptTxt(${part.partNum})">Télécharger Prompt.txt</button>
                        <button class="btn btn-generate btn-small" id="generateBtn${part.partNum}" onclick="generateAndDownloadPart(${part.partNum})">
                            Générer et Télécharger PDF
                        </button>
                    </div>
                </div>

                <div style="background: linear-gradient(135deg, rgba(143, 175, 177, 0.1), rgba(200, 208, 195, 0.1)); padding: 25px; border-radius: 12px; border: 3px solid var(--vert-sauge); margin-top: 25px;" id="jsonZone${part.partNum}">
                    <h4 style="color: var(--mer); margin-bottom: 15px; font-size: 1.3em; display: flex; align-items: center; gap: 10px;">
                        <span>Validation Immédiate du JSON</span>
                    </h4>
                    
                    <div id="jsonStatus${part.partNum}" style="margin-bottom: 15px; padding: 12px; background: var(--blanc); border-radius: 8px; font-weight: 600; color: #666;">
                        En attente du JSON Claude...
                    </div>
                    
                    <textarea id="jsonTextarea${part.partNum}" class="json-textarea" placeholder="Dès que Claude a terminé de générer le JSON :
1. Sélectionnez TOUT le JSON (Ctrl+A ou Cmd+A dans Claude)
2. Copiez (Ctrl+C ou Cmd+C)
3. Collez ICI (Ctrl+V ou Cmd+V)
4. Cliquez sur 'Tester le JSON' pour vérifier
5. Si valide, cliquez sur 'Valider et Enregistrer'

Le JSON sera automatiquement nettoyé et les fragments peuvent être fusionnés." oninput="enableButtons(${part.partNum})"></textarea>
                    
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 12px; margin-top: 15px;">
                        <button class="btn btn-secondary" id="testBtn${part.partNum}" onclick="previewJSON(${part.partNum})" disabled style="opacity: 0.5;">
                            Tester le JSON
                        </button>
                        <button class="btn btn-secondary" onclick="validateJSONFromTextarea(${part.partNum})" id="validateBtn${part.partNum}" disabled style="opacity: 0.5;">
                            Valider et Enregistrer
                        </button>
                        <button class="btn btn-secondary" onclick="appendFragment(${part.partNum})" title="Ajouter ce fragment au JSON accumulé">
                            + Ajouter Fragment
                        </button>
                        <button class="btn btn-secondary" onclick="clearFragments(${part.partNum})" title="Effacer les fragments accumulés">
                            Effacer Fragments
                        </button>
                        <button class="btn btn-secondary" onclick="document.getElementById('fileInput${part.partNum}').click()">
                            Upload Fichier
                        </button>
                    </div>
                    
                    <div id="fragmentInfo${part.partNum}" style="display: none; margin-top: 15px; padding: 12px; background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px;">
                        <strong style="color: #856404;">Fragments accumulés :</strong>
                        <span id="fragmentCount${part.partNum}">0</span> fragment(s) - 
                        <span id="fragmentSize${part.partNum}">0</span> caractères
                        <br><small style="color: #856404;">Collez la suite du JSON et cliquez sur "+ Ajouter Fragment". Quand c'est complet, cliquez sur "Tester le JSON".</small>
                        <br><button onclick="showMergedPreview(${part.partNum})" style="margin-top: 8px; padding: 5px 10px; font-size: 0.85em; cursor: pointer;">Voir aperçu fusionné</button>
                    </div>
                    
                    <div id="jsonPreview${part.partNum}" style="display: none; margin-top: 20px; padding: 20px; background: var(--blanc); border-radius: 10px; border: 2px solid var(--vert-sauge);"></div>
                    
                    <input type="file" id="fileInput${part.partNum}" accept=".json" onchange="handleJSONUpload(${part.partNum})" style="display: none;">
                    
                    <input type="hidden" id="accumulatedJson${part.partNum}" value="">
                </div>
            `;
        }
        
        // Stockage des fragments par partie
        const fragmentStorage = {};
        
        function appendFragment(partNum) {
            const textarea = document.getElementById(`jsonTextarea${partNum}`);
            const fragmentInfo = document.getElementById(`fragmentInfo${partNum}`);
            const fragmentCount = document.getElementById(`fragmentCount${partNum}`);
            const fragmentSize = document.getElementById(`fragmentSize${partNum}`);
            
            const newFragment = textarea.value.trim();
            if (!newFragment) {
                alert('Collez d\'abord un fragment de JSON dans la zone de texte.');
                return;
            }
            
            // Initialiser le stockage si nécessaire
            if (!fragmentStorage[partNum]) {
                fragmentStorage[partNum] = [];
            }
            
            // Ajouter le fragment
            fragmentStorage[partNum].push(newFragment);
            
            // Mettre à jour l'affichage
            fragmentInfo.style.display = 'block';
            fragmentCount.textContent = fragmentStorage[partNum].length;
            const totalSize = fragmentStorage[partNum].join('').length;
            fragmentSize.textContent = totalSize.toLocaleString();
            
            // Vider la zone de texte pour le prochain fragment
            textarea.value = '';
            textarea.placeholder = `Fragment ${fragmentStorage[partNum].length} ajouté !\n\nCollez le fragment suivant ici puis cliquez sur "+ Ajouter Fragment".\n\nQuand tous les fragments sont ajoutés, cliquez sur "Tester le JSON" pour vérifier et fusionner.`;
            
            // Feedback visuel
            const statusDiv = document.getElementById(`jsonStatus${partNum}`);
            statusDiv.innerHTML = `Fragment ${fragmentStorage[partNum].length} ajouté (${totalSize.toLocaleString()} car. au total). Continuez ou testez.`;
            statusDiv.style.color = '#856404';
            statusDiv.style.background = '#fff3cd';
        }
        
        function clearFragments(partNum) {
            fragmentStorage[partNum] = [];
            const fragmentInfo = document.getElementById(`fragmentInfo${partNum}`);
            fragmentInfo.style.display = 'none';
            
            const textarea = document.getElementById(`jsonTextarea${partNum}`);
            textarea.value = '';
            textarea.placeholder = `Dès que Claude a terminé de générer le JSON :
1. Sélectionnez TOUT le JSON (Ctrl+A ou Cmd+A dans Claude)
2. Copiez (Ctrl+C ou Cmd+C)
3. Collez ICI (Ctrl+V ou Cmd+V)

Si le JSON est coupé par Claude:
- Collez le premier morceau et cliquez "+ Ajouter Fragment"
- Demandez à Claude de continuer
- Collez la suite et cliquez à nouveau "+ Ajouter Fragment"
- Répétez jusqu'à avoir tout le JSON
- Cliquez "Tester le JSON" pour fusionner et valider`;
            
            const statusDiv = document.getElementById(`jsonStatus${partNum}`);
            statusDiv.innerHTML = 'Fragments effacés. Recommencez.';
            statusDiv.style.color = '#666';
            statusDiv.style.background = 'var(--blanc)';
        }
        
        function mergeFragments(partNum) {
            // Récupérer tous les fragments
            const fragments = fragmentStorage[partNum] || [];
            const textarea = document.getElementById(`jsonTextarea${partNum}`);
            const currentText = textarea.value.trim();
            
            // Ajouter le texte actuel s'il y en a
            let allParts = [...fragments];
            if (currentText) {
                allParts.push(currentText);
            }
            
            if (allParts.length === 0) {
                return null;
            }
            
            // Fusionner intelligemment
            let merged = '';
            
            for (let i = 0; i < allParts.length; i++) {
                let part = allParts[i].trim();
                
                // Nettoyer les marqueurs markdown
                part = part.replace(/^```json\s*/i, '');
                part = part.replace(/^```\s*/i, '');
                part = part.replace(/\s*```$/i, '');
                
                if (i === 0) {
                    merged = part;
                } else {
                    // Trouver le point de jonction
                    // Chercher un chevauchement ou simplement concaténer
                    merged = smartMerge(merged, part);
                }
            }
            
            return merged;
        }
        
        function smartMerge(str1, str2) {
            // Nettoyer les espaces en fin de str1 et début de str2
            str1 = str1.trimEnd();
            str2 = str2.trimStart();
            
            // Nettoyer les marqueurs markdown de str2
            str2 = str2.replace(/^```json\s*/i, '');
            str2 = str2.replace(/^```\s*/i, '');
            
            // FUSION SIMPLE : concaténation directe
            // C'est la méthode la plus fiable quand Claude coupe proprement
            return str1 + str2;
        }
        
        // Fonction pour afficher un aperçu du JSON fusionné (debug)
        function showMergedPreview(partNum) {
            const merged = mergeFragments(partNum);
            if (!merged) {
                alert('Aucun fragment à afficher');
                return;
            }
            
            const previewDiv = document.getElementById(`jsonPreview${partNum}`);
            previewDiv.style.display = 'block';
            
            // Montrer les 500 premiers et 500 derniers caractères
            const start = merged.substring(0, 500);
            const end = merged.substring(merged.length - 500);
            
            previewDiv.innerHTML = `
                <h4 style="color: #0066cc; margin-bottom: 15px;">Aperçu du JSON fusionné (${merged.length.toLocaleString()} car.)</h4>
                <div style="background: #f8f9fa; padding: 10px; border-radius: 8px; margin-bottom: 10px;">
                    <strong>Début :</strong>
                    <pre style="white-space: pre-wrap; font-size: 0.8em; max-height: 150px; overflow: auto;">${escapeHtml(start)}...</pre>
                </div>
                <div style="background: #f8f9fa; padding: 10px; border-radius: 8px;">
                    <strong>Fin :</strong>
                    <pre style="white-space: pre-wrap; font-size: 0.8em; max-height: 150px; overflow: auto;">...${escapeHtml(end)}</pre>
                </div>
                <p style="margin-top: 10px; font-size: 0.85em; color: #666;">
                    Vérifiez que le début commence par <code>{</code> et la fin termine par <code>}</code>
                </p>
            `;
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // GÉNÉRATION À LA DEMANDE (LAZY LOADING)
        async function generateAndDownloadPart(partNum) {
            const part = state.parts[partNum - 1];
            const btn = document.getElementById(`generateBtn${partNum}`);
            const statusDiv = document.getElementById(`status${partNum}`);

            // Éviter les doubles clics
            if (state.isGenerating) {
                alert('Une génération est déjà en cours. Veuillez patienter.');
                return;
            }

            // Vérifier si déjà généré et en cache
            if (part.blob && part.blobUrl) {
                downloadPartFile(partNum);
                return;
            }

            state.isGenerating = true;
            btn.disabled = true;
            btn.innerHTML = '<span class="spinner"></span> Rendu page 0/' + part.numPages + '...';
            statusDiv.innerHTML = '<span class="lazy-status generating"><span class="spinner"></span> Rendu en cours...</span>';

            try {
                const { jsPDF } = window.jspdf;
                
                // Créer un canvas hors-écran pour le rendu
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                let pdf = null;
                
                // Rendre chaque page
                for (let pageNum = part.startPage; pageNum <= part.endPage; pageNum++) {
                    // Mise à jour du statut
                    const currentPage = pageNum - part.startPage + 1;
                    btn.innerHTML = `<span class="spinner"></span> Rendu page ${currentPage}/${part.numPages}...`;
                    
                    // Obtenir la page
                    const page = await state.pdfDocument.getPage(pageNum);
                    const viewport = page.getViewport({ scale: RENDER_SCALE });
                    
                    // Configurer le canvas
                    canvas.width = viewport.width;
                    canvas.height = viewport.height;
                    
                    // Fond blanc
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Rendre la page
                    await page.render({
                        canvasContext: ctx,
                        viewport: viewport
                    }).promise;
                    
                    // Convertir en JPEG
                    const imgData = canvas.toDataURL('image/jpeg', JPEG_QUALITY);
                    
                    // Créer le PDF ou ajouter une page
                    if (pageNum === part.startPage) {
                        // Première page: créer le PDF avec les dimensions de la page
                        const orientation = viewport.width > viewport.height ? 'l' : 'p';
                        pdf = new jsPDF({
                            orientation: orientation,
                            unit: 'px',
                            format: [viewport.width, viewport.height],
                            compress: true
                        });
                        pdf.addImage(imgData, 'JPEG', 0, 0, viewport.width, viewport.height, undefined, 'FAST');
                    } else {
                        // Pages suivantes
                        const orientation = viewport.width > viewport.height ? 'l' : 'p';
                        pdf.addPage([viewport.width, viewport.height], orientation);
                        pdf.addImage(imgData, 'JPEG', 0, 0, viewport.width, viewport.height, undefined, 'FAST');
                    }
                    
                    // Libérer la mémoire de la page
                    page.cleanup();
                    
                    // Permettre à l'interface de respirer
                    await new Promise(resolve => setTimeout(resolve, 10));
                }
                
                // Générer le blob PDF
                const pdfBlob = pdf.output('blob');
                const actualSize = pdfBlob.size;
                const actualSizeMB = (actualSize / (1024 * 1024)).toFixed(2);
                
                // Créer l'URL
                part.blob = pdfBlob;
                part.blobUrl = URL.createObjectURL(pdfBlob);
                part.status = 'ready';
                part.actualSizeMB = actualSizeMB;

                // Statut final
                let statusHTML = '';
                if (actualSize > 30 * 1024 * 1024) {
                    statusHTML = `<span class="lazy-status" style="background: #f8d7da; color: #721c24;">
                        ${actualSizeMB} MB - Trop gros!
                    </span>`;
                    alert(`La partie générée fait ${actualSizeMB} Mo. Essayez de réduire RENDER_SCALE ou JPEG_QUALITY dans le code.`);
                } else {
                    statusHTML = `<span class="lazy-status ready">${actualSizeMB} MB</span>`;
                }

                statusDiv.innerHTML = statusHTML;
                btn.innerHTML = 'Re-télécharger PDF';
                btn.disabled = false;

                // Télécharger automatiquement
                downloadPartFile(partNum);

                // Nettoyer la mémoire après un délai
                setTimeout(() => {
                    cleanupPartMemory(partNum);
                }, 60000);

            } catch (error) {
                console.error('Erreur de génération:', error);
                statusDiv.innerHTML = '<span class="lazy-status" style="background: #f8d7da; color: #721c24;">Erreur</span>';
                btn.innerHTML = 'Réessayer';
                btn.disabled = false;
                alert('Erreur lors de la génération: ' + error.message);
            } finally {
                state.isGenerating = false;
            }
        }

        function downloadPartFile(partNum) {
            const part = state.parts[partNum - 1];
            if (!part.blobUrl) {
                alert('Le fichier n\'est pas encore prêt. Cliquez sur "Générer et Télécharger PDF".');
                return;
            }

            const a = document.createElement('a');
            a.href = part.blobUrl;
            const fileName = `part${String(partNum).padStart(2, '0')}_${state.metadata.titre.substring(0, 30).replace(/[^a-z0-9]/gi, '_')}.pdf`;
            a.download = fileName;
            a.click();
        }

        function cleanupPartMemory(partNum) {
            const part = state.parts[partNum - 1];
            if (part.blobUrl) {
                URL.revokeObjectURL(part.blobUrl);
                part.blobUrl = null;
            }
            part.blob = null;
            part.status = 'pending';
            
            const statusDiv = document.getElementById(`status${partNum}`);
            const btn = document.getElementById(`generateBtn${partNum}`);
            
            if (statusDiv && !state.uploadedJSONs[partNum - 1]) {
                statusDiv.innerHTML = '<span class="lazy-status pending">En attente</span>';
            }
            if (btn && !state.uploadedJSONs[partNum - 1]) {
                btn.innerHTML = 'Générer et Télécharger PDF';
            }
        }

        // GÉNÉRATION DU PROMPT CLAUDE - VERSION OPTION C (COMPROMIS QUALITÉ/TAILLE)
        function generateClaudePrompt(part) {
            const meta = state.metadata;
            const isMulti = part.totalParts > 1;
            
            return `# ${isMulti ? `PARTIE ${part.partNum}/${part.totalParts} | ` : ''}EXTRACTION EXPERTE CLAUDE - OPTION C

${isMulti ? `Pages ${part.startPage}-${part.endPage} (${part.numPages} pages)\n\n` : ''}DOCUMENT : ${meta.titre}
AUTEURS : ${meta.auteurs.join(', ')}
ANNÉE : ${meta.annee || 'N/A'}
APPROCHES : ${meta.approches.join(', ') || 'À identifier'}
DOMAINE : ${meta.domaine}
LANGUE : ${meta.langue}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

MISSION : Extraction Thérapeutique de Haute Fidélité (Format Optimisé)

Tu es Claude Sonnet 4.5. Extrais le contenu avec FIDÉLITÉ ABSOLUE au texte original 
et une structure PROFESSIONNELLE. Le format est optimisé pour éviter la troncature 
tout en préservant la qualité thérapeutique.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

RÈGLES D'EXTRACTION OPTION C

1. FIDÉLITÉ AU CONTENU
   - Terminologie EXACTE de l'auteur
   - Sens et intention respectés
   - Citations textuelles si essentielles (1 max par section)

2. LIMITES DE TAILLE (CRITIQUES)
   - description_detaillee : 400 caractères MAXIMUM
   - contexte_therapeutique : 100 caractères MAXIMUM
   - mots_cles_experts : 6 termes MAXIMUM
   - Contenus par page : 2-3 MAXIMUM (regrouper si nécessaire)

3. ÉLÉMENTS SUPPRIMÉS (reconstruits automatiquement)
   - NE PAS générer : index_concepts, index_mots_cles, index_auteurs_cites
   - NE PAS générer : description_courte (utiliser uniquement description_detaillee)
   - NE PAS générer : notes_cliniques (fusionner dans contexte_therapeutique)
   - NE PAS générer : references_internes

4. ANTI-TRONCATURE
   - Si tu approches de la limite de tokens, TERMINE proprement le JSON
   - Ferme TOUS les crochets et accolades
   - Génère TOUJOURS la section statistiques à la fin
   - Un JSON tronqué est INUTILISABLE

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

FORMAT JSON OPTION C (STRICTEMENT RESPECTÉ)

{
  "part_info": ${isMulti ? `{
    "part_number": ${part.partNum},
    "total_parts": ${part.totalParts},
    "page_range": [${part.startPage}, ${part.endPage}]
  }` : 'null'},
  "document_metadata": {
    "id": "${meta.titre.substring(0, 30).toLowerCase().replace(/[^a-z0-9]/g, '_')}",
    "titre": "${meta.titre}",
    "auteurs": ${JSON.stringify(meta.auteurs)},
    "annee_publication": ${meta.annee || 'null'},
    "approches_therapeutiques": ${JSON.stringify(meta.approches)},
    "domaine_expertise": "${meta.domaine}",
    "langue": "${meta.langue}",
    "niveau_expertise": "professionnel_expert",
    "pages_total": ${part.numPages}
  },
  "structure_hierarchique": {
    "chapitres": [
      {
        "chapitre_id": "ch01",
        "numero": 1,
        "titre": "TITRE EXACT DU CHAPITRE",
        "pages": [${part.startPage}, ${part.endPage}],
        "resume_chapitre": "Synthèse en 1-2 phrases (150 chars max)",
        "sections": [
          {
            "section_id": "ch01_s01",
            "titre": "Titre exact de la section",
            "contenus": [
              {
                "contenu_id": "ch01_s01_c001",
                "type": "concept_theorique|framework|outil_therapeutique|exercice_pratique|cas_clinique",
                "titre": "Titre précis et descriptif",
                "pages": [${part.startPage}],
                "taxonomie": {
                  "categorie_principale": "attachment|communication|conflict|intimacy|emotion_regulation|trauma|development",
                  "niveau_complexite": "fondamental|intermediaire|avance|expert"
                },
                "description_detaillee": "Explication fidèle du concept (400 chars MAX). Inclure l'essentiel du contenu thérapeutique avec la terminologie exacte de l'auteur.",
                "contexte_therapeutique": "Application clinique concrète (100 chars MAX)",
                "mots_cles_experts": ["terme1", "terme2", "terme3", "terme4", "terme5", "terme6"],
                "auteurs_references": ["Nom Auteur si cité"],
                "citation": "Citation textuelle essentielle si pertinente (p.X)"
              }
            ]
          }
        ]
      }
    ]
  },
  "statistiques": {
    "total_chapitres": 0,
    "total_sections": 0,
    "total_concepts": 0,
    "total_frameworks": 0,
    "total_outils": 0,
    "total_exercices": 0,
    "total_cas_cliniques": 0,
    "total_citations": 0,
    "pages_analysees": ${part.numPages}
  }
}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

CHECKLIST QUALITÉ

Avant de finaliser, vérifie :

COMPLÉTUDE
  [x] Toutes les pages ${part.startPage}-${part.endPage} analysées
  [x] Concepts importants extraits (2-3 par page)
  [x] Frameworks, outils, exercices identifiés

LIMITES RESPECTÉES
  [x] description_detaillee ≤ 400 caractères
  [x] contexte_therapeutique ≤ 100 caractères
  [x] mots_cles_experts ≤ 6 termes
  [x] Pas d'index (index_concepts, index_mots_cles, index_auteurs_cites)

TECHNIQUE
  [x] JSON strictement valide
  [x] Statistiques exactes et cohérentes
  [x] Toutes les accolades/crochets fermés

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

GÉNÈRE MAINTENANT le JSON complet. Qualité thérapeutique + Format optimisé.

Ta réponse doit être UNIQUEMENT le JSON valide, sans aucun texte additionnel.`;
        }

        function copyPrompt(partNum) {
            const part = state.parts[partNum - 1];
            const prompt = generateClaudePrompt(part);
            navigator.clipboard.writeText(prompt).then(() => {
                alert('Prompt copié dans le presse-papiers !');
            });
        }

        function downloadPromptTxt(partNum) {
            const part = state.parts[partNum - 1];
            const prompt = generateClaudePrompt(part);
            const blob = new Blob([prompt], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const fileName = `prompt_claude_part${partNum}_${state.metadata.titre.substring(0, 30).replace(/[^a-z0-9]/gi, '_')}.txt`;
            a.download = fileName;
            a.click();
            URL.revokeObjectURL(url);
        }

        // GESTION JSON
        function cleanJSON(rawText) {
            let cleaned = rawText.trim();
            
            // Supprimer les blocs markdown au début (plusieurs variantes)
            cleaned = cleaned.replace(/^```json\s*/i, '');
            cleaned = cleaned.replace(/^```JSON\s*/i, '');
            cleaned = cleaned.replace(/^```\s*/i, '');
            cleaned = cleaned.replace(/^`+\s*/i, ''); // Un ou plusieurs backticks
            
            // Supprimer les blocs markdown à la fin
            cleaned = cleaned.replace(/\s*```$/i, '');
            cleaned = cleaned.replace(/\s*`+$/i, ''); // Un ou plusieurs backticks
            
            // Supprimer les commentaires JavaScript (peuvent casser le JSON)
            // Attention: ne pas supprimer // dans les URLs
            cleaned = cleaned.replace(/(?<!")\/\/(?![\w./-]*")[^\n]*/g, '');
            cleaned = cleaned.replace(/\/\*[\s\S]*?\*\//g, '');
            
            // Supprimer les virgules trailing (avant } ou ])
            cleaned = cleaned.replace(/,(\s*[}\]])/g, '$1');
            
            // Supprimer les caractères de contrôle invisibles (sauf newline et tab)
            cleaned = cleaned.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '');
            
            // Supprimer le BOM UTF-8 s'il existe
            cleaned = cleaned.replace(/^\uFEFF/, '');
            
            // S'assurer que ça commence par { et finit par }
            const firstBrace = cleaned.indexOf('{');
            const lastBrace = cleaned.lastIndexOf('}');
            
            if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
                cleaned = cleaned.substring(firstBrace, lastBrace + 1);
            }
            
            return cleaned;
        }

        function enableButtons(partNum) {
            const textarea = document.getElementById(`jsonTextarea${partNum}`);
            const hasContent = textarea && textarea.value.trim().length > 0;
            const hasFragments = fragmentStorage[partNum] && fragmentStorage[partNum].length > 0;
            
            const testBtn = document.getElementById(`testBtn${partNum}`);
            const validateBtn = document.getElementById(`validateBtn${partNum}`);
            const statusDiv = document.getElementById(`jsonStatus${partNum}`);
            
            // Activer si contenu OU fragments
            const canProcess = hasContent || hasFragments;
            
            if (testBtn && validateBtn) {
                testBtn.disabled = !canProcess;
                validateBtn.disabled = !canProcess;
                testBtn.style.opacity = canProcess ? '1' : '0.5';
                validateBtn.style.opacity = canProcess ? '1' : '0.5';
            }
            
            if (statusDiv && hasContent && !hasFragments) {
                statusDiv.innerHTML = 'JSON collé ! Cliquez sur "Tester" puis "Valider"';
                statusDiv.style.color = '#0066cc';
                statusDiv.style.background = '#e3f2fd';
            }
        }

        function previewJSON(partNum) {
            const textarea = document.getElementById(`jsonTextarea${partNum}`);
            const previewDiv = document.getElementById(`jsonPreview${partNum}`);
            const statusDiv = document.getElementById(`jsonStatus${partNum}`);
            
            // Essayer d'abord de fusionner les fragments s'il y en a
            let rawText = mergeFragments(partNum);
            
            // Si pas de fragments, utiliser le texte de la textarea
            if (!rawText) {
                rawText = textarea.value.trim();
            }
            
            if (!rawText) {
                alert('Veuillez coller le JSON de Claude d\'abord, ou ajouter des fragments.');
                return;
            }

            const cleaned = cleanJSON(rawText);
            
            // Afficher la taille du JSON fusionné
            console.log(`JSON fusionné: ${cleaned.length} caractères`);

            try {
                const json = JSON.parse(cleaned);
                
                // Effacer les fragments après succès
                fragmentStorage[partNum] = [];
                const fragmentInfo = document.getElementById(`fragmentInfo${partNum}`);
                if (fragmentInfo) fragmentInfo.style.display = 'none';
                
                // Mettre le JSON fusionné dans la textarea pour validation
                textarea.value = cleaned;
                
                const stats = json.statistiques || {};
                const metadata = json.document_metadata || {};
                const chapitres = json.structure_hierarchique?.chapitres || [];
                
                // Compter les contenus
                let totalContenus = 0;
                chapitres.forEach(ch => {
                    if (ch.sections) {
                        ch.sections.forEach(s => {
                            if (s.contenus) totalContenus += s.contenus.length;
                        });
                    }
                });
                
                previewDiv.style.display = 'block';
                previewDiv.innerHTML = `
                    <h4 style="color: #28a745; margin-bottom: 15px;">JSON Valide ! (${cleaned.length.toLocaleString()} caractères)</h4>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px;">
                        <div style="background: #e8f5e9; padding: 10px; border-radius: 8px; text-align: center;">
                            <div style="font-size: 1.5em; font-weight: 700; color: #2e7d32;">${chapitres.length}</div>
                            <div style="font-size: 0.85em; color: #666;">Chapitres</div>
                        </div>
                        <div style="background: #e3f2fd; padding: 10px; border-radius: 8px; text-align: center;">
                            <div style="font-size: 1.5em; font-weight: 700; color: #1565c0;">${totalContenus}</div>
                            <div style="font-size: 0.85em; color: #666;">Contenus</div>
                        </div>
                        <div style="background: #fff3e0; padding: 10px; border-radius: 8px; text-align: center;">
                            <div style="font-size: 1.5em; font-weight: 700; color: #e65100;">${stats.total_outils || 0}</div>
                            <div style="font-size: 0.85em; color: #666;">Outils</div>
                        </div>
                        <div style="background: #fce4ec; padding: 10px; border-radius: 8px; text-align: center;">
                            <div style="font-size: 1.5em; font-weight: 700; color: #c2185b;">${stats.total_exercices || 0}</div>
                            <div style="font-size: 0.85em; color: #666;">Exercices</div>
                        </div>
                    </div>
                    <p style="margin-top: 15px; color: #28a745; font-weight: 600;">
                        Cliquez sur "Valider et Enregistrer" pour confirmer cette partie.
                    </p>
                `;
                
                statusDiv.innerHTML = 'JSON fusionné et validé ! Prêt à enregistrer.';
                statusDiv.style.color = '#28a745';
                statusDiv.style.background = '#d4edda';
                
            } catch (e) {
                // Essayer de réparer le JSON incomplet
                const repairSuggestion = tryRepairJSON(cleaned);
                
                previewDiv.style.display = 'block';
                previewDiv.innerHTML = `
                    <h4 style="color: #dc3545; margin-bottom: 15px;">Erreur de Syntaxe JSON</h4>
                    <p style="background: #f8d7da; padding: 15px; border-radius: 8px; font-family: monospace; font-size: 0.85em;">
                        ${e.message}
                    </p>
                    <div style="margin-top: 15px; padding: 15px; background: #fff3cd; border-radius: 8px;">
                        <strong style="color: #856404;">Diagnostic :</strong>
                        <p style="margin-top: 10px; color: #856404; font-size: 0.9em;">
                            ${repairSuggestion}
                        </p>
                    </div>
                    <div style="margin-top: 15px; display: flex; gap: 10px; flex-wrap: wrap;">
                        <button onclick="advancedRepair(${partNum})" class="btn btn-secondary btn-small" style="background: #28a745; color: white;">
                            Réparation Avancée
                        </button>
                        <button onclick="attemptAutoRepair(${partNum})" class="btn btn-secondary btn-small">
                            Réparation Simple
                        </button>
                        <button onclick="fullDiagnosis(${partNum})" class="btn btn-secondary btn-small" style="background: #0066cc; color: white;">
                            Diagnostic
                        </button>
                        <button onclick="showMergedPreview(${partNum})" class="btn btn-secondary btn-small">
                            Voir JSON brut
                        </button>
                    </div>
                    <p style="margin-top: 15px; color: #666; font-size: 0.85em;">
                        <strong>Autre solution :</strong> Demandez à Claude de "continuer le JSON exactement où il s'est arrêté" 
                        et utilisez "+ Ajouter Fragment".
                    </p>
                `;
                
                statusDiv.innerHTML = 'JSON incomplet - Essayez "Réparer auto" ou ajoutez la suite';
                statusDiv.style.color = '#856404';
                statusDiv.style.background = '#fff3cd';
            }
        }
        
        function attemptAutoRepair(partNum) {
            const textarea = document.getElementById(`jsonTextarea${partNum}`);
            const statusDiv = document.getElementById(`jsonStatus${partNum}`);
            
            // Récupérer le JSON (fusionné ou direct)
            let rawText = mergeFragments(partNum);
            if (!rawText) {
                rawText = textarea.value.trim();
            }
            
            if (!rawText) {
                alert('Aucun JSON à réparer');
                return;
            }
            
            // Nettoyer d'abord
            let cleaned = cleanJSON(rawText);
            
            // Tenter la réparation
            const repaired = autoRepairJSON(cleaned);
            
            // Mettre le JSON réparé dans la textarea
            textarea.value = repaired;
            
            // Effacer les fragments
            fragmentStorage[partNum] = [];
            const fragmentInfo = document.getElementById(`fragmentInfo${partNum}`);
            if (fragmentInfo) fragmentInfo.style.display = 'none';
            
            // Tester à nouveau
            statusDiv.innerHTML = 'Réparation tentée - Test en cours...';
            statusDiv.style.color = '#0066cc';
            statusDiv.style.background = '#e3f2fd';
            
            // Relancer le test
            setTimeout(() => previewJSON(partNum), 100);
        }
        
        function tryRepairJSON(jsonStr) {
            // Compter les accolades et crochets
            const openBraces = (jsonStr.match(/{/g) || []).length;
            const closeBraces = (jsonStr.match(/}/g) || []).length;
            const openBrackets = (jsonStr.match(/\[/g) || []).length;
            const closeBrackets = (jsonStr.match(/\]/g) || []).length;
            
            const missingBraces = openBraces - closeBraces;
            const missingBrackets = openBrackets - closeBrackets;
            
            let suggestion = '';
            
            if (missingBraces > 0 || missingBrackets > 0) {
                suggestion = `<strong>Éléments manquants :</strong> `;
                if (missingBrackets > 0) suggestion += `${missingBrackets} crochet(s) fermant <code>]</code> `;
                if (missingBraces > 0) suggestion += `${missingBraces} accolade(s) fermante <code>}</code> `;
            }
            
            // Vérifier si ça finit au milieu d'une chaîne
            const lastQuote = jsonStr.lastIndexOf('"');
            const afterLastQuote = jsonStr.slice(lastQuote + 1).trim();
            
            // Trouver la position approximative de l'erreur
            const last100 = jsonStr.slice(-100);
            suggestion += `<br><br><strong>Fin du JSON :</strong><br><code style="font-size: 0.8em; background: #f8f9fa; padding: 5px; display: block; white-space: pre-wrap; max-height: 100px; overflow: auto;">${escapeHtml(last100)}</code>`;
            
            return suggestion || 'Vérifiez que tout le JSON a été copié.';
        }
        
        // Fonction pour tenter une réparation automatique du JSON
        function autoRepairJSON(jsonStr) {
            let repaired = jsonStr.trim();
            
            // Supprimer les marqueurs markdown
            repaired = repaired.replace(/^```json\s*/i, '');
            repaired = repaired.replace(/^```\s*/i, '');
            repaired = repaired.replace(/\s*```$/i, '');
            
            // Supprimer les virgules trailing avant } ou ]
            repaired = repaired.replace(/,(\s*[}\]])/g, '$1');
            
            // Compter les éléments manquants
            const openBraces = (repaired.match(/{/g) || []).length;
            const closeBraces = (repaired.match(/}/g) || []).length;
            const openBrackets = (repaired.match(/\[/g) || []).length;
            const closeBrackets = (repaired.match(/\]/g) || []).length;
            
            // Si le JSON est coupé au milieu d'une chaîne, fermer la chaîne
            const lastQuoteIndex = repaired.lastIndexOf('"');
            const afterQuote = repaired.slice(lastQuoteIndex + 1);
            const quotesInAfter = (afterQuote.match(/"/g) || []).length;
            
            // Si nombre impair de guillemets après le dernier, on est dans une chaîne
            if (quotesInAfter % 2 === 0 && !afterQuote.includes(':') && !afterQuote.includes(',')) {
                // On est peut-être au milieu d'une valeur, ajouter un guillemet fermant
                // Mais c'est risqué, on ne le fait pas automatiquement
            }
            
            // Ajouter les crochets et accolades manquants
            const missingBrackets = openBrackets - closeBrackets;
            const missingBraces = openBraces - closeBraces;
            
            // Ajouter d'abord les crochets, puis les accolades
            for (let i = 0; i < missingBrackets; i++) {
                repaired += ']';
            }
            for (let i = 0; i < missingBraces; i++) {
                repaired += '}';
            }
            
            return repaired;
        }
        
        // Diagnostic avancé : trouve exactement où le JSON est cassé
        function findJSONError(jsonStr) {
            let position = 0;
            let line = 1;
            let column = 1;
            let inString = false;
            let escapeNext = false;
            let stack = [];
            let lastGoodPosition = 0;
            
            for (let i = 0; i < jsonStr.length; i++) {
                const char = jsonStr[i];
                
                // Gestion des nouvelles lignes
                if (char === '\n') {
                    line++;
                    column = 1;
                } else {
                    column++;
                }
                
                // Gestion de l'échappement dans les chaînes
                if (escapeNext) {
                    escapeNext = false;
                    continue;
                }
                
                if (char === '\\' && inString) {
                    escapeNext = true;
                    continue;
                }
                
                // Entrée/sortie de chaîne
                if (char === '"' && !escapeNext) {
                    inString = !inString;
                    if (!inString) lastGoodPosition = i;
                    continue;
                }
                
                // Si dans une chaîne, on continue
                if (inString) continue;
                
                // Gestion de la structure
                if (char === '{' || char === '[') {
                    stack.push({ char, pos: i, line, column });
                    lastGoodPosition = i;
                } else if (char === '}') {
                    if (stack.length === 0 || stack[stack.length - 1].char !== '{') {
                        return {
                            error: `Accolade fermante '}' inattendue`,
                            position: i,
                            line,
                            column,
                            context: getContext(jsonStr, i)
                        };
                    }
                    stack.pop();
                    lastGoodPosition = i;
                } else if (char === ']') {
                    if (stack.length === 0 || stack[stack.length - 1].char !== '[') {
                        return {
                            error: `Crochet fermant ']' inattendu`,
                            position: i,
                            line,
                            column,
                            context: getContext(jsonStr, i)
                        };
                    }
                    stack.pop();
                    lastGoodPosition = i;
                }
            }
            
            // Vérifier si on est resté dans une chaîne
            if (inString) {
                return {
                    error: `Chaîne de texte non fermée (guillemet manquant)`,
                    position: jsonStr.length,
                    line,
                    column,
                    context: getContext(jsonStr, jsonStr.length - 50),
                    suggestion: `Le JSON est coupé au milieu d'un texte. Ajoutez un guillemet " puis les accolades/crochets manquants.`
                };
            }
            
            // Vérifier si des éléments ne sont pas fermés
            if (stack.length > 0) {
                const unclosed = stack.map(s => s.char === '{' ? 'accolade {' : 'crochet [').join(', ');
                return {
                    error: `Éléments non fermés : ${stack.length} (${unclosed})`,
                    position: jsonStr.length,
                    line,
                    column,
                    context: getContext(jsonStr, lastGoodPosition),
                    suggestion: `Ajoutez ${stack.reverse().map(s => s.char === '{' ? '}' : ']').join('')} à la fin.`,
                    autoFix: stack.reverse().map(s => s.char === '{' ? '}' : ']').join('')
                };
            }
            
            return null; // Pas d'erreur structurelle évidente
        }
        
        function getContext(str, pos) {
            const start = Math.max(0, pos - 40);
            const end = Math.min(str.length, pos + 40);
            const before = str.slice(start, pos);
            const after = str.slice(pos, end);
            return { before, after, position: pos };
        }
        
        // Fonction de diagnostic complète
        function fullDiagnosis(partNum) {
            const textarea = document.getElementById(`jsonTextarea${partNum}`);
            const previewDiv = document.getElementById(`jsonPreview${partNum}`);
            
            let rawText = mergeFragments(partNum);
            if (!rawText) {
                rawText = textarea.value.trim();
            }
            
            if (!rawText) {
                alert('Aucun JSON à diagnostiquer');
                return;
            }
            
            const cleaned = cleanJSON(rawText);
            const diagnosis = findJSONError(cleaned);
            
            previewDiv.style.display = 'block';
            
            if (diagnosis) {
                let html = `
                    <h4 style="color: #dc3545; margin-bottom: 15px;">Diagnostic Avancé</h4>
                    <div style="background: #f8d7da; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <strong>Erreur trouvée :</strong> ${diagnosis.error}<br>
                        <strong>Position :</strong> caractère ${diagnosis.position} (ligne ${diagnosis.line}, colonne ${diagnosis.column})
                    </div>
                `;
                
                if (diagnosis.context) {
                    html += `
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                            <strong>Contexte autour de l'erreur :</strong>
                            <pre style="white-space: pre-wrap; font-size: 0.85em; margin-top: 10px;">...${escapeHtml(diagnosis.context.before)}<span style="background: #dc3545; color: white; padding: 2px 4px;">▼ICI</span>${escapeHtml(diagnosis.context.after)}...</pre>
                        </div>
                    `;
                }
                
                if (diagnosis.suggestion) {
                    html += `
                        <div style="background: #d4edda; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                            <strong>Suggestion :</strong> ${diagnosis.suggestion}
                        </div>
                    `;
                }
                
                if (diagnosis.autoFix) {
                    html += `
                        <button onclick="applyAutoFix(${partNum}, '${diagnosis.autoFix}')" class="btn btn-secondary btn-small" style="background: #28a745; color: white;">
                            Appliquer la correction : ajouter "${escapeHtml(diagnosis.autoFix)}"
                        </button>
                    `;
                }
                
                previewDiv.innerHTML = html;
            } else {
                // Pas d'erreur structurelle, le problème est ailleurs
                previewDiv.innerHTML = `
                    <h4 style="color: #856404; margin-bottom: 15px;">Diagnostic</h4>
                    <p>Pas d'erreur structurelle évidente (accolades/crochets équilibrés).</p>
                    <p>Le problème peut être :</p>
                    <ul style="margin-left: 20px; margin-top: 10px;">
                        <li>Une virgule en trop ou manquante</li>
                        <li>Un deux-points manquant après une clé</li>
                        <li>Une valeur invalide (ex: texte sans guillemets)</li>
                    </ul>
                    <p style="margin-top: 15px;">Taille du JSON : ${cleaned.length.toLocaleString()} caractères</p>
                    <button onclick="downloadJSONForDebug(${partNum})" class="btn btn-secondary btn-small" style="margin-top: 10px;">
                        Télécharger JSON pour debug externe
                    </button>
                `;
            }
        }
        
        function applyAutoFix(partNum, fix) {
            const textarea = document.getElementById(`jsonTextarea${partNum}`);
            let content = mergeFragments(partNum) || textarea.value;
            content = cleanJSON(content);
            
            // Appliquer le fix
            textarea.value = content + fix;
            
            // Effacer les fragments
            fragmentStorage[partNum] = [];
            const fragmentInfo = document.getElementById(`fragmentInfo${partNum}`);
            if (fragmentInfo) fragmentInfo.style.display = 'none';
            
            // Retester
            previewJSON(partNum);
        }
        
        // Fonction pour corriger l'erreur à une position spécifique
        function fixAtPosition(partNum, position, action) {
            const textarea = document.getElementById(`jsonTextarea${partNum}`);
            let content = mergeFragments(partNum) || textarea.value;
            content = cleanJSON(content);
            
            if (action === 'remove') {
                // Supprimer le caractère à cette position
                content = content.substring(0, position) + content.substring(position + 1);
            } else if (action === 'addBrace') {
                // Ajouter une accolade fermante avant cette position
                content = content.substring(0, position) + '}' + content.substring(position);
            } else if (action === 'addBracket') {
                // Ajouter un crochet fermant avant cette position
                content = content.substring(0, position) + ']' + content.substring(position);
            }
            
            textarea.value = content;
            fragmentStorage[partNum] = [];
            const fragmentInfo = document.getElementById(`fragmentInfo${partNum}`);
            if (fragmentInfo) fragmentInfo.style.display = 'none';
            
            previewJSON(partNum);
        }
        
        // Analyse approfondie pour trouver où la structure se casse
        function deepAnalysis(partNum) {
            const textarea = document.getElementById(`jsonTextarea${partNum}`);
            const previewDiv = document.getElementById(`jsonPreview${partNum}`);
            
            let content = mergeFragments(partNum) || textarea.value;
            content = cleanJSON(content);
            
            // Parser progressivement pour trouver où ça casse
            let lastValidPosition = 0;
            let testLength = 1000;
            
            while (testLength < content.length) {
                const partial = content.substring(0, testLength);
                
                // Essayer de parser en ajoutant des fermetures
                const completed = tryComplete(partial);
                try {
                    JSON.parse(completed);
                    lastValidPosition = testLength;
                    testLength += 1000;
                } catch (e) {
                    // Affiner la recherche
                    break;
                }
            }
            
            // Recherche binaire pour trouver la position exacte
            let low = lastValidPosition;
            let high = Math.min(testLength, content.length);
            
            while (high - low > 10) {
                const mid = Math.floor((low + high) / 2);
                const partial = content.substring(0, mid);
                const completed = tryComplete(partial);
                try {
                    JSON.parse(completed);
                    low = mid;
                } catch (e) {
                    high = mid;
                }
            }
            
            // Montrer le contexte autour de la position problématique
            const problemArea = content.substring(Math.max(0, low - 100), Math.min(content.length, high + 100));
            const lineNum = content.substring(0, low).split('\n').length;
            
            previewDiv.style.display = 'block';
            previewDiv.innerHTML = `
                <h4 style="color: #0066cc;">Analyse Approfondie</h4>
                <p>Le JSON est valide jusqu'au caractère ~${low} (ligne ~${lineNum})</p>
                <p>Le problème se situe dans cette zone :</p>
                <pre style="background: #f8f9fa; padding: 15px; border-radius: 8px; white-space: pre-wrap; font-size: 0.8em; max-height: 300px; overflow: auto;">${escapeHtml(problemArea)}</pre>
                <div style="margin-top: 15px;">
                    <p><strong>Actions possibles :</strong></p>
                    <button onclick="fixAtPosition(${partNum}, ${high}, 'remove')" class="btn btn-secondary btn-small" style="margin: 5px;">
                        Supprimer le caractère problématique
                    </button>
                    <button onclick="downloadJSONForDebug(${partNum})" class="btn btn-secondary btn-small" style="margin: 5px;">
                        Télécharger pour édition manuelle
                    </button>
                </div>
            `;
        }
        
        function tryComplete(partial) {
            // Compter les ouvertures non fermées
            let braces = 0;
            let brackets = 0;
            let inString = false;
            let escape = false;
            
            for (const char of partial) {
                if (escape) { escape = false; continue; }
                if (char === '\\' && inString) { escape = true; continue; }
                if (char === '"') { inString = !inString; continue; }
                if (inString) continue;
                
                if (char === '{') braces++;
                if (char === '}') braces--;
                if (char === '[') brackets++;
                if (char === ']') brackets--;
            }
            
            // Fermer les chaînes ouvertes
            let completed = partial;
            if (inString) completed += '"';
            
            // Ajouter les fermetures manquantes
            for (let i = 0; i < brackets; i++) completed += ']';
            for (let i = 0; i < braces; i++) completed += '}';
            
            return completed;
        }
        
        function downloadJSONForDebug(partNum) {
            const textarea = document.getElementById(`jsonTextarea${partNum}`);
            let content = mergeFragments(partNum) || textarea.value;
            content = cleanJSON(content);
            
            const blob = new Blob([content], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `debug_part${partNum}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // Réparation avancée itérative
        function advancedRepair(partNum) {
            const textarea = document.getElementById(`jsonTextarea${partNum}`);
            const statusDiv = document.getElementById(`jsonStatus${partNum}`);
            const previewDiv = document.getElementById(`jsonPreview${partNum}`);
            
            let content = mergeFragments(partNum) || textarea.value;
            content = cleanJSON(content);
            
            statusDiv.innerHTML = 'Réparation en cours...';
            statusDiv.style.background = '#fff3cd';
            statusDiv.style.color = '#856404';
            
            // Réparation itérative
            let fixed = content;
            let corrections = [];
            const maxIterations = 30;
            
            for (let i = 0; i < maxIterations; i++) {
                try {
                    JSON.parse(fixed);
                    // Succès!
                    break;
                } catch (e) {
                    const pos = e.pos || 0;
                    const msg = (e.message || '').toLowerCase();
                    
                    if (msg.includes('control character') || msg.includes('unterminated string')) {
                        // Caractère de contrôle dans une chaîne = chaîne coupée par un newline
                        // Trouver si on est dans une chaîne
                        let inString = false;
                        let escape = false;
                        
                        for (let j = 0; j < pos; j++) {
                            if (escape) { escape = false; continue; }
                            if (fixed[j] === '\\') { escape = true; continue; }
                            if (fixed[j] === '"') { inString = !inString; }
                        }
                        
                        if (inString) {
                            // Fermer la chaîne avant le caractère problématique
                            let cutPoint = pos;
                            // Reculer pour trouver un bon point de coupure
                            while (cutPoint > 0 && fixed[cutPoint-1] !== ' ' && fixed[cutPoint-1] !== ':') {
                                cutPoint--;
                                if (pos - cutPoint > 50) { cutPoint = pos; break; }
                            }
                            if (cutPoint < pos - 50) cutPoint = pos;
                            
                            fixed = fixed.substring(0, cutPoint) + '..."' + fixed.substring(pos + 1);
                            corrections.push(`Chaîne fermée à ${cutPoint}`);
                        } else {
                            // Supprimer le caractère problématique
                            fixed = fixed.substring(0, pos) + fixed.substring(pos + 1);
                            corrections.push(`Caractère supprimé à ${pos}`);
                        }
                    } else if (msg.includes('expecting \',\'') || msg.includes('delimiter')) {
                        // Virgule manquante
                        const before = fixed.substring(Math.max(0, pos - 20), pos);
                        const after = fixed.substring(pos, Math.min(fixed.length, pos + 20));
                        
                        if (/"\s*$/.test(before) && /^\s*"/.test(after)) {
                            fixed = fixed.substring(0, pos) + ',' + fixed.substring(pos);
                            corrections.push(`Virgule ajoutée à ${pos}`);
                        } else if (/[a-zA-Z0-9\.]\s*$/.test(before) && /^\s*"/.test(after)) {
                            fixed = fixed.substring(0, pos) + '",' + fixed.substring(pos);
                            corrections.push(`Fermeture + virgule à ${pos}`);
                        } else {
                            fixed = fixed.substring(0, pos) + ',' + fixed.substring(pos);
                            corrections.push(`Virgule ajoutée à ${pos}`);
                        }
                    } else if (msg.includes('unexpected token') || msg.includes('expected')) {
                        // Structure cassée - essayer de diagnostiquer
                        corrections.push(`Erreur non réparée: ${e.message}`);
                        break;
                    } else {
                        corrections.push(`Erreur inconnue: ${e.message}`);
                        break;
                    }
                }
            }
            
            // Tester le résultat
            try {
                const parsed = JSON.parse(fixed);
                
                // Succès!
                textarea.value = fixed;
                fragmentStorage[partNum] = [];
                const fragmentInfo = document.getElementById(`fragmentInfo${partNum}`);
                if (fragmentInfo) fragmentInfo.style.display = 'none';
                
                const chapitres = parsed.structure_hierarchique?.chapitres || [];
                let totalContenus = 0;
                chapitres.forEach(ch => {
                    if (ch.sections) {
                        ch.sections.forEach(s => {
                            if (s.contenus) totalContenus += s.contenus.length;
                        });
                    }
                });
                
                previewDiv.style.display = 'block';
                previewDiv.innerHTML = `
                    <h4 style="color: #28a745;">Réparation Réussie! (${corrections.length} corrections)</h4>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; margin: 15px 0;">
                        <div style="background: #e8f5e9; padding: 10px; border-radius: 8px; text-align: center;">
                            <div style="font-size: 1.5em; font-weight: 700; color: #2e7d32;">${chapitres.length}</div>
                            <div style="font-size: 0.85em;">Chapitres</div>
                        </div>
                        <div style="background: #e3f2fd; padding: 10px; border-radius: 8px; text-align: center;">
                            <div style="font-size: 1.5em; font-weight: 700; color: #1565c0;">${totalContenus}</div>
                            <div style="font-size: 0.85em;">Contenus</div>
                        </div>
                    </div>
                    <details style="margin-top: 10px;">
                        <summary style="cursor: pointer; color: #666;">Voir les corrections effectuées</summary>
                        <ul style="margin: 10px 0 0 20px; font-size: 0.85em; color: #666;">
                            ${corrections.map(c => `<li>${c}</li>`).join('')}
                        </ul>
                    </details>
                    <p style="margin-top: 15px; color: #28a745; font-weight: 600;">
                        Cliquez sur "Valider et Enregistrer" pour confirmer.
                    </p>
                `;
                
                statusDiv.innerHTML = `Réparé avec ${corrections.length} corrections!`;
                statusDiv.style.background = '#d4edda';
                statusDiv.style.color = '#155724';
                
            } catch (e) {
                previewDiv.style.display = 'block';
                previewDiv.innerHTML = `
                    <h4 style="color: #dc3545;">Réparation Incomplète</h4>
                    <p>Après ${corrections.length} corrections, il reste des erreurs :</p>
                    <p style="background: #f8d7da; padding: 10px; border-radius: 8px; font-family: monospace; font-size: 0.85em;">
                        ${e.message}
                    </p>
                    <details style="margin-top: 10px;">
                        <summary style="cursor: pointer;">Corrections effectuées</summary>
                        <ul style="margin: 10px 0 0 20px; font-size: 0.85em;">
                            ${corrections.map(c => `<li>${c}</li>`).join('')}
                        </ul>
                    </details>
                    <p style="margin-top: 15px;">
                        <button onclick="downloadJSONForDebug(${partNum})" class="btn btn-secondary btn-small">
                            Télécharger pour réparation manuelle
                        </button>
                    </p>
                `;
                
                statusDiv.innerHTML = 'Réparation partielle - erreurs restantes';
                statusDiv.style.background = '#fff3cd';
                statusDiv.style.color = '#856404';
                
                // Sauvegarder quand même le résultat partiel
                textarea.value = fixed;
            }
        }

        function validateJSONFromTextarea(partNum) {
            const textarea = document.getElementById(`jsonTextarea${partNum}`);
            const rawText = textarea.value.trim();
            
            if (!rawText) {
                alert('Veuillez coller le JSON de Claude d\'abord.');
                return;
            }

            const cleaned = cleanJSON(rawText);

            try {
                const json = JSON.parse(cleaned);
                processJSON(partNum - 1, json);
            } catch (e) {
                alert('Erreur JSON: ' + e.message + '\n\nUtilisez d\'abord le bouton "Tester le JSON" pour diagnostiquer le problème.');
            }
        }

        function handleJSONUpload(partNum) {
            const fileInput = document.getElementById(`fileInput${partNum}`);
            const file = fileInput.files[0];
            
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const json = JSON.parse(e.target.result);
                    processJSON(partNum - 1, json);
                } catch (err) {
                    alert('Erreur: Le fichier ne contient pas un JSON valide.\n' + err.message);
                }
            };
            reader.readAsText(file);
        }

        function processJSON(slotIndex, json) {
            state.uploadedJSONs[slotIndex] = json;
            
            const partNum = slotIndex + 1;
            
            // Mise à jour visuelle de la carte
            const card = document.getElementById(`partCard${partNum}`);
            card.style.borderColor = '#28a745';
            card.style.borderWidth = '4px';
            card.style.background = 'linear-gradient(135deg, rgba(40, 167, 69, 0.05), rgba(40, 167, 69, 0.1))';
            
            // Afficher le checkmark
            document.getElementById(`partValidated${partNum}`).style.display = 'block';
            
            // Compter les parties validées
            const validatedCount = state.uploadedJSONs.filter(j => j !== null).length;
            const totalParts = state.parts.length;
            
            // Mise à jour du statut
            const statusDiv = document.getElementById(`jsonStatus${partNum}`);
            statusDiv.innerHTML = `<strong>Partie ${partNum}/${totalParts} VALIDÉE !</strong> ${validatedCount < totalParts ? `→ Passez à la partie ${partNum + 1}` : '→ Toutes les parties sont validées !'}`;
            statusDiv.style.color = '#155724';
            statusDiv.style.background = 'linear-gradient(135deg, #d4edda, #c3e6cb)';
            statusDiv.style.fontWeight = '700';
            statusDiv.style.fontSize = '1.1em';
            statusDiv.style.padding = '15px';
            statusDiv.style.border = '2px solid #28a745';
            
            // Masquer la zone de texte et les boutons
            document.getElementById(`jsonTextarea${partNum}`).style.display = 'none';
            document.getElementById(`testBtn${partNum}`).style.display = 'none';
            document.getElementById(`validateBtn${partNum}`).style.display = 'none';
            
            const previewDiv = document.getElementById(`jsonPreview${partNum}`);
            if (previewDiv) {
                previewDiv.style.display = 'none';
            }
            
            // Nettoyer la mémoire de la partie PDF
            cleanupPartMemory(partNum);
            
            // Vérifier si toutes les parties sont validées
            checkAllPartsValidated();
        }

        function checkAllPartsValidated() {
            const allValidated = state.uploadedJSONs.every(json => json !== null);
            
            if (allValidated) {
                document.getElementById('fusionReady').style.display = 'block';
                document.getElementById('fusionBtn').style.display = 'block';
                document.getElementById('fusionBtn').scrollIntoView({ behavior: 'smooth' });
            }
        }

        // FUSION ET GÉNÉRATION FINALE - VERSION OPTION C (reconstruction automatique des index)
        function mergeAndGenerate() {
            const mergedData = {
                date_creation: new Date().toISOString(),
                document_metadata: state.uploadedJSONs[0].document_metadata,
                structure_hierarchique: {
                    chapitres: [],
                    index_concepts: {
                        frameworks_theoriques: [],
                        outils_pratiques: [],
                        exercices_therapeutiques: [],
                        cas_cliniques: []
                    },
                    index_mots_cles: {},
                    index_auteurs_cites: {}
                },
                statistiques: {
                    total_chapitres: 0,
                    total_sections: 0,
                    total_concepts: 0,
                    total_frameworks: 0,
                    total_outils: 0,
                    total_exercices: 0,
                    total_cas_cliniques: 0,
                    total_citations: 0,
                    pages_analysees: state.totalPages
                }
            };

            // Fusion des données et reconstruction des index
            state.uploadedJSONs.forEach((json, index) => {
                if (!json) return;

                // Fusionner les chapitres
                if (json.structure_hierarchique?.chapitres) {
                    mergedData.structure_hierarchique.chapitres.push(...json.structure_hierarchique.chapitres);
                }

                // Fusionner les index existants (si présents - ancien format)
                if (json.structure_hierarchique?.index_concepts) {
                    const idx = json.structure_hierarchique.index_concepts;
                    if (idx.frameworks_theoriques) mergedData.structure_hierarchique.index_concepts.frameworks_theoriques.push(...idx.frameworks_theoriques);
                    if (idx.outils_pratiques) mergedData.structure_hierarchique.index_concepts.outils_pratiques.push(...idx.outils_pratiques);
                    if (idx.exercices_therapeutiques) mergedData.structure_hierarchique.index_concepts.exercices_therapeutiques.push(...idx.exercices_therapeutiques);
                    if (idx.cas_cliniques) mergedData.structure_hierarchique.index_concepts.cas_cliniques.push(...idx.cas_cliniques);
                }

                // Fusionner les index de mots-clés existants
                if (json.structure_hierarchique?.index_mots_cles) {
                    Object.entries(json.structure_hierarchique.index_mots_cles).forEach(([key, values]) => {
                        if (!mergedData.structure_hierarchique.index_mots_cles[key]) {
                            mergedData.structure_hierarchique.index_mots_cles[key] = [];
                        }
                        mergedData.structure_hierarchique.index_mots_cles[key].push(...values);
                    });
                }

                // Fusionner les statistiques
                if (json.statistiques) {
                    Object.keys(mergedData.statistiques).forEach(key => {
                        if (key !== 'pages_analysees' && typeof json.statistiques[key] === 'number') {
                            mergedData.statistiques[key] += json.statistiques[key];
                        }
                    });
                }
            });

            // RECONSTRUCTION AUTOMATIQUE DES INDEX (Option C)
            let totalSections = 0;
            let totalConcepts = 0;
            let totalCitations = 0;
            
            mergedData.structure_hierarchique.chapitres.forEach(chapitre => {
                if (!chapitre.sections) return;
                
                totalSections += chapitre.sections.length;
                
                chapitre.sections.forEach(section => {
                    if (!section.contenus) return;
                    
                    section.contenus.forEach(contenu => {
                        totalConcepts++;
                        const id = contenu.contenu_id || contenu.id;
                        
                        // Reconstruire index_concepts par type
                        const type = contenu.type || '';
                        if (type.includes('framework')) {
                            mergedData.structure_hierarchique.index_concepts.frameworks_theoriques.push(id);
                            mergedData.statistiques.total_frameworks++;
                        } else if (type.includes('outil')) {
                            mergedData.structure_hierarchique.index_concepts.outils_pratiques.push(id);
                            mergedData.statistiques.total_outils++;
                        } else if (type.includes('exercice')) {
                            mergedData.structure_hierarchique.index_concepts.exercices_therapeutiques.push(id);
                            mergedData.statistiques.total_exercices++;
                        } else if (type.includes('cas')) {
                            mergedData.structure_hierarchique.index_concepts.cas_cliniques.push(id);
                            mergedData.statistiques.total_cas_cliniques++;
                        }
                        
                        // Reconstruire index_mots_cles
                        const motsCles = contenu.mots_cles_experts || contenu.mots_cles || [];
                        motsCles.forEach(motCle => {
                            const key = motCle.toLowerCase().replace(/[^a-z0-9_]/g, '_');
                            if (!mergedData.structure_hierarchique.index_mots_cles[key]) {
                                mergedData.structure_hierarchique.index_mots_cles[key] = [];
                            }
                            if (!mergedData.structure_hierarchique.index_mots_cles[key].includes(id)) {
                                mergedData.structure_hierarchique.index_mots_cles[key].push(id);
                            }
                        });
                        
                        // Reconstruire index_auteurs_cites
                        const auteurs = contenu.auteurs_references || contenu.auteurs || [];
                        auteurs.forEach(auteur => {
                            if (!mergedData.structure_hierarchique.index_auteurs_cites[auteur]) {
                                mergedData.structure_hierarchique.index_auteurs_cites[auteur] = [];
                            }
                            if (!mergedData.structure_hierarchique.index_auteurs_cites[auteur].includes(id)) {
                                mergedData.structure_hierarchique.index_auteurs_cites[auteur].push(id);
                            }
                        });
                        
                        // Compter les citations
                        if (contenu.citation || (contenu.citations && contenu.citations.length > 0)) {
                            totalCitations++;
                        }
                    });
                });
            });

            // Mettre à jour les statistiques recalculées
            mergedData.document_metadata.pages_total = state.totalPages;
            mergedData.statistiques.total_chapitres = mergedData.structure_hierarchique.chapitres.length;
            mergedData.statistiques.total_sections = totalSections;
            mergedData.statistiques.total_concepts = totalConcepts;
            mergedData.statistiques.total_citations = totalCitations;

            state.finalData = mergedData;

            // Générer les fichiers finaux
            const readme = generateREADME(mergedData);
            const html = generateHTML(mergedData);
            const md = generateMarkdown(mergedData);

            createFinalDownloads(mergedData, readme, html, md);

            // Nettoyer toute la mémoire PDF
            cleanupAllMemory();

            updateProgressIndicator(3);
            document.getElementById('phase2').classList.add('hidden');
            document.getElementById('phase3').classList.remove('hidden');
            document.getElementById('phase3').scrollIntoView({ behavior: 'smooth' });
        }

        function cleanupAllMemory() {
            // Libérer toutes les URLs de blob
            state.parts.forEach((part, index) => {
                cleanupPartMemory(index + 1);
            });
            
            // Ne pas libérer pdfArrayBuffer car il peut être nécessaire pour le ZIP final
        }

        // GÉNÉRATION DES FICHIERS
        function generateREADME(data) {
            return `# ${data.document_metadata.titre}

## Informations du Document

- **Auteurs** : ${data.document_metadata.auteurs.join(', ')}
- **Année** : ${data.document_metadata.annee_publication || 'N/A'}
- **Domaine** : ${data.document_metadata.domaine_expertise}
- **Approches thérapeutiques** : ${data.document_metadata.approches_therapeutiques.join(', ')}
- **Langue** : ${data.document_metadata.langue}
- **Pages totales** : ${data.document_metadata.pages_total}

## Statistiques d'Extraction

| Métrique | Valeur |
|----------|--------|
| Chapitres | ${data.statistiques.total_chapitres} |
| Sections | ${data.statistiques.total_sections} |
| Concepts | ${data.statistiques.total_concepts} |
| Frameworks | ${data.statistiques.total_frameworks} |
| Outils | ${data.statistiques.total_outils} |
| Exercices | ${data.statistiques.total_exercices} |
| Cas cliniques | ${data.statistiques.total_cas_cliniques} |
| Citations | ${data.statistiques.total_citations} |

## Structure des Fichiers

- \`knowledge_index.json\` - Structure JSON complète navigable
- \`README.md\` - Ce fichier de documentation
- \`index.html\` - Interface web de consultation
- \`knowledge.md\` - Format Markdown structuré
- \`[nom_original].pdf\` - PDF source de référence

## Utilisation

### Pour GPT/Claude Knowledge Base
1. Uploadez \`knowledge_index.json\` dans votre assistant personnalisé
2. Le JSON est optimisé pour la recherche sémantique

### Pour consultation web
1. Ouvrez \`index.html\` dans votre navigateur
2. Navigation interactive avec recherche

---

*Base de connaissances générée par PDF Batch PRO - Édition Claude Ultimate (WebWorkers)*
*Institut du Couple © ${new Date().getFullYear()}*
`;
        }

        function generateHTML(data) {
            return `<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${data.document_metadata.titre} - Base de Connaissances</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --mer: #8FAFB1;
            --vert-sauge: #C8D0C3;
            --beige-sable: #D8CDBB;
            --sable: #E6D7C3;
            --blanc: #FFFFFF;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Montserrat', sans-serif;
            background: var(--blanc);
            padding: 40px 20px;
            color: #333;
            line-height: 1.6;
        }
        .container { max-width: 1200px; margin: 0 auto; }
        h1 {
            color: var(--mer);
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
        }
        .metadata {
            background: var(--sable);
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 30px;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 30px 0;
        }
        .stat-card {
            background: var(--blanc);
            border: 2px solid var(--vert-sauge);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
        }
        .stat-value {
            font-size: 2em;
            font-weight: 700;
            color: var(--mer);
        }
        .stat-label {
            color: #666;
            font-size: 0.9em;
        }
        .chapter {
            background: var(--sable);
            border-left: 5px solid var(--mer);
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 10px 10px 0;
        }
        .chapter-title {
            color: var(--mer);
            font-size: 1.4em;
            font-weight: 700;
            margin-bottom: 10px;
        }
        .footer {
            text-align: center;
            margin-top: 50px;
            padding-top: 30px;
            border-top: 2px solid var(--beige-sable);
            font-size: 0.9em;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>${data.document_metadata.titre}</h1>
        
        <div class="metadata">
            <p><strong>Auteurs :</strong> ${data.document_metadata.auteurs.join(', ')}</p>
            <p><strong>Domaine :</strong> ${data.document_metadata.domaine_expertise}</p>
            <p><strong>Approches :</strong> ${data.document_metadata.approches_therapeutiques.join(', ')}</p>
            <p><strong>Pages :</strong> ${data.document_metadata.pages_total}</p>
        </div>

        <h2 style="color: var(--mer); margin-bottom: 20px;">Statistiques</h2>
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-value">${data.statistiques.total_chapitres || 0}</div>
                <div class="stat-label">Chapitres</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">${data.statistiques.total_concepts || 0}</div>
                <div class="stat-label">Concepts</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">${data.statistiques.total_frameworks || 0}</div>
                <div class="stat-label">Frameworks</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">${data.statistiques.total_outils || 0}</div>
                <div class="stat-label">Outils</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">${data.statistiques.total_exercices || 0}</div>
                <div class="stat-label">Exercices</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">${data.statistiques.total_cas_cliniques || 0}</div>
                <div class="stat-label">Cas Cliniques</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">${data.statistiques.total_citations || 0}</div>
                <div class="stat-label">Citations</div>
            </div>
        </div>

        <h2 style="color: var(--mer); margin: 40px 0 20px;">Structure des Chapitres</h2>
        ${data.structure_hierarchique.chapitres.map((ch, i) => `
            <div class="chapter">
                <div class="chapter-title">${i + 1}. ${ch.titre}</div>
                <p><strong>Pages :</strong> ${ch.pages ? ch.pages.join(', ') : 'N/A'}</p>
                <p><strong>Sections :</strong> ${ch.sections ? ch.sections.length : 0}</p>
                ${ch.resume_chapitre ? `<p style="margin-top: 10px; font-style: italic;">${ch.resume_chapitre}</p>` : ''}
            </div>
        `).join('')}

        <div class="footer">
            <p><strong>Institut du Couple - Base de Connaissances Thérapeutiques</strong></p>
            <p style="margin-top: 10px;">
                Généré par PDF Batch PRO - Option C (Compromis Qualité/Taille)<br>
                Bilan de Compétences du couple© - Marie-Christine Abatte Psychologue
            </p>
            <p style="margin-top: 10px; font-size: 0.85em;">
                Date de création : ${new Date(data.date_creation).toLocaleDateString('fr-FR')}
            </p>
        </div>
    </div>
</body>
</html>`;
        }

        function generateMarkdown(data) {
            let md = `# ${data.document_metadata.titre}\n\n`;
            md += `**Auteurs :** ${data.document_metadata.auteurs.join(', ')}\n`;
            md += `**Approches thérapeutiques :** ${data.document_metadata.approches_therapeutiques.join(', ')}\n`;
            md += `**Domaine :** ${data.document_metadata.domaine_expertise}\n`;
            md += `**Pages :** ${data.document_metadata.pages_total}\n\n`;
            md += `---\n\n`;

            data.structure_hierarchique.chapitres.forEach((ch, i) => {
                md += `## Chapitre ${i + 1} : ${ch.titre}\n\n`;
                
                if (ch.resume_chapitre) {
                    md += `*${ch.resume_chapitre}*\n\n`;
                }
                
                if (ch.sections) {
                    ch.sections.forEach((section, j) => {
                        md += `### ${j + 1}. ${section.titre}\n\n`;
                        
                        if (section.contenus) {
                            section.contenus.forEach(content => {
                                md += `#### ${content.titre}\n\n`;
                                md += `**Type :** ${content.type}\n\n`;
                                
                                // Option C : utiliser description_detaillee OU description_courte OU description
                                const description = content.description_detaillee || content.description_courte || content.description || '';
                                if (description) {
                                    md += `${description}\n\n`;
                                }
                                
                                // Mots-clés : supporter les deux formats
                                const motsCles = content.mots_cles_experts || content.mots_cles || [];
                                if (motsCles.length > 0) {
                                    md += `**Mots-clés :** ${motsCles.join(', ')}\n\n`;
                                }
                                
                                if (content.contexte_therapeutique) {
                                    md += `**Contexte thérapeutique :** ${content.contexte_therapeutique}\n\n`;
                                }
                                
                                // Citation : supporter le nouveau format simplifié
                                if (content.citation && typeof content.citation === 'string') {
                                    md += `**Citation :** ${content.citation}\n\n`;
                                }
                                
                                md += `---\n\n`;
                            });
                        }
                    });
                }
            });

            md += `\n---\n\n`;
            md += `*Base de connaissances générée par PDF Batch PRO - Option C*\n`;
            md += `*Institut du Couple © ${new Date().getFullYear()}*\n`;

            return md;
        }

        function createFinalDownloads(json, readme, html, md) {
            const container = document.getElementById('finalDownloads');
            container.innerHTML = '';
            
            const files = [
                { 
                    name: 'knowledge_index.json', 
                    content: JSON.stringify(json, null, 2), 
                    type: 'application/json', 
                    icon: '📊',
                    desc: 'Structure JSON complète navigable' 
                },
                { 
                    name: 'README.md', 
                    content: readme, 
                    type: 'text/markdown', 
                    icon: '📝',
                    desc: 'Documentation et guide d\'utilisation' 
                },
                { 
                    name: 'index.html', 
                    content: html, 
                    type: 'text/html', 
                    icon: '🌐',
                    desc: 'Interface web de consultation' 
                },
                { 
                    name: 'knowledge.md', 
                    content: md, 
                    type: 'text/markdown', 
                    icon: '📄',
                    desc: 'Format Markdown structuré' 
                },
                { 
                    name: state.pdfFile.name, 
                    content: state.pdfFile, 
                    type: 'application/pdf', 
                    icon: '📕',
                    desc: 'PDF original de référence',
                    isBlob: true
                }
            ];

            files.forEach(file => {
                const blob = file.isBlob ? file.content : new Blob([file.content], { type: file.type });
                const url = URL.createObjectURL(blob);
                
                const item = document.createElement('div');
                item.className = 'download-item';
                item.innerHTML = `
                    <div class="download-icon">${file.icon}</div>
                    <div style="font-weight: 700; font-size: 1.2em; margin: 15px 0;">${file.name}</div>
                    <div style="font-size: 0.9em; color: #666; margin-bottom: 20px;">${file.desc}</div>
                    <a href="${url}" download="${file.name}" class="btn btn-secondary btn-small">Télécharger</a>
                `;
                container.appendChild(item);
            });
        }

        async function downloadAllAsZip() {
            const zip = new JSZip();
            const baseName = state.metadata.titre.substring(0, 50).replace(/[^a-z0-9]/gi, '_');
            
            // Ajouter le JSON
            zip.file('knowledge_index.json', JSON.stringify(state.finalData, null, 2));
            
            // Ajouter le README
            zip.file('README.md', generateREADME(state.finalData));
            
            // Ajouter le HTML
            zip.file('index.html', generateHTML(state.finalData));
            
            // Ajouter le Markdown
            zip.file('knowledge.md', generateMarkdown(state.finalData));
            
            // Ajouter le PDF original
            zip.file(state.pdfFile.name, state.pdfFile);
            
            // Générer le ZIP
            const content = await zip.generateAsync({ type: 'blob' });
            
            // Télécharger
            const url = URL.createObjectURL(content);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${baseName}_base_connaissances.zip`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function updateProgressIndicator(step) {
            for (let i = 1; i <= 3; i++) {
                const indicator = document.getElementById(`stepIndicator${i}`);
                indicator.classList.remove('active', 'completed');
                
                if (i < step) {
                    indicator.classList.add('completed');
                } else if (i === step) {
                    indicator.classList.add('active');
                }
            }
        }

        function reset() {
            // Nettoyer toute la mémoire
            state.parts.forEach((part, index) => {
                if (part.blobUrl) {
                    URL.revokeObjectURL(part.blobUrl);
                }
            });
            
            location.reload();
        }
    </script>
</body>
</html>
