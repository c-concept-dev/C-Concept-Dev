<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OCR Universel V6.0 ULTIMATE - Labo R&D Anthropic + API Multi-LLM</title>
    
    <!-- Police Montserrat -->
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Bibliothèques CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/idb@7/build/umd.js"></script>
    
    <style>
        /* ══════════════════════════════════════════════════════════════ */
        /* CHARTE GRAPHIQUE MARIE-CHRISTINE ABATTE */
        /* ══════════════════════════════════════════════════════════════ */
        
        :root {
            --vert-sauge: #C8D0C3;
            --beige-sable: #D8CDBB;
            --sable: #E6D7C3;
            --mer: #8FAFB1;
            --blanc: #FFFFFF;
            --noir: #000000;
            --gris-texte: #333333;
            --gris-secondaire: #666666;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Montserrat', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, var(--sable) 0%, var(--beige-sable) 100%);
            color: var(--gris-texte);
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: var(--blanc);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.15);
        }
        
        /* ══════════════════════════════════════════════════════════════ */
        /* TYPOGRAPHIE */
        /* ══════════════════════════════════════════════════════════════ */
        
        h1 {
            color: var(--mer);
            font-size: 2.5em;
            font-weight: 700;
            margin-bottom: 10px;
            text-align: center;
        }
        
        h2 {
            color: var(--mer);
            font-size: 2em;
            font-weight: 600;
            margin-top: 40px;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 3px solid var(--vert-sauge);
        }
        
        h3 {
            color: var(--gris-texte);
            font-size: 1.5em;
            font-weight: 600;
            margin-top: 30px;
            margin-bottom: 15px;
        }
        
        h4 {
            color: var(--mer);
            font-size: 1.2em;
            font-weight: 600;
            margin-bottom: 10px;
        }
        
        /* ══════════════════════════════════════════════════════════════ */
        /* HEADER */
        /* ══════════════════════════════════════════════════════════════ */
        
        .header {
            text-align: center;
            padding: 30px;
            background: linear-gradient(135deg, var(--sable) 0%, var(--beige-sable) 100%);
            border-radius: 12px;
            margin-bottom: 40px;
            border-left: 5px solid var(--mer);
        }
        
        .version-badge {
            display: inline-block;
            background: linear-gradient(135deg, var(--mer) 0%, var(--vert-sauge) 100%);
            color: var(--blanc);
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 600;
            margin-top: 10px;
        }
        
        .subtitle {
            font-size: 1.1em;
            color: var(--gris-secondaire);
            margin-top: 10px;
        }
        
        /* ══════════════════════════════════════════════════════════════ */
        /* CARDS & SECTIONS */
        /* ══════════════════════════════════════════════════════════════ */
        
        .section {
            background: var(--blanc);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        
        .card {
            background: linear-gradient(135deg, var(--sable) 0%, var(--beige-sable) 100%);
            padding: 14px;
            border-radius: 8px;
            border-left: 4px solid var(--mer);
            margin-bottom: 15px;
            transition: transform 0.3s;
        }
        
        .card:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(143, 175, 177, 0.3);
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .info-item {
            background: var(--sable);
            padding: 20px;
            border-radius: 10px;
        }
        
        .info-label {
            font-size: 0.85em;
            color: var(--gris-secondaire);
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        .info-value {
            font-size: 1.2em;
            font-weight: 600;
            color: var(--mer);
        }
        
        /* ══════════════════════════════════════════════════════════════ */
        /* UPLOAD ZONE */
        /* ══════════════════════════════════════════════════════════════ */
        
        .drop-zone {
            border: 3px dashed var(--mer);
            border-radius: 12px;
            padding: 60px 30px;
            text-align: center;
            cursor: pointer;
            background: var(--sable);
            transition: all 0.3s;
        }
        
        .drop-zone:hover, .drop-zone.drag-over {
            background: linear-gradient(135deg, var(--mer) 0%, var(--vert-sauge) 100%);
            color: var(--blanc);
            transform: scale(1.02);
        }
        
        .drop-zone input[type="file"] {
            display: none;
        }
        
        .drop-zone-icon {
            font-size: 4em;
            margin-bottom: 20px;
        }
        
        .supported-formats {
            margin-top: 20px;
            padding: 20px;
            background: var(--beige-sable);
            border-radius: 10px;
        }
        
        .format-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        
        .format-badge {
            background: var(--mer);
            color: var(--blanc);
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 0.85em;
            text-align: center;
            font-weight: 500;
        }
        
        /* ══════════════════════════════════════════════════════════════ */
        /* PROGRESS */
        /* ══════════════════════════════════════════════════════════════ */
        
        .progress-container {
            background: var(--sable);
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 25px;
            border-left: 4px solid var(--mer);
            display: none;
        }
        
        .progress-bar-container {
            width: 100%;
            height: 30px;
            background: var(--beige-sable);
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 15px;
        }
        
        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--mer), var(--vert-sauge));
            border-radius: 15px;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--blanc);
            font-weight: 600;
        }
        
        .progress-detail {
            display: flex;
            justify-content: space-between;
            padding: 12px;
            background: var(--blanc);
            border-radius: 8px;
            margin-top: 10px;
        }
        
        /* ══════════════════════════════════════════════════════════════ */
        /* STATUS MESSAGES */
        /* ══════════════════════════════════════════════════════════════ */
        
        .status-message {
            padding: 15px 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: none;
            border-left: 4px solid;
        }
        
        .status-success {
            background: #E8F5E9;
            border-color: #4CAF50;
            color: #2E7D32;
        }
        
        .status-info {
            background: var(--sable);
            border-color: var(--mer);
            color: var(--gris-texte);
        }
        
        .status-warning {
            background: #FFF3E0;
            border-color: #FF9800;
            color: #E65100;
        }
        
        .status-error {
            background: #FFEBEE;
            border-color: #F44336;
            color: #C62828;
        }
        
        /* ══════════════════════════════════════════════════════════════ */
        /* BUTTONS */
        /* ══════════════════════════════════════════════════════════════ */
        
        .btn {
            background: linear-gradient(135deg, var(--mer) 0%, var(--vert-sauge) 100%);
            color: var(--blanc);
            border: none;
            padding: 15px 40px;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(143, 175, 177, 0.3);
            font-family: 'Montserrat', sans-serif;
        }
        
        .btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(143, 175, 177, 0.5);
        }
        
        .btn-secondary {
            background: var(--beige-sable);
            color: var(--gris-texte);
        }
        
        .btn-small {
            padding: 10px 25px;
            font-size: 14px;
        }
        
        .btn-group {
            display: flex;
            gap: 15px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        /* ══════════════════════════════════════════════════════════════ */
        /* TEMPLATES */
        /* ══════════════════════════════════════════════════════════════ */
        
        .templates-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .template-card {
            background: var(--sable);
            padding: 25px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            border-left: 4px solid var(--mer);
        }
        
        .template-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 20px rgba(143, 175, 177, 0.3);
        }
        
        .template-badge {
            display: inline-block;
            background: var(--mer);
            color: var(--blanc);
            padding: 5px 12px;
            border-radius: 12px;
            font-size: 0.8em;
            margin-top: 10px;
            margin-right: 5px;
        }
        
        /* ══════════════════════════════════════════════════════════════ */
        /* CONFIGURATION */
        /* ══════════════════════════════════════════════════════════════ */
        
        .config-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin: 30px 0;
        }
        
        .config-section {
            background: var(--sable);
            padding: 25px;
            border-radius: 12px;
            border-left: 4px solid var(--mer);
        }
        
        .platform-selector {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 20px 0;
        }
        
        .platform-option {
            background: var(--blanc);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid var(--beige-sable);
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        
        .platform-option:hover {
            border-color: var(--mer);
        }
        
        .platform-option.selected {
            background: linear-gradient(135deg, var(--mer) 0%, var(--vert-sauge) 100%);
            color: var(--blanc);
            border-color: var(--mer);
        }
        
        .model-selector {
            display: none;
            margin-top: 15px;
        }
        
        .model-selector select {
            width: 100%;
            padding: 12px;
            border-radius: 8px;
            border: 2px solid var(--beige-sable);
            font-family: 'Montserrat', sans-serif;
            font-size: 15px;
            background: var(--blanc);
        }
        
        .indicator-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 20px;
        }
        
        .indicator {
            text-align: center;
            padding: 15px;
            background: var(--blanc);
            border-radius: 8px;
        }
        
        .indicator-label {
            font-size: 0.85em;
            color: var(--gris-secondaire);
            margin-bottom: 8px;
        }
        
        .indicator-value {
            font-size: 1.1em;
            font-weight: 600;
            color: var(--mer);
        }
        
        /* ══════════════════════════════════════════════════════════════ */
        /* COMPOSITION OVERRIDE */
        /* ══════════════════════════════════════════════════════════════ */
        
        .composition-section {
            background: var(--sable);
            padding: 30px;
            border-radius: 12px;
            border-left: 4px solid var(--mer);
            margin-top: 30px;
            display: none;
        }
        
        .content-checkboxes {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .checkbox-label {
            background: var(--blanc);
            padding: 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .checkbox-label:hover {
            background: var(--beige-sable);
        }
        
        .checkbox-label input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        
        .weights-section {
            margin-top: 25px;
            padding: 25px;
            background: var(--blanc);
            border-radius: 10px;
        }
        
        .slider-item {
            display: grid;
            grid-template-columns: 200px 1fr 80px;
            gap: 15px;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .slider-item input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: var(--beige-sable);
            outline: none;
            -webkit-appearance: none;
        }
        
        .slider-item input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: var(--mer);
            cursor: pointer;
        }
        
        .slider-item input[type="range"]::-moz-range-thumb {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: var(--mer);
            cursor: pointer;
            border: none;
        }
        
        /* ══════════════════════════════════════════════════════════════ */
        /* PARTS CONTAINER */
        /* ══════════════════════════════════════════════════════════════ */
        
        .part-card {
            background: var(--sable);
            padding: 30px;
            border-radius: 12px;
            margin-bottom: 30px;
            border-left: 4px solid var(--mer);
        }
        
        .part-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .part-title {
            font-size: 1.3em;
            font-weight: 600;
            color: var(--mer);
        }
        
        .status-badge {
            padding: 8px 16px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 600;
        }
        
        .status-pending {
            background: var(--beige-sable);
            color: var(--gris-texte);
        }
        
        .status-completed {
            background: #4CAF50;
            color: var(--blanc);
        }
        
        .prompt-output {
            background: var(--blanc);
            padding: 25px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            max-height: 500px;
            overflow-y: auto;
            white-space: pre-wrap;
            margin-bottom: 20px;
        }
        
        textarea {
            width: 100%;
            min-height: 200px;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid var(--beige-sable);
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            resize: vertical;
        }
        
        /* ══════════════════════════════════════════════════════════════ */
        /* STATISTICS */
        /* ══════════════════════════════════════════════════════════════ */
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 25px 0;
        }
        
        .stat-card {
            background: linear-gradient(135deg, var(--mer), var(--vert-sauge));
            color: var(--blanc);
            padding: 25px;
            border-radius: 12px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 2.5em;
            font-weight: 700;
            margin-bottom: 10px;
        }
        
        .stat-label {
            font-size: 0.9em;
            opacity: 0.95;
        }
        
        /* ══════════════════════════════════════════════════════════════ */
        /* FOOTER */
        /* ══════════════════════════════════════════════════════════════ */
        
        .footer {
            text-align: center;
            margin-top: 50px;
            padding-top: 30px;
            border-top: 2px solid var(--beige-sable);
            font-size: 11px;
            color: var(--noir);
        }
        
        /* ══════════════════════════════════════════════════════════════ */
        /* BATCH PROCESSING */
        /* ══════════════════════════════════════════════════════════════ */
        
        .batch-section {
            margin-top: 30px;
        }
        
        .batch-upload {
            background: var(--sable);
            padding: 25px;
            border-radius: 12px;
            border: 2px dashed var(--mer);
            text-align: center;
            margin-bottom: 25px;
        }
        
        .batch-upload input[type="file"] {
            display: none;
        }
        
        .batch-upload-label {
            display: inline-block;
            background: linear-gradient(135deg, var(--mer), var(--vert-sauge));
            color: var(--blanc);
            padding: 15px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.3s;
        }
        
        .batch-upload-label:hover {
            transform: scale(1.05);
        }
        
        .batch-queue {
            margin: 25px 0;
        }
        
        .batch-item {
            background: var(--blanc);
            border: 2px solid var(--beige-sable);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 15px;
            transition: all 0.3s;
        }
        
        .batch-item:hover {
            border-color: var(--mer);
            box-shadow: 0 4px 12px rgba(143, 175, 177, 0.2);
        }
        
        .batch-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .batch-file-name {
            font-weight: 600;
            color: var(--gris-texte);
            font-size: 1.05em;
            flex: 1;
        }
        
        .batch-file-status {
            display: inline-block;
            padding: 6px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 600;
            margin: 0 10px;
        }
        
        .status-queued {
            background: var(--sable);
            color: var(--gris-secondaire);
        }
        
        .status-extracting {
            background: #FFE5B4;
            color: #8B4513;
        }
        
        .status-analyzing {
            background: #B4D7FF;
            color: #003366;
        }
        
        .status-generating {
            background: #D4EDDA;
            color: #155724;
        }
        
        .status-completed {
            background: var(--vert-sauge);
            color: #2C5F2D;
        }
        
        .status-error {
            background: #F8D7DA;
            color: #721C24;
        }
        
        .batch-remove-btn {
            background: transparent;
            border: none;
            color: var(--gris-secondaire);
            font-size: 1.5em;
            cursor: pointer;
            padding: 5px 10px;
            transition: color 0.3s;
        }
        
        .batch-remove-btn:hover {
            color: #DC3545;
        }
        
        .batch-progress-bar {
            width: 100%;
            height: 8px;
            background: var(--sable);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        
        .batch-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--mer), var(--vert-sauge));
            border-radius: 4px;
            transition: width 0.5s ease;
        }
        
        .batch-progress-message {
            font-size: 0.9em;
            color: var(--gris-secondaire);
            font-style: italic;
        }
        
        .batch-error-message {
            background: #F8D7DA;
            color: #721C24;
            padding: 12px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 0.9em;
            border-left: 4px solid #DC3545;
        }
        
        .batch-controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 30px 0;
            flex-wrap: wrap;
        }
        
        .batch-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 25px 0;
        }
        
        .batch-stat {
            background: linear-gradient(135deg, var(--sable), var(--beige-sable));
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            border-left: 4px solid var(--mer);
        }
        
        .batch-stat-value {
            font-size: 2em;
            font-weight: 700;
            color: var(--mer);
            margin-bottom: 5px;
        }
        
        .batch-stat-label {
            font-size: 0.9em;
            color: var(--gris-secondaire);
            font-weight: 500;
        }
        
        .batch-templates {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .batch-template-card {
            background: var(--blanc);
            border: 2px solid var(--beige-sable);
            border-radius: 10px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        
        .batch-template-card:hover {
            border-color: var(--mer);
            transform: translateY(-5px);
            box-shadow: 0 6px 20px rgba(143, 175, 177, 0.3);
        }
        
        .batch-template-card h5 {
            color: var(--mer);
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        
        .batch-template-card p {
            font-size: 0.9em;
            color: var(--gris-secondaire);
            margin-bottom: 10px;
        }
        
        .batch-config-section {
            background: var(--sable);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }

        /* ════════════════════════════════════════════════════════════
           V6.3.0 - SECTION SÉCURITÉ
           ════════════════════════════════════════════════════════════ */
        .security-warning {
            background: linear-gradient(135deg, #fff5e6 0%, #ffe8cc 100%);
            border: 2px solid #ff9800;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            display: none;
        }
        .security-warning.visible {
            display: block;
        }
        .security-warning h4 {
            color: #e65100;
            margin: 0 0 15px 0;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .security-warning-content {
            color: #5d4037;
            line-height: 1.6;
            margin-bottom: 15px;
        }
        .security-warning-content ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        .security-warning-content li {
            margin: 5px 0;
        }
        .security-warning-highlight {
            background: #fff3e0;
            border-left: 3px solid #ff9800;
            padding: 10px;
            margin: 10px 0;
            font-weight: 500;
        }
        .security-warning-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        .security-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
        }
        .security-btn-primary {
            background: var(--vert-sauge);
            color: white;
        }
        .security-btn-primary:hover {
            background: #7fa582;
        }
        .security-btn-secondary {
            background: white;
            color: var(--gris-secondaire);
            border: 1px solid var(--gris-clair);
        }
        .security-btn-secondary:hover {
            background: var(--beige-sable);
        }
        /* ════════════════════════════════════════════════════════════ */
        
        .batch-config-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 15px;
        }
        
        .batch-config-item {
            display: flex;
            flex-direction: column;
        }
        
        .batch-config-item label {
            font-weight: 600;
            color: var(--gris-texte);
            margin-bottom: 8px;
            font-size: 0.95em;
        }
        
        .batch-config-item select,
        .batch-config-item input[type="number"] {
            padding: 10px;
            border: 2px solid var(--beige-sable);
            border-radius: 8px;
            font-family: Montserrat;
            font-size: 0.95em;
        }
        
        .batch-config-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        
        .batch-empty {
            text-align: center;
            padding: 60px 20px;
            color: var(--gris-secondaire);
        }
        
        .batch-empty-icon {
            font-size: 4em;
            margin-bottom: 20px;
            opacity: 0.3;
        }
        
        /* ══════════════════════════════════════════════════════════════ */
        /* EXPORT FORMATS */
        /* ══════════════════════════════════════════════════════════════ */
        
        .export-section {
            margin-top: 30px;
        }
        
        .export-formats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 25px 0;
        }
        
        .export-format-card {
            background: var(--blanc);
            border: 2px solid var(--beige-sable);
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            position: relative;
        }
        
        .export-format-card:hover {
            border-color: var(--mer);
            transform: translateY(-5px);
            box-shadow: 0 6px 20px rgba(143, 175, 177, 0.3);
        }
        
        .export-format-card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none;
        }
        
        /* V6.3.0 - Organisation Exports Basiques/Avancés */
        .export-section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 20px 0 15px 0;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--beige-sable);
        }
        .export-section-title {
            font-size: 1.2em;
            font-weight: 600;
            color: var(--vert-sauge);
        }
        .export-toggle-btn {
            background: var(--beige-sable);
            border: 1px solid var(--gris-clair);
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s ease;
        }
        .export-toggle-btn:hover {
            background: var(--vert-sauge);
            color: white;
        }
        .export-advanced-section {
            display: none;
        }
        .export-advanced-section.visible {
            display: block;
        }
        
        .export-format-icon {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .export-format-name {
            font-weight: 600;
            color: var(--mer);
            margin-bottom: 8px;
            font-size: 1.1em;
        }
        
        .export-format-desc {
            font-size: 0.85em;
            color: var(--gris-secondaire);
            line-height: 1.4;
        }
        
        .export-format-badge {
            display: inline-block;
            background: var(--vert-sauge);
            color: var(--gris-texte);
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.75em;
            font-weight: 600;
            margin-top: 8px;
        }
        
        .export-options {
            background: var(--sable);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }
        
        .export-option-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--beige-sable);
        }
        
        .export-option-row:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        
        .export-option-label {
            font-weight: 500;
            color: var(--gris-texte);
            flex: 1;
        }
        
        .export-option-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .export-option-control input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        
        .export-option-control select {
            padding: 8px 12px;
            border: 2px solid var(--beige-sable);
            border-radius: 8px;
            font-family: Montserrat;
            font-size: 0.9em;
        }
        
        .export-preview {
            background: var(--blanc);
            border: 2px solid var(--beige-sable);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .export-preview-header {
            font-weight: 600;
            color: var(--mer);
            margin-bottom: 15px;
            font-family: Montserrat;
        }
        
        .export-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 25px 0;
            flex-wrap: wrap;
        }
        
        .export-all-btn {
            background: linear-gradient(135deg, var(--mer), var(--vert-sauge));
            color: var(--blanc);
            padding: 15px 40px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 1.1em;
            cursor: pointer;
            transition: transform 0.3s;
        }
        
        .export-all-btn:hover {
            transform: scale(1.05);
        }
        
        .export-all-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* ══════════════════════════════════════════════════════════════ */
        /* RESPONSIVE */
        /* ══════════════════════════════════════════════════════════════ */
        
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 1.8em;
            }
            
            h2 {
                font-size: 1.5em;
            }
            
            .config-grid {
                grid-template-columns: 1fr;
            }
            
            .platform-selector {
                grid-template-columns: 1fr;
            }
            
            .slider-item {
                grid-template-columns: 1fr;
            }
            
            .format-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        /* ══════════════════════════════════════════════════════════════ */
        /* API V6.0 - MODAL & STRATEGIES */
        /* ══════════════════════════════════════════════════════════════ */
        
        #promptModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            z-index: 10000;
            overflow-y: auto;
            padding: 20px;
        }
        
        .modal-content {
            background: white;
            max-width: 1200px;
            margin: 20px auto;
            border-radius: 16px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid var(--vert-sauge);
        }
        
        .modal-close {
            font-size: 32px;
            cursor: pointer;
            color: var(--gris-secondaire);
            transition: color 0.2s;
        }
        
        .modal-close:hover {
            color: var(--mer);
        }
        
        .strategies-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .strategy-card {
            padding: 25px;
            border: 2px solid var(--vert-sauge);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            background: linear-gradient(135deg, var(--blanc) 0%, var(--sable) 100%);
        }
        
        .strategy-card:hover {
            border-color: var(--mer);
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(143, 175, 177, 0.3);
        }
        
        .strategy-card.selected {
            border-color: var(--mer);
            background: linear-gradient(135deg, #E8F5F9 0%, var(--vert-sauge) 100%);
        }
        
        .strategy-card h4 {
            margin-bottom: 10px;
            color: var(--mer);
        }
        
        .strategy-content {
            display: none;
            margin-top: 30px;
            padding: 25px;
            background: #f8f9fa;
            border-radius: 12px;
        }
        
        .strategy-content.active {
            display: block;
        }
        
        /* API Configuration Panel */
        .api-config-panel {
            background: white;
            padding: 25px;
            border-radius: 12px;
            border: 2px solid var(--vert-sauge);
            margin-top: 20px;
        }
        
        .api-mode-switch {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            padding: 15px;
            background: #e8f4f8;
            border-radius: 8px;
        }
        
        .api-mode-switch label {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            padding: 10px 15px;
            border-radius: 6px;
            transition: background 0.2s;
        }
        
        .api-mode-switch label:hover {
            background: rgba(255,255,255,0.7);
        }
        
        .api-mode-switch input[type="radio"]:checked + span {
            font-weight: 600;
            color: var(--mer);
        }
        
        .user-keys-panel {
            background: #fff3cd;
            padding: 20px;
            border-radius: 8px;
            margin-top: 15px;
            border: 2px solid #ffc107;
        }
        
        .key-input-group {
            margin-bottom: 15px;
        }
        
        .key-input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: var(--gris-texte);
        }
        
        .key-input-group input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-family: monospace;
        }
        
        .model-selector {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 15px;
        }
        
        .model-selector select {
            padding: 10px;
            border: 1px solid var(--vert-sauge);
            border-radius: 6px;
            font-family: 'Montserrat', sans-serif;
        }
        
        .api-params {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 15px;
        }
        
        .cost-estimate {
            background: #e8f5e9;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            text-align: center;
        }
        
        .cost-estimate strong {
            color: #2e7d32;
            font-size: 1.2em;
        }
        
        /* API Result Modal */
        #apiResultModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            z-index: 10001;
            overflow-y: auto;
            padding: 20px;
        }
        
        .api-result-content {
            background: white;
            max-width: 1000px;
            margin: 20px auto;
            border-radius: 16px;
            padding: 40px;
        }
        
        .result-metadata {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 25px;
        }
        
        .metadata-item {
            text-align: center;
            padding: 15px;
            background: var(--sable);
            border-radius: 8px;
        }
        
        .metadata-value {
            font-size: 1.5em;
            font-weight: 700;
            color: var(--mer);
        }
        
        .metadata-label {
            font-size: 0.9em;
            color: var(--gris-secondaire);
            margin-top: 5px;
        }
        
        .json-display {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            max-height: 500px;
            overflow-y: auto;
        }
        
        .result-actions {
            display: flex;
            gap: 15px;
            margin-top: 25px;
        }
        
        /* Progress Bar */
        .api-progress {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            display: none;
        }
        
        /* ══════════════════════════════════════════════════════════════ */
        /* 3 MODES INTERFACE */
        /* ══════════════════════════════════════════════════════════════ */
        
        .mode-section {
            margin-bottom: 20px;
            border: 2px solid transparent;
            border-radius: 12px;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        .mode-section.active {
            border-color: var(--mer);
            box-shadow: 0 4px 12px rgba(143, 175, 177, 0.2);
        }
        
        .mode-header {
            background: linear-gradient(135deg, var(--vert-sauge), var(--beige-sable));
            padding: 20px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
        }
        
        .mode-header:hover {
            background: linear-gradient(135deg, var(--mer), var(--vert-sauge));
        }
        
        .mode-section.active .mode-header {
            background: linear-gradient(135deg, var(--mer), var(--vert-sauge));
        }
        
        .mode-header h3 {
            margin: 0;
            color: var(--gris-texte);
            font-size: 1.3em;
        }
        
        .mode-badge {
            background: white;
            color: var(--mer);
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: 600;
        }
        
        .mode-badge-premium {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: white;
        }
        
        .mode-badge-free {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
        }
        
        .mode-content {
            padding: 25px;
            background: white;
        }
        
        .mode-actions {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .mode-actions .btn {
            flex: 1;
            min-width: 200px;
        }
        
        .api-config-box {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-top: 15px;
        }
        
        .key-input-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .key-input-row:last-child {
            grid-template-columns: auto 1fr auto;
        }
        
        .api-params-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 15px;
        }
        
        .cost-display {
            background: #e8f5e9;
            padding: 12px;
            border-radius: 6px;
            margin-top: 15px;
            text-align: center;
            font-size: 1.1em;
        }
        
        .worker-info {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
        }
        
        .worker-toggle {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.4s;
            border-radius: 34px;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: 0.4s;
            border-radius: 50%;
        }
        
        input:checked + .toggle-slider {
            background-color: var(--mer);
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }
        
        #workerStatus {
            font-weight: 600;
            color: var(--gris-texte);
        }
        }
        
        .api-progress.active {
            display: block;
        }
        
        .progress-bar {
            width: 100%;
            height: 30px;
            background: #e9ecef;
            border-radius: 15px;
            overflow: hidden;
            margin-top: 10px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--mer), var(--vert-sauge));
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
        }
        
        /* ══════════════════════════════════════════════════════════════ */
        /* MODE SELECTION CARDS */
        /* ══════════════════════════════════════════════════════════════ */
        
        .mode-selection-section {
            background: linear-gradient(135deg, rgba(143, 175, 177, 0.1), rgba(208, 194, 173, 0.1));
            padding: 30px;
            border-radius: 16px;
            margin-bottom: 30px;
        }
        
        .mode-cards-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
        }
        
        .mode-card {
            background: white;
            border: 3px solid var(--beige-sable);
            border-radius: 16px;
            padding: 0;
            cursor: pointer;
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        .mode-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
        }
        
        .mode-card-active {
            border-color: var(--mer);
            box-shadow: 0 6px 16px rgba(143, 175, 177, 0.3);
        }
        
        .mode-card-active .mode-card-header {
            background: linear-gradient(135deg, var(--mer), var(--vert-sauge));
        }
        
        .mode-card-header {
            background: linear-gradient(135deg, var(--vert-sauge), var(--beige-sable));
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .mode-card-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }
        
        .mode-card-header h3 {
            margin: 10px 0;
            color: var(--noir-principal);
            font-size: 18px;
        }
        
        .mode-card-active .mode-card-header h3 {
            color: white;
        }
        
        .mode-card-badge {
            display: inline-block;
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 700;
            margin-top: 8px;
        }
        
        .mode-badge-default {
            background: white;
            color: var(--mer);
        }
        
        .mode-badge-premium {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: white;
        }
        
        .mode-badge-free {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
        }
        
        .mode-card-content {
            padding: 20px;
        }
        
        .mode-card-content p {
            color: var(--noir-principal);
            margin-bottom: 15px;
        }
        
        .mode-card-content ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .mode-card-content ul li {
            padding: 8px 0;
            color: var(--gris-secondaire);
            font-size: 14px;
        }
        
        .mode-card-config {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 2px solid var(--beige-sable);
        }
        
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.4s;
            border-radius: 34px;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: 0.4s;
            border-radius: 50%;
        }
        
        .toggle-switch input:checked + .toggle-slider {
            background-color: var(--mer);
        }
        
        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }
        
        /* ══════════════════════════════════════════════════════════════ */
        /* PROVIDER ACCORDION SYSTEM */
        /* ══════════════════════════════════════════════════════════════ */
        
        .provider-accordion {
            background: white;
            border: 2px solid var(--beige-sable);
            border-radius: 8px;
            margin-bottom: 12px;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .provider-accordion:hover {
            box-shadow: 0 3px 10px rgba(0,0,0,0.08);
        }
        
        .provider-accordion.active {
            border-color: var(--mer);
            box-shadow: 0 4px 12px rgba(143, 175, 177, 0.25);
        }
        
        .accordion-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 18px;
            cursor: pointer;
            transition: background 0.2s ease;
        }
        
        .accordion-header:hover {
            background: linear-gradient(135deg, rgba(143, 175, 177, 0.05), rgba(208, 194, 173, 0.05));
        }
        
        .accordion-icon {
            font-size: 1.2em;
            transition: transform 0.3s ease;
            color: var(--gris-secondaire);
        }
        
        .provider-accordion.active .accordion-icon {
            transform: rotate(90deg);
            color: var(--mer);
        }
        
        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .provider-accordion.active .accordion-content {
            max-height: 600px;
        }
        
        /* COST ESTIMATOR */
        .cost-estimator {
            background: #F5F5F5;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }
        
        .cost-item {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            font-size: 0.9em;
        }
        
        .cost-total {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-top: 2px solid var(--beige-sable);
            margin-top: 10px;
        }
        
        /* ══════════════════════════════════════════════════════════════ */
        /* TABS MODERNES POUR LES MODES */
        /* ══════════════════════════════════════════════════════════════ */
        
        /* ══════════════════════════════════════════════════════════════ */
        /* MODE RADIOS - MINIMALISTE */
        /* ══════════════════════════════════════════════════════════════ */
        
        .mode-radios {
            display: flex;
            gap: 12px;
            margin: 15px 0 20px 0;
            justify-content: center;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }
        
        .mode-radio {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 10px 20px;
            border: 1px solid #C8D0C3;  /* CHARTE: vert pâle */
            border-radius: 6px;
            transition: all 0.2s ease;
            background: white;
            flex: 1;  /* Largeur égale */
            justify-content: center;
            min-width: 0;
        }
        
        .mode-radio:hover {
            border-color: #8FAFB1;  /* CHARTE: bleu-vert */
            background: #E6D7C3;  /* CHARTE: beige clair */
        }
        
        .mode-radio input[type="radio"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: #8FAFB1;  /* CHARTE: couleur du radio */
        }
        
        .mode-radio input[type="radio"]:checked + span {
            font-weight: 600;
            color: #8FAFB1;  /* CHARTE */
        }
        
        .mode-radio span {
            font-size: 0.85em;
            color: #333;
            white-space: nowrap;
        }
        
        /* PANELS MINIMALISTES */
        .mode-panels {
            margin-top: 15px;
            max-width: 600px;  /* ✨ LARGEUR RÉDUITE */
            margin-left: auto;
            margin-right: auto;
        }
        
        .mode-panel {
            display: none;
        }
        
        .mode-panel.active {
            display: block;
        }
        
        /* PROVIDER MINI ACCORDIONS */
        .provider-mini {
            background: white;
            border: 1px solid #C8D0C3;  /* CHARTE: vert pâle */
            border-radius: 6px;
            margin-bottom: 8px;
            transition: all 0.2s ease;
            position: relative;  /* Pour la croix */
        }
        
        .provider-mini:hover {
            border-color: #8FAFB1;  /* CHARTE: bleu-vert */
            box-shadow: 0 2px 6px rgba(143, 175, 177, 0.2);  /* CHARTE: shadow avec primaire */
        }
        
        .provider-mini-header {
            padding: 10px 12px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9em;
            user-select: none;
        }
        
        .provider-mini-header:hover {
            background: #E6D7C3;  /* CHARTE: beige clair */
        }
        
        /* CROIX DE FERMETURE */
        .mini-close {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #E6D7C3;  /* CHARTE */
            color: #8FAFB1;  /* CHARTE */
            border: 1px solid #C8D0C3;  /* CHARTE */
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 0.8em;
            font-weight: 600;
            z-index: 10;
            transition: all 0.2s ease;
        }
        
        .mini-close:hover {
            background: #8FAFB1;  /* CHARTE */
            color: white;
            transform: rotate(90deg);
        }
        
        .provider-mini.active .mini-close {
            display: flex;
        }
        
        .mini-arrow {
            font-size: 0.8em;
            color: #999;
            transition: transform 0.2s ease;
        }
        
        .provider-mini.active .mini-arrow {
            transform: rotate(90deg);
            color: #8FAFB1;  /* CHARTE */
        }
        
        .provider-mini-body {
            display: none;
            padding: 0 12px 12px 12px;
            border-top: 1px solid #E6D7C3;  /* CHARTE: beige clair */
            animation: slideDown 0.2s ease;
        }
        
        .provider-mini.active .provider-mini-body {
            display: block;
        }
        
        @keyframes slideDown {
            from { opacity: 0; max-height: 0; }
            to { opacity: 1; max-height: 200px; }
        }
        
        /* CONFIRMATION SAUVEGARDE */
        .save-confirmed {
            background: #8FAFB1 !important;  /* CHARTE: vert-bleu */
            color: white !important;
            pointer-events: none;
        }
        
        .save-confirmed::after {
            content: " ✓";
            margin-left: 5px;
        }

        
        /* SMOOTH SCROLL GLOBAL */
        html {
            scroll-behavior: smooth;
        }
        
        /* ══════════════════════════════════════════════════════════════ */
        /* API QUICK ACTIONS */
        /* ══════════════════════════════════════════════════════════════ */
        
        .api-quick-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .api-quick-card {
            background: white;
            border: 2px solid var(--beige-sable);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .api-quick-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.15);
            border-color: var(--mer);
        }
        
        .api-quick-icon {
            font-size: 3em;
            margin-bottom: 10px;
        }
        
        .api-quick-card h4 {
            margin: 10px 0 5px 0;
            color: var(--noir-principal);
        }
        
        .api-quick-card p {
            font-size: 0.9em;
            color: var(--gris-secondaire);
            margin-bottom: 15px;
        }
        
        .api-quick-badge {
            display: inline-block;
            padding: 8px 16px;
            background: var(--mer);
            color: white;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.9em;
        }
        
        /* ══════════════════════════════════════════════════════════════ */
        /* TABS MODERNES */
        /* ══════════════════════════════════════════════════════════════ */
        
        .mode-tabs-container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            overflow: hidden;
            margin-bottom: 30px;
        }
        
        .mode-tabs-header {
            display: flex;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-bottom: 2px solid var(--beige-sable);
        }
        
        .mode-tab {
            flex: 1;
            padding: 18px 20px;
            text-align: center;
            cursor: pointer;
            border: none;
            background: transparent;
            transition: all 0.3s ease;
            position: relative;
            font-weight: 500;
            color: var(--gris-secondaire);
            border-right: 1px solid rgba(0,0,0,0.05);
        }
        
        .mode-tab:last-child {
            border-right: none;
        }
        
        .mode-tab:hover:not(.mode-tab-active) {
            background: rgba(255,255,255,0.5);
            color: var(--noir-principal);
        }
        
        .mode-tab-active {
            background: white;
            color: var(--mer);
            font-weight: 700;
        }
        
        .mode-tab-active::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--mer), var(--violet-profond));
        }
        
        .mode-tab-icon {
            font-size: 1.5em;
            display: block;
            margin-bottom: 5px;
        }
        
        .mode-tab-badge {
            display: inline-block;
            margin-left: 8px;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.7em;
            font-weight: 600;
        }
        
        .mode-tab-badge-default {
            background: #E3F2FD;
            color: #1976D2;
        }
        
        .mode-tab-badge-premium {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: white;
        }
        
        .mode-tab-badge-free {
            background: #E8F5E9;
            color: #4CAF50;
        }
        
        .mode-tabs-content {
            padding: 25px;
            min-height: 300px;
            max-height: 700px;
            overflow-y: auto;
            scroll-behavior: smooth;
        }
        
        .mode-tab-panel {
            display: none;
            animation: fadeIn 0.4s ease;
        }
        
        .mode-tab-panel-active {
            display: block;
        }
        
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* ══════════════════════════════════════════════════════════════ */
        /* SMOOTH SCROLL GLOBAL */
        /* ══════════════════════════════════════════════════════════════ */
        
        html {
            scroll-behavior: smooth;
        }
        
        .scroll-highlight {
            animation: highlightPulse 2s ease;
        }
        
        @keyframes highlightPulse {
            0%, 100% {
                box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            }
            50% {
                box-shadow: 0 0 20px rgba(82, 143, 173, 0.6),
                            0 0 40px rgba(82, 143, 173, 0.3);
            }
        }
        
        /* ══════════════════════════════════════════════════════════════ */
        /* TABS MODERNES */
        /* ══════════════════════════════════════════════════════════════ */
        
        .mode-tabs-header {
            display: flex;
            gap: 0;
            border-bottom: 3px solid var(--beige-sable);
            margin-bottom: 30px;
            background: linear-gradient(180deg, #ffffff, #f8f9fa);
            border-radius: 12px 12px 0 0;
            overflow: hidden;
        }
        
        .mode-tab {
            flex: 1;
            padding: 20px 15px;
            background: transparent;
            border: none;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            font-size: 14px;
            font-weight: 500;
            color: #666;
        }
        
        .mode-tab::after {
            content: '';
            position: absolute;
            bottom: -3px;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--violet-profond);
            transform: scaleX(0);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .mode-tab:hover {
            background: rgba(139, 92, 246, 0.05);
            color: var(--noir-principal);
        }
        
        .mode-tab-active {
            color: var(--violet-profond);
            font-weight: 600;
            background: rgba(139, 92, 246, 0.08);
        }
        
        .mode-tab-active::after {
            transform: scaleX(1);
        }
        
        .mode-tab-icon {
            font-size: 24px;
            display: block;
        }
        
        .mode-tab > div {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 4px;
            line-height: 1.2;
        }
        
        .mode-tab-badge {
            font-size: 10px;
            font-weight: 600;
            padding: 3px 8px;
            border-radius: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .mode-tab-badge-default {
            background: linear-gradient(135deg, #E3F2FD, #BBDEFB);
            color: #1976D2;
        }
        
        .mode-tab-badge-premium {
            background: linear-gradient(135deg, #F3E5F5, #E1BEE7);
            color: #7B1FA2;
        }
        
        .mode-tab-badge-free {
            background: linear-gradient(135deg, #E8F5E9, #C8E6C9);
            color: #388E3C;
        }
        
        .mode-tabs-content {
            position: relative;
            min-height: 300px;
        }
        
        .mode-tab-panel {
            display: none;
            animation: fadeIn 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .mode-tab-panel-active {
            display: block;
        }
        
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Highlight temporaire après scroll */
        @keyframes highlightPulse {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(139, 92, 246, 0);
            }
            50% {
                box-shadow: 0 0 0 8px rgba(139, 92, 246, 0.2);
            }
        }
        
        .highlight-element {
            animation: highlightPulse 1.5s ease-out;
            border: 2px solid var(--violet-profond) !important;
        }
        
        /* ══════════════════════════════════════════════════════════════ */
        /* MAX-HEIGHT + SCROLL INTERNE */
        /* ══════════════════════════════════════════════════════════════ */
        
        .provider-grid {
            max-height: 400px;
            overflow-y: auto;
            padding-right: 10px;
        }
        
        .provider-grid::-webkit-scrollbar {
            width: 8px;
        }
        
        .provider-grid::-webkit-scrollbar-track {
            background: var(--beige-sable);
            border-radius: 4px;
        }
        
        .provider-grid::-webkit-scrollbar-thumb {
            background: var(--mer);
            border-radius: 4px;
        }
        
        .provider-grid::-webkit-scrollbar-thumb:hover {
            background: var(--violet-profond);
        }
        
        #batchList {
            max-height: 500px;
            overflow-y: auto;
        }
        
        #batchList::-webkit-scrollbar {
            width: 8px;
        }
        
        #batchList::-webkit-scrollbar-track {
            background: var(--beige-sable);
            border-radius: 4px;
        }
        
        #batchList::-webkit-scrollbar-thumb {
            background: var(--mer);
            border-radius: 4px;
        }
        
        /* Sections avec beaucoup de contenu */
        .mode-card-config,
        .provider-config,
        .api-quick-section {
            max-height: 600px;
            overflow-y: auto;
            padding-right: 10px;
        }
        
        .mode-card-config::-webkit-scrollbar,
        .provider-config::-webkit-scrollbar,
        .api-quick-section::-webkit-scrollbar {
            width: 8px;
        }
        
        .mode-card-config::-webkit-scrollbar-track,
        .provider-config::-webkit-scrollbar-track,
        .api-quick-section::-webkit-scrollbar-track {
            background: var(--beige-sable);
            border-radius: 4px;
        }
        
        .mode-card-config::-webkit-scrollbar-thumb,
        .provider-config::-webkit-scrollbar-thumb,
        .api-quick-section::-webkit-scrollbar-thumb {
            background: var(--mer);
            border-radius: 4px;
        }
        
        .mode-card-config::-webkit-scrollbar-thumb:hover,
        .provider-config::-webkit-scrollbar-thumb:hover,
        .api-quick-section::-webkit-scrollbar-thumb:hover {
            background: var(--violet-profond);
        }
        
        /* Smooth scroll pour toute la page */
        html {
            scroll-behavior: smooth;
        }
        
        /* ══════════════════════════════════════════════════════════════ */
        /* RESPONSIVE */
        /* ══════════════════════════════════════════════════════════════ */
        
        @media (max-width: 768px) {
            .mode-cards-grid {
                grid-template-columns: 1fr;
            }
            
            .strategies-grid {
                grid-template-columns: 1fr;
            }
            
            .model-selector {
                grid-template-columns: 1fr;
            }
            
            .api-params {
                grid-template-columns: 1fr;
            }
            
            .result-metadata {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        /* ══════════════════════════════════════════════════════════════ */
        /* ANIMATIONS SMOOTH & TRANSITIONS OPTIMISÉES */
        /* ══════════════════════════════════════════════════════════════ */
        
        /* Animation pour éléments qui apparaissent/disparaissent */
        #providerConfig,
        #apiQuickActions,
        #workerActivePanel {
            animation: slideDown 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-8px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Smooth scroll highlight subtil */
        .scroll-highlight {
            animation: pulseHighlight 1.2s ease;
        }
        
        @keyframes pulseHighlight {
            0%, 100% {
                box-shadow: inherit;
            }
            50% {
                box-shadow: 0 0 0 6px rgba(143, 175, 177, 0.25);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- ══════════════════════════════════════════════════════════════ -->
        <!-- HEADER -->
        <!-- ══════════════════════════════════════════════════════════════ -->
        <div class="header">
            <h1>OCR Universel V6.0 ULTIMATE</h1>
            <span class="version-badge">Labo R&D Anthropic + API Multi-LLM</span>
            <p class="subtitle">
                21 formats supportés • OCR parallèle intelligent • Détection multi-dimensionnelle • API Multi-LLM • Production Ready
            </p>
        </div>

        <!-- ══════════════════════════════════════════════════════════════ -->
        <!-- MODE DE TRAITEMENT -->
        <!-- ══════════════════════════════════════════════════════════════ -->
        <div class="section mode-selection-section" id="modeSelectionSection">
            <h2 style="font-size:1.4em;margin-bottom:15px;color:#8FAFB1;">Mode</h2>
            
            <!-- RADIO BUTTONS MINIMALISTES -->
            <div class="mode-radios">
                <label class="mode-radio">
                    <input type="radio" name="mode" value="manual" checked onchange="switchMode('manual')">
                    <span>Manuel</span>
                </label>
                <label class="mode-radio" onclick="handleModeToggle(event, 'user-keys')">
                    <input type="radio" name="mode" value="user-keys" onchange="switchMode('user-keys')">
                    <span>API Multi-LLM</span>
                </label>
                <label class="mode-radio">
                    <input type="radio" name="mode" value="worker" onchange="switchMode('worker')">
                    <span>API Worker</span>
                </label>
            </div>
            
            <!-- PANELS MINIMALISTES -->
            <div class="mode-panels">
                <!-- PANEL MANUEL -->
                <div class="mode-panel active" id="panelManual" data-mode="manual">
                    <p style="margin:10px 0;color:#666;font-size:0.9em;text-align:center;">
                        Uploadez un PDF → Prompt généré automatiquement
                    </p>
                </div>
                
                <!-- PANEL API -->
                <div class="mode-panel" id="panelUserKeys" data-mode="user-keys">
                    
                    <!-- DEEPSEEK -->
                    <div class="provider-mini" data-provider="deepseek">
                        <button class="mini-close" onclick="event.stopPropagation(); closeMini('deepseek')" title="Fermer">×</button>
                        <div class="provider-mini-header" onclick="toggleMini('deepseek')">
                            <span><b>DeepSeek</b> <small style="color:#8FAFB1;">$0.27/M</small></span>
                            <span class="mini-arrow">▶</span>
                        </div>
                        <div class="provider-mini-body" id="mini-deepseek">
                            <select id="model-deepseek" onchange="updateMiniCost('deepseek')" style="width:48%;padding:8px;font-size:0.85em;border:1px solid #C8D0C3;border-radius:4px;">
                                <option value="deepseek-chat">V3</option>
                                <option value="deepseek-reasoner">R1</option>
                            </select>
                            <input type="password" id="key-deepseek" placeholder="sk-..." style="width:48%;padding:8px;font-size:0.85em;border:1px solid #C8D0C3;border-radius:4px;">
                            <button class="save-btn" id="save-deepseek" onclick="saveMiniKey('deepseek')" style="width:100%;padding:8px;margin-top:8px;background:#8FAFB1;color:white;border:none;border-radius:4px;cursor:pointer;font-size:0.85em;font-weight:600;">
                                Sauvegarder
                            </button>
                            <div style="margin-top:8px;font-size:0.75em;color:#666;">
                                <span>Coût estimé: <b id="cost-deepseek" style="color:#8FAFB1;">$0.0179</b></span>
                            </div>
                        </div>
                    </div>

                    <!-- GROQ -->
                    <div class="provider-mini" data-provider="groq">
                        <button class="mini-close" onclick="event.stopPropagation(); closeMini('groq')" title="Fermer">×</button>
                        <div class="provider-mini-header" onclick="toggleMini('groq')">
                            <span><b>Groq</b> <small style="color:#8FAFB1;">GRATUIT</small></span>
                            <span class="mini-arrow">▶</span>
                        </div>
                        <div class="provider-mini-body" id="mini-groq">
                            <select id="model-groq" onchange="updateMiniCost('groq')" style="width:48%;padding:8px;font-size:0.85em;border:1px solid #C8D0C3;border-radius:4px;">
                                <option value="llama-3.3-70b-versatile">Llama 3.3 70B</option>
                                <option value="llama-3.1-70b-versatile">Llama 3.1 70B</option>
                                <option value="mixtral-8x7b-32768">Mixtral 8x7B</option>
                            </select>
                            <input type="password" id="key-groq" placeholder="gsk_..." style="width:48%;padding:8px;font-size:0.85em;border:1px solid #C8D0C3;border-radius:4px;">
                            <button class="save-btn" id="save-groq" onclick="saveMiniKey('groq')" style="width:100%;padding:8px;margin-top:8px;background:#8FAFB1;color:white;border:none;border-radius:4px;cursor:pointer;font-size:0.85em;font-weight:600;">
                                Sauvegarder
                            </button>
                            <div style="margin-top:8px;font-size:0.75em;color:#8FAFB1;font-weight:600;">
                                <span>Gratuit (pas de coût)</span>
                            </div>
                        </div>
                    </div>

                    <!-- ANTHROPIC -->
                    <div class="provider-mini" data-provider="anthropic">
                        <button class="mini-close" onclick="event.stopPropagation(); closeMini('anthropic')" title="Fermer">×</button>
                        <div class="provider-mini-header" onclick="toggleMini('anthropic')">
                            <span><b>Anthropic</b> <small style="color:#8FAFB1;">$3.00/M</small></span>
                            <span class="mini-arrow">▶</span>
                        </div>
                        <div class="provider-mini-body" id="mini-anthropic">
                            <select id="model-anthropic" onchange="updateMiniCost('anthropic')" style="width:48%;padding:8px;font-size:0.85em;border:1px solid #C8D0C3;border-radius:4px;">
                                <option value="claude-sonnet-4-20250514">Sonnet 4</option>
                                <option value="claude-opus-4-20250514">Opus 4</option>
                                <option value="claude-haiku-4.5-20250514">Haiku 4.5</option>
                            </select>
                            <input type="password" id="key-anthropic" placeholder="sk-ant-..." style="width:48%;padding:8px;font-size:0.85em;border:1px solid #C8D0C3;border-radius:4px;">
                            <button class="save-btn" id="save-anthropic" onclick="saveMiniKey('anthropic')" style="width:100%;padding:8px;margin-top:8px;background:#8FAFB1;color:white;border:none;border-radius:4px;cursor:pointer;font-size:0.85em;font-weight:600;">
                                Sauvegarder
                            </button>
                            <div style="margin-top:8px;font-size:0.75em;color:#666;">
                                <span>Coût estimé: <b id="cost-anthropic" style="color:#8FAFB1;">$0.2100</b></span>
                            </div>
                        </div>
                    </div>

                    <!-- OPENAI -->
                    <div class="provider-mini" data-provider="openai">
                        <button class="mini-close" onclick="event.stopPropagation(); closeMini('openai')" title="Fermer">×</button>
                        <div class="provider-mini-header" onclick="toggleMini('openai')">
                            <span><b>OpenAI</b> <small style="color:#8FAFB1;">$2.50/M</small></span>
                            <span class="mini-arrow">▶</span>
                        </div>
                        <div class="provider-mini-body" id="mini-openai">
                            <select id="model-openai" onchange="updateMiniCost('openai')" style="width:48%;padding:8px;font-size:0.85em;border:1px solid #C8D0C3;border-radius:4px;">
                                <option value="gpt-4o">GPT-4o</option>
                                <option value="gpt-4o-mini">GPT-4o Mini</option>
                                <option value="o1">o1</option>
                            </select>
                            <input type="password" id="key-openai" placeholder="sk-..." style="width:48%;padding:8px;font-size:0.85em;border:1px solid #C8D0C3;border-radius:4px;">
                            <button class="save-btn" id="save-openai" onclick="saveMiniKey('openai')" style="width:100%;padding:8px;margin-top:8px;background:#8FAFB1;color:white;border:none;border-radius:4px;cursor:pointer;font-size:0.85em;font-weight:600;">
                                Sauvegarder
                            </button>
                            <div style="margin-top:8px;font-size:0.75em;color:#666;">
                                <span>Coût estimé: <b id="cost-openai" style="color:#8FAFB1;">$0.1650</b></span>
                            </div>
                        </div>
                    </div>

                    <!-- GOOGLE -->
                    <div class="provider-mini" data-provider="google">
                        <button class="mini-close" onclick="event.stopPropagation(); closeMini('google')" title="Fermer">×</button>
                        <div class="provider-mini-header" onclick="toggleMini('google')">
                            <span><b>Google</b> <small style="color:#8FAFB1;">$0.50/M</small></span>
                            <span class="mini-arrow">▶</span>
                        </div>
                        <div class="provider-mini-body" id="mini-google">
                            <select id="model-google" onchange="updateMiniCost('google')" style="width:48%;padding:8px;font-size:0.85em;border:1px solid #C8D0C3;border-radius:4px;">
                                <option value="gemini-2.0-flash-exp">Gemini 2.0 Flash</option>
                                <option value="gemini-1.5-pro">Gemini 1.5 Pro</option>
                            </select>
                            <input type="password" id="key-google" placeholder="AIza..." style="width:48%;padding:8px;font-size:0.85em;border:1px solid #C8D0C3;border-radius:4px;">
                            <button class="save-btn" id="save-google" onclick="saveMiniKey('google')" style="width:100%;padding:8px;margin-top:8px;background:#8FAFB1;color:white;border:none;border-radius:4px;cursor:pointer;font-size:0.85em;font-weight:600;">
                                Sauvegarder
                            </button>
                            <div style="margin-top:8px;font-size:0.75em;color:#666;">
                                <span>Coût estimé: <b id="cost-google" style="color:#8FAFB1;">$0.0425</b></span>
                            </div>
                        </div>
                    </div>

                    <!-- QUICK ACTIONS -->
                    <div id="apiQuickActions" style="display:none;margin-top:15px;">
                        <div style="padding:12px;background:#E6D7C3;border-left:4px solid #8FAFB1;border-radius:6px;text-align:center;margin-bottom:12px;">
                            <h4 style="margin:0 0 5px 0;font-size:0.9em;color:#333;font-weight:600;">Actions rapides</h4>
                            <p style="margin:0;font-size:0.75em;color:#666;">Glissez-déposez ou cliquez pour sélectionner</p>
                        </div>
                        
                        <!-- ZONE DRAG & DROP -->
                        <div id="quickDropZone" 
                             ondrop="handleQuickDrop(event)" 
                             ondragover="handleQuickDragOver(event)" 
                             ondragleave="handleQuickDragLeave(event)"
                             style="border:2px dashed #C8D0C3;border-radius:8px;padding:30px;text-align:center;background:white;margin-bottom:12px;transition:all 0.2s ease;cursor:pointer;">
                            <div style="color:#8FAFB1;font-size:2em;margin-bottom:8px;">📄</div>
                            <div style="color:#333;font-weight:600;margin-bottom:5px;font-size:0.9em;">Glissez un document ici</div>
                            <div id="quickFileInfo" style="color:#666;font-size:0.75em;">ou cliquez pour parcourir</div>
                            <input type="file" id="quickFileInput" accept=".pdf,.docx,.doc,.xlsx,.xls,.pptx,.ppt,.epub,.html,.htm,.md,.markdown,.txt,.png,.jpg,.jpeg,.gif,.webp,.tiff,.tif,.svg,.rtf,.odt,.ods,.odp,.csv,.tsv,.json,.xml,.yaml,.yml,.mobi,.azw,.azw3,.cbz,.cbr,.eml,.msg,.ics,.vcf,.gpx,.kml,.tex,.bib,.zip" style="display:none;" onchange="handleQuickFileSelect(event)">
                        </div>
                        
                        <!-- BOUTONS PROVIDERS -->
                        <div style="display:grid;grid-template-columns:repeat(5,1fr);gap:8px;">
                            <button id="quickBtn-groq" onclick="processQuickFile('groq', 'llama-3.3-70b-versatile')" disabled style="padding:10px 8px;background:#f0f0f0;border:1px solid #C8D0C3;border-radius:4px;cursor:not-allowed;font-size:0.75em;font-weight:600;color:#999;transition:all 0.2s ease;">
                                Groq
                            </button>
                            <button id="quickBtn-deepseek" onclick="processQuickFile('deepseek', 'deepseek-chat')" disabled style="padding:10px 8px;background:#f0f0f0;border:1px solid #C8D0C3;border-radius:4px;cursor:not-allowed;font-size:0.75em;font-weight:600;color:#999;transition:all 0.2s ease;">
                                DeepSeek
                            </button>
                            <button id="quickBtn-anthropic" onclick="processQuickFile('anthropic', 'claude-sonnet-4-20250514')" disabled style="padding:10px 8px;background:#f0f0f0;border:1px solid #C8D0C3;border-radius:4px;cursor:not-allowed;font-size:0.75em;font-weight:600;color:#999;transition:all 0.2s ease;">
                                Claude
                            </button>
                            <button id="quickBtn-openai" onclick="processQuickFile('openai', 'gpt-4o')" disabled style="padding:10px 8px;background:#f0f0f0;border:1px solid #C8D0C3;border-radius:4px;cursor:not-allowed;font-size:0.75em;font-weight:600;color:#999;transition:all 0.2s ease;">
                                GPT-4o
                            </button>
                            <button id="quickBtn-google" onclick="processQuickFile('google', 'gemini-2.0-flash-exp')" disabled style="padding:10px 8px;background:#f0f0f0;border:1px solid #C8D0C3;border-radius:4px;cursor:not-allowed;font-size:0.75em;font-weight:600;color:#999;transition:all 0.2s ease;">
                                Gemini
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- PANEL WORKER -->
                <div class="mode-panel" id="panelWorker" data-mode="worker">
                    <div style="padding:12px;background:#E6D7C3;border-left:4px solid #8FAFB1;border-radius:6px;margin-bottom:12px;text-align:center;">
                        <label style="display:flex;align-items:center;justify-content:center;gap:10px;cursor:pointer;">
                            <span style="font-size:0.9em;font-weight:600;">Activer Worker Mode</span>
                            <input type="checkbox" id="workerToggle" onchange="toggleWorkerMode()" style="width:20px;height:20px;">
                        </label>
                    </div>
                    
                    <div id="workerActivePanel" style="display:none;">
                        <select id="workerModel" style="width:100%;padding:10px;margin-bottom:10px;border:1px solid #C8D0C3;border-radius:4px;font-size:0.9em;">
                            <option value="claude-sonnet-4-20250514">Sonnet 4</option>
                            <option value="claude-opus-4-20250514">Opus 4</option>
                            <option value="claude-haiku-4.5-20250514">Haiku 4.5</option>
                        </select>
                        <button class="btn" onclick="sendWithWorker()" style="width:100%;padding:12px;background:#8FAFB1;color:white;border:none;border-radius:6px;cursor:pointer;font-size:0.9em;font-weight:600;transition:all 0.2s ease;" onmouseover="this.style.background='#7A9FA1'" onmouseout="this.style.background='#8FAFB1'">
                            Analyser avec Worker
                        </button>
                        <div id="apiProgress" style="display:none;margin-top:12px;">
                            <div style="background:#E6D7C3;border-radius:6px;overflow:hidden;height:24px;">
                                <div id="apiProgressFill" style="background:#8FAFB1;height:100%;width:0%;transition:width 0.3s;display:flex;align-items:center;justify-content:center;">
                                    <span id="apiProgressText" style="color:white;font-size:0.8em;font-weight:600;">Préparation...</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ══════════════════════════════════════════════════════════════ -->
        <!-- BATCH PROCESSING -->
        <!-- ══════════════════════════════════════════════════════════════ -->
        <div class="section batch-section" id="batchSection">
            <h2>Batch Processing</h2>
            
            <!-- Batch Templates -->
            <div class="card">
                <h4>Templates Batch</h4>
                <p style="margin-bottom:15px;color:var(--gris-secondaire);">Configurations pré-définies pour traitement de dossiers</p>
                <div class="batch-templates">
                    <div class="batch-template-card" onclick="applyBatchTemplate('books_documents')">
                        <h5>📚 Livres & Documents</h5>
                        <p>Livres, manuels, guides</p>
                        <span class="template-badge">Mixte</span>
                    </div>
                    <div class="batch-template-card" onclick="applyBatchTemplate('media_collection')">
                        <h5>🎨 Collection Média</h5>
                        <p>Images, scans, photos</p>
                        <span class="template-badge">Scanné</span>
                    </div>
                    <div class="batch-template-card" onclick="applyBatchTemplate('academic_research')">
                        <h5>🔬 Académique & Recherche</h5>
                        <p>Articles, thèses, études</p>
                        <span class="template-badge">Digital</span>
                    </div>
                    <div class="batch-template-card" onclick="applyBatchTemplate('business_docs')">
                        <h5>💼 Documents Professionnels</h5>
                        <p>Rapports, contrats, factures</p>
                        <span class="template-badge">Digital</span>
                    </div>
                    <div class="batch-template-card" onclick="applyBatchTemplate('custom')">
                        <h5>⚙️ Personnalisé</h5>
                        <p>Configuration manuelle</p>
                        <span class="template-badge">Config</span>
                    </div>
                </div>
            </div>
            
            <!-- Batch Configuration -->
            <div class="batch-config-section">
                <h4>Configuration Batch</h4>
                <div class="batch-config-row">
                    <div class="batch-config-item">
                        <label>Fichiers simultanés:</label>
                        <input type="number" id="batchMaxConcurrent" value="3" min="1" max="5" onchange="updateBatchConfig()">
                    </div>
                    <div class="batch-config-item">
                        <label>Tentatives retry:</label>
                        <input type="number" id="batchRetryAttempts" value="2" min="0" max="5" onchange="updateBatchConfig()">
                    </div>
                </div>
                <div class="batch-config-row">
                    <div class="batch-config-item">
                        <label>
                            <input type="checkbox" id="batchContinueOnError" checked onchange="updateBatchConfig()">
                            Continuer si erreur
                        </label>
                    </div>
                    <div class="batch-config-item">
                        <label>Stratégie de fusion:</label>
                        <select id="batchMergeStrategy" onchange="updateBatchConfig()">
                            <option value="chronological">Chronologique</option>
                            <option value="by_type">Par type</option>
                            <option value="alphabetical">Alphabétique</option>
                            <option value="flat">Plat (pas de fusion)</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <!-- Upload Multiple Files -->
            <div class="batch-upload">
                <input type="file" id="batchFileInput" multiple accept=".pdf,.docx,.doc,.xlsx,.xls,.pptx,.ppt,.epub,.html,.htm,.md,.markdown,.txt,.png,.jpg,.jpeg,.gif,.webp,.tiff,.tif,.svg,.rtf,.odt,.ods,.odp,.csv,.tsv,.json,.xml,.yaml,.yml,.mobi,.azw,.azw3,.cbz,.cbr,.eml,.msg,.ics,.vcf,.gpx,.kml,.tex,.bib,.zip">
                <label for="batchFileInput" class="batch-upload-label">
                    Sélectionner plusieurs fichiers
                </label>
                <p style="margin-top:15px;color:var(--gris-secondaire);">Glissez-déposez plusieurs fichiers ou cliquez pour sélectionner</p>
            </div>
            
            <!-- Batch Queue -->
            <div id="batchQueue" class="batch-queue"></div>
            
            <!-- Batch Controls -->
            <div class="batch-controls">
                <button class="btn" onclick="startBatch()" id="batchStartBtn">
                    Démarrer le Batch
                </button>
                <button class="btn btn-secondary" onclick="pauseBatch()" id="batchPauseBtn" disabled>
                    Pause
                </button>
                <button class="btn btn-secondary" onclick="resumeBatch()" id="batchResumeBtn" disabled>
                    Reprendre
                </button>
                <button class="btn btn-secondary" onclick="exportPartialBatch()" id="batchExportBtn" disabled>
                    Exporter résultats partiels
                </button>
                <button class="btn" onclick="openPromptModal()" id="batchPromptBtn" disabled style="background:linear-gradient(135deg, #11998e, #38ef7d);">
                    🎯 Générer Prompt Consolidé
                </button>
                <button class="btn btn-danger" onclick="clearBatch()">
                    Tout effacer
                </button>
            </div>
            
            <!-- Batch Statistics -->
            <div class="batch-stats" id="batchStats" style="display:none;">
                <div class="batch-stat">
                    <div class="batch-stat-value" id="batchStatTotal">0</div>
                    <div class="batch-stat-label">Total</div>
                </div>
                <div class="batch-stat">
                    <div class="batch-stat-value" id="batchStatCompleted">0</div>
                    <div class="batch-stat-label">Complétés</div>
                </div>
                <div class="batch-stat">
                    <div class="batch-stat-value" id="batchStatErrors">0</div>
                    <div class="batch-stat-label">Erreurs</div>
                </div>
                <div class="batch-stat">
                    <div class="batch-stat-value" id="batchStatTime">0s</div>
                    <div class="batch-stat-label">Temps écoulé</div>
                </div>
            </div>
        </div>

        <!-- ══════════════════════════════════════════════════════════════ -->
        <!-- UPLOAD ZONE -->
        <!-- ══════════════════════════════════════════════════════════════ -->
        <div class="section">
            <h2>Upload Document</h2>
            
            <div class="drop-zone" id="dropZone">
                <input type="file" id="fileInput" accept=".pdf,.docx,.doc,.xlsx,.xls,.pptx,.ppt,.epub,.html,.htm,.md,.markdown,.txt,.png,.jpg,.jpeg,.gif,.webp,.tiff,.tif,.svg,.rtf,.odt,.ods,.odp,.csv,.tsv,.json,.xml,.yaml,.yml,.mobi,.azw,.azw3,.cbz,.cbr,.eml,.msg,.ics,.vcf,.gpx,.kml,.tex,.bib,.zip">
                
                <div class="drop-zone-content">
                    <div class="drop-zone-icon">📄</div>
                    <h3>Glissez-déposez ou cliquez pour sélectionner</h3>
                    <p>21 formats supportés • Analyse multi-dimensionnelle • OCR intelligent</p>
                </div>
            </div>
        </div>

        <!-- ══════════════════════════════════════════════════════════════ -->
        <!-- PROGRESS -->
        <!-- ══════════════════════════════════════════════════════════════ -->
        <div class="progress-container" id="progressContainer">
            <h3>Traitement en cours...</h3>
            <div class="progress-bar-container">
                <div class="progress-bar-fill" id="progressBar">0%</div>
            </div>
            <div class="progress-detail" id="progressDetail">
                <span id="progressStage">Initialisation...</span>
                <span id="progressText">Chargement...</span>
            </div>
        </div>

        <!-- ══════════════════════════════════════════════════════════════ -->
        <!-- STATUS MESSAGE -->
        <!-- ══════════════════════════════════════════════════════════════ -->
        <div class="status-message" id="statusMessage"></div>

        <!-- ══════════════════════════════════════════════════════════════ -->
        <!-- DETECTION RESULT -->
        <!-- ══════════════════════════════════════════════════════════════ -->
        <div class="section" id="detectionSection" style="display:none;">
            <!-- Rempli dynamiquement -->
        </div>

        <!-- ══════════════════════════════════════════════════════════════ -->
        <!-- API QUICK ACTIONS (SINGLE FILE) -->
        <!-- ══════════════════════════════════════════════════════════════ -->
        <div class="section" id="apiQuickActions" style="display:none;">
            <h2>🚀 Analyser avec API</h2>
            <p style="color:var(--gris-secondaire);margin-bottom:20px;">Envoyez directement ce document à un LLM pour analyse automatique</p>
            
            <div class="api-quick-grid">
                <!-- Groq Card -->
                <div class="api-quick-card" onclick="sendSingleFileToAPI('groq', 'llama-3.3-70b-versatile')">
                    <div class="api-quick-icon">⚡</div>
                    <h4>Groq (GRATUIT)</h4>
                    <p>Llama 3.3 70B</p>
                    <div class="api-quick-badge">$0.00</div>
                </div>
                
                <!-- DeepSeek Card -->
                <div class="api-quick-card" onclick="sendSingleFileToAPI('deepseek', 'deepseek-chat')">
                    <div class="api-quick-icon">💰</div>
                    <h4>DeepSeek (-89%)</h4>
                    <p>DeepSeek-V3</p>
                    <div class="api-quick-badge">~$0.018</div>
                </div>
                
                <!-- Anthropic Card -->
                <div class="api-quick-card" onclick="sendSingleFileToAPI('anthropic', 'claude-sonnet-4-20250514')">
                    <div class="api-quick-icon">🤖</div>
                    <h4>Claude Sonnet 4</h4>
                    <p>Qualité maximale</p>
                    <div class="api-quick-badge">~$0.21</div>
                </div>
                
                <!-- OpenAI Card -->
                <div class="api-quick-card" onclick="sendSingleFileToAPI('openai', 'gpt-4o')">
                    <div class="api-quick-icon">🟢</div>
                    <h4>GPT-4o</h4>
                    <p>Référence</p>
                    <div class="api-quick-badge">~$0.17</div>
                </div>
            </div>
            
            <div style="margin-top:20px;padding:15px;background:#FFF3CD;border-radius:8px;border-left:4px solid #FFC107;">
                <p style="margin:0;color:#856404;"><strong>💡 Astuce:</strong> Configurez d'abord vos clés API dans <strong>MODE 2 : API MULTI-LLM</strong> (en haut de la page)</p>
            </div>
        </div>

        <!-- ══════════════════════════════════════════════════════════════ -->
        <!-- COMPOSITION OVERRIDE -->
        <!-- ══════════════════════════════════════════════════════════════ -->
        <div id="compositionSection" class="composition-section">
            <h3>Ajustement Composition (Optionnel)</h3>
            
            <div class="card">
                <h4>Format Technique</h4>
                <select id="technicalOverride" onchange="updateTechnicalFormat()" style="width:100%;padding:12px;border-radius:8px;border:2px solid var(--beige-sable);font-family:Montserrat;font-size:15px;">
                    <option value="auto">Détection auto</option>
                    <option value="scanned">Document scanné (OCR requis)</option>
                    <option value="digital">Texte digital (natif)</option>
                    <option value="manuscrit">Manuscrit / Écriture manuelle</option>
                    <option value="photo">Photo / Capture</option>
                    <option value="image">Image vectorielle</option>
                    <option value="hybrid">Hybride (scanné + digital)</option>
                </select>
            </div>
            
            <div class="card">
                <h4>Types de Contenu (Multi-sélection)</h4>
                <p style="margin-bottom:15px;color:var(--gris-secondaire);">Cochez tous les types présents dans le document:</p>
                
                <div id="contentCheckboxes" class="content-checkboxes">
                    <!-- TYPES UNIVERSELS (10) -->
                    <div style="margin-bottom:20px;border-bottom:2px solid var(--beige-sable);padding-bottom:15px;">
                        <h5 style="color:var(--vert-sauge);margin-bottom:10px;font-size:14px;">Types Universels</h5>
                        <label class="checkbox-label">
                            <input type="checkbox" value="text_paragraphs" onchange="updateComposition()">
                            📝 Texte & Paragraphes
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" value="images_photos" onchange="updateComposition()">
                            🖼️ Images & Photos
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" value="tables_data" onchange="updateComposition()">
                            📊 Tableaux & Données
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" value="charts_graphs" onchange="updateComposition()">
                            📈 Graphiques & Courbes
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" value="diagrams_schemas" onchange="updateComposition()">
                            🔷 Diagrammes & Schémas
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" value="forms_templates" onchange="updateComposition()">
                            📋 Formulaires & Modèles
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" value="lists_bullet_points" onchange="updateComposition()">
                            • Listes & Points
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" value="code_technical" onchange="updateComposition()">
                            💻 Code & Technique
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" value="mathematical_formulas" onchange="updateComposition()">
                            🧮 Formules Mathématiques
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" value="annotations_highlights" onchange="updateComposition()">
                            ✏️ Annotations & Surlignages
                        </label>
                    </div>
                    
                    <!-- TYPES COMPLÉMENTAIRES (8) -->
                    <div>
                        <h5 style="color:var(--bleu-mer);margin-bottom:10px;font-size:14px;">Types Complémentaires</h5>
                        <label class="checkbox-label">
                            <input type="checkbox" value="musical_notation" onchange="updateComposition()">
                            🎼 Notation Musicale
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" value="citations_references" onchange="updateComposition()">
                            📖 Citations & Références
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" value="exercises_questions" onchange="updateComposition()">
                            ❓ Exercices & Questions
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" value="callouts_boxes" onchange="updateComposition()">
                            💬 Encadrés Spéciaux
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" value="index_glossary" onchange="updateComposition()">
                            📑 Index & Glossaires
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" value="case_studies" onchange="updateComposition()">
                            📚 Études de Cas
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" value="links_urls" onchange="updateComposition()">
                            🔗 Liens & URLs
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" value="infographics" onchange="updateComposition()">
                            🎨 Infographies
                        </label>
                    </div>
                </div>
                
                <div id="weightsSection" class="weights-section" style="display:none;">
                    <h5>Pondération (auto-normalisée)</h5>
                    <div id="slidersList"></div>
                    <button class="btn btn-secondary btn-small" onclick="resetWeights()" style="margin-top:15px;">
                        Réinitialiser poids automatiques
                    </button>
                </div>
            </div>
        </div>

        <!-- ══════════════════════════════════════════════════════════════ -->
        <!-- CONFIGURATION -->
        <!-- ══════════════════════════════════════════════════════════════ -->
        <div class="section" id="configSection" style="display:none;">
            <h2>Configuration</h2>
            
            <div class="config-grid">
                <div class="config-section">
                    <h4>Plateforme IA</h4>
                    <div class="platform-selector">
                        <div class="platform-option selected" id="platformChatGPT" onclick="selectPlatform('chatgpt')">
                            <strong>ChatGPT</strong>
                            <p>GPT-4o / o1</p>
                        </div>
                        <div class="platform-option" id="platformClaude" onclick="selectPlatform('claude')">
                            <strong>Claude</strong>
                            <p>Sonnet 4 / Opus 4</p>
                        </div>
                    </div>
                    
                    <div id="gptSelectorGroup" class="model-selector" style="display:block;">
                        <label>Modèle ChatGPT:</label>
                        <select id="gptSelector" onchange="updateIndicators()">
                            <option value="gpt-4o" selected>GPT-4o (Rapide, équilibré)</option>
                            <option value="o1">o1 (Raisonnement profond)</option>
                            <option value="o1-mini">o1-mini (Rapide, efficace)</option>
                        </select>
                    </div>
                    
                    <div id="claudeSelectorGroup" class="model-selector">
                        <label>Modèle Claude:</label>
                        <select id="claudeSelector" onchange="updateIndicators()">
                            <option value="claude-sonnet-4-20250514" selected>Claude Sonnet 4 (Optimal)</option>
                            <option value="claude-opus-4-20250514">Claude Opus 4 (Maximum qualité)</option>
                        </select>
                    </div>
                    
                    <div class="indicator-grid">
                        <div class="indicator">
                            <div class="indicator-label">Qualité</div>
                            <div class="indicator-value" id="qualityIndicator">Élevée</div>
                        </div>
                        <div class="indicator">
                            <div class="indicator-label">Vitesse</div>
                            <div class="indicator-value" id="speedIndicator">Rapide</div>
                        </div>
                        <div class="indicator">
                            <div class="indicator-label">Détails</div>
                            <div class="indicator-value" id="detailsIndicator">Complets</div>
                        </div>
                    </div>
                </div>
                
                <div class="config-section">
                    <h4>Format Extraction</h4>
                    <select id="formatSelector" onchange="updateIndicators()" style="width:100%;padding:12px;border-radius:8px;border:2px solid var(--beige-sable);font-family:Montserrat;font-size:15px;margin-bottom:15px;">
                        <option value="7">Standard (7 modules)</option>
                        <option value="32" selected>R&D Complet (32 modules)</option>
                    </select>
                    
                    <div id="formatDesc" style="padding:15px;background:var(--blanc);border-radius:8px;"></div>
                </div>
            </div>
            
            <div style="text-align:center;margin-top:30px;">
                <button class="btn" onclick="processFile()">
                    Lancer le Traitement
                </button>
            </div>
        </div>

        <!-- ══════════════════════════════════════════════════════════════ -->
        <!-- PARTS CONTAINER -->
        <!-- ══════════════════════════════════════════════════════════════ -->
        <div class="section" id="phase2" style="display:none;">
            <h2>Traitement par Parties</h2>
            <div id="partsContainer"></div>
        </div>

        <!-- ══════════════════════════════════════════════════════════════ -->
        <!-- EXPORT FORMATS -->
        <!-- ══════════════════════════════════════════════════════════════ -->
        <div class="section export-section" id="exportSection" style="display:none;">
            <h2>Export Multi-Format</h2>
            <p style="color:var(--gris-secondaire);margin-bottom:25px;">
                Exportez vos données extraites dans 8 formats différents pour une intégration optimale avec vos outils
            </p>
            
            <!-- Export Options -->
            <div class="export-options">
                <h4>Options d'Export</h4>
                <div class="export-option-row">
                    <span class="export-option-label">Inclure métadonnées</span>
                    <div class="export-option-control">
                        <input type="checkbox" id="exportIncludeMetadata" checked>
                    </div>
                </div>
                <div class="export-option-row">
                    <span class="export-option-label">Format d'analyse</span>
                    <div class="export-option-control">
                        <select id="exportAnalysisFormat">
                            <option value="complete">Complète</option>
                            <option value="summary">Résumé</option>
                            <option value="none">Sans analyse</option>
                        </select>
                    </div>
                </div>
                <div class="export-option-row">
                    <span class="export-option-label">Inclure texte brut</span>
                    <div class="export-option-control">
                        <input type="checkbox" id="exportIncludeRawText" checked>
                    </div>
                </div>
            </div>
            
            <!-- V6.3.0 - EXPORTS RAPIDES -->
            <div class="export-section-header">
                <h3 class="export-section-title">📦 Exports Rapides</h3>
            </div>
            <div class="export-formats-grid">
                <div class="export-format-card" onclick="exportFormat('markdown')">
                    <div class="export-format-icon">📝</div>
                    <div class="export-format-name">Markdown</div>
                    <div class="export-format-desc">Documentation structurée avec formatage</div>
                    <span class="export-format-badge">.md</span>
                </div>
                
                <div class="export-format-card" onclick="exportFormat('pdf')">
                    <div class="export-format-icon">📄</div>
                    <div class="export-format-name">PDF Report</div>
                    <div class="export-format-desc">Rapport professionnel imprimable</div>
                    <span class="export-format-badge">.pdf</span>
                </div>
                
                <div class="export-format-card" onclick="exportFormat('excel')">
                    <div class="export-format-icon">📊</div>
                    <div class="export-format-name">Excel</div>
                    <div class="export-format-desc">Feuilles de calcul avec données tabulaires</div>
                    <span class="export-format-badge">.xlsx</span>
                </div>
            </div>
            
            <!-- V6.3.0 - EXPORTS AVANCÉS (toggle) -->
            <div class="export-section-header">
                <h3 class="export-section-title">🔧 Exports Avancés</h3>
                <button class="export-toggle-btn" onclick="toggleAdvancedExports()">
                    <span id="toggleAdvancedText">▼ Afficher (5 formats)</span>
                </button>
            </div>
            <div class="export-advanced-section" id="advancedExportsSection">
                <div class="export-formats-grid">
                <div class="export-format-card" onclick="exportFormat('jsonld')">
                    <div class="export-format-icon">🔗</div>
                    <div class="export-format-name">JSON-LD</div>
                    <div class="export-format-desc">Knowledge graph (Schema.org)</div>
                    <span class="export-format-badge">.jsonld</span>
                </div>
                
                <div class="export-format-card" onclick="exportFormat('yaml')">
                    <div class="export-format-icon">⚙️</div>
                    <div class="export-format-name">YAML</div>
                    <div class="export-format-desc">Configuration lisible</div>
                    <span class="export-format-badge">.yaml</span>
                </div>
                
                <div class="export-format-card" onclick="exportFormat('obsidian')">
                    <div class="export-format-icon">💎</div>
                    <div class="export-format-name">Obsidian</div>
                    <div class="export-format-desc">Vault avec backlinks</div>
                    <span class="export-format-badge">.md + links</span>
                </div>
                
                <div class="export-format-card" onclick="exportFormat('notion')">
                    <div class="export-format-icon">📚</div>
                    <div class="export-format-name">Notion</div>
                    <div class="export-format-desc">Import CSV pour database</div>
                    <span class="export-format-badge">.csv</span>
                </div>
                
                <div class="export-format-card" onclick="exportFormat('anki')">
                    <div class="export-format-icon">🎴</div>
                    <div class="export-format-name">Anki</div>
                    <div class="export-format-desc">Flashcards pour mémorisation</div>
                    <span class="export-format-badge">.txt</span>
                </div>
            </div>
            
            <!-- Export All Button -->
            <div class="export-buttons">
                <button class="export-all-btn" onclick="exportAllFormats()">
                    Exporter Tous les Formats
                </button>
            </div>
            
            <!-- Export Preview -->
            <div id="exportPreview" style="display:none;">
                <h4>Aperçu Export</h4>
                <div class="export-preview" id="exportPreviewContent"></div>
            </div>
        </div>

        <!-- ══════════════════════════════════════════════════════════════ -->
        <!-- STATISTICS -->
        <!-- ══════════════════════════════════════════════════════════════ -->
        <div class="section" id="statsSection" style="display:none;">
            <h2>Statistiques</h2>
            <div class="stats-grid" id="statsGrid"></div>
        </div>

        <!-- ══════════════════════════════════════════════════════════════ -->
        <!-- FOOTER -->
        <!-- ══════════════════════════════════════════════════════════════ -->
        <div class="footer">
            OCR Universel V6.0 ULTIMATE - Labo R&D Anthropic + API Multi-LLM - Marie-Christine Abatte Psychologue
        </div>
    </div>

    <script>
        // ══════════════════════════════════════════════════════════════
        // GLOBAL STATE
        // ══════════════════════════════════════════════════════════════
        
        const STATE = {
            file: null,
            fileName: '',
            fileType: '',
            totalPages: 1,
            extractedText: '',
            analysis: null,
            documentType: '',
            detectionResult: null,
            format: 32,
            platform: 'chatgpt',
            processingMode: 'manual', // manual | user-keys | worker
            selectedProvider: null, // deepseek | groq | anthropic | openai | google
            
            // Batch processing state
            batch: {
                queue: [],              // Array of BatchItem
                status: 'idle',         // idle | running | paused | completed
                currentIndex: 0,
                startTime: null,
                pausedAt: null,
                stats: {
                    total: 0,
                    completed: 0,
                    errors: 0,
                    skipped: 0
                },
                config: {
                    maxConcurrent: 3,   // 3 files in parallel
                    retryAttempts: 2,
                    continueOnError: true,
                    autoMerge: false,
                    mergeStrategy: 'chronological' // chronological | by_type | alphabetical | flat
                }
            },
            gptModel: 'gpt-4o',
            claudeModel: 'claude-sonnet-4-20250514',
            parts: [],
            currentPartIndex: 0,
            startTime: null,
            batchSize: 30,
            ocrCache: null,
            ocrWorkerPool: null
        };

        // ══════════════════════════════════════════════════════════════
        // CONFIGURATION
        // ══════════════════════════════════════════════════════════════
        
        const CONFIG = {
            gpt: {
                'gpt-4o': {
                    quality: 'Élevée',
                    speed: 'Rapide',
                    details: 'Complets'
                },
                'o1': {
                    quality: 'Maximale',
                    speed: 'Lent',
                    details: 'Exhaustifs'
                },
                'o1-mini': {
                    quality: 'Bonne',
                    speed: 'Très rapide',
                    details: 'Essentiels'
                }
            },
            claude: {
                'claude-sonnet-4-20250514': {
                    quality: 'Élevée',
                    speed: 'Optimal',
                    details: 'Complets'
                },
                'claude-opus-4-20250514': {
                    quality: 'Maximale',
                    speed: 'Modéré',
                    details: 'Exhaustifs'
                }
            },
            format: {
                7: 'Structure hiérarchique, index conceptuel, contenu enrichi, graphe de connaissances, taxonomie, analytics (7 modules essentiels)',
                32: 'Tous les modules Standard PLUS : sémantique avancée, pédagogie, multimodal, évaluation, références, citations, contexte historique, applications, controverses, glossaire, stats, comparaisons, implémentation, public cible, ressources, validation, méta-analyse, liens, temporalité, patterns, insights, analytics (32 modules R&D)'
            },
            BATCH_FACTORS: {
                base_batch_size: 30,
                technical: {
                    'scanned': 0.7,
                    'photo': 0.6,
                    'manuscrit': 0.5,
                    'digital': 1.2,
                    'image': 1.0,
                    'hybrid': 0.8
                },
                content: {
                    'partition_musicale': 0.8,
                    'tablature': 0.7,
                    'texte_pedagogique': 1.0,
                    'regles_jeu': 0.9,
                    'document_therapie': 1.1,
                    'questionnaire_psy': 1.2,
                    'paper_scientifique': 0.9,
                    'manuel_technique': 1.0,
                    'text_standard': 1.0
                }
            },
            PATTERNS: {
                technical: {
                    density_thresholds: {
                        digital_low: 0.15,
                        scanned_high: 0.5,
                        hybrid_variance: 0.1
                    }
                },
                content: {
                    partition_musicale: {
                        filename: ['partition', 'score', 'sheet', 'realbook', 'fake book', 'songbook', 'lead sheet', 'transcription', 'music', 'sade', 'aebersold'],
                        metadata: ['music', 'musical', 'score', 'composition', 'composer'],
                        text: [
                            /\b[A-G][#b♯♭]?(m|maj|min|M|dim|aug|sus)?[0-9]?\b/g,
                            /\b[A-G][#b♯♭]?7(b9|#9|b5|#5|#11)?\b/g,
                            '♯', '♭', '♮', 'verse', 'chorus', 'bridge', 'intro', 'outro', 'solo',
                            'refrain', 'couplet', 'walking bass', 'chord changes', 'turnaround',
                            'ii-v-i', 'cadence', 'swing', 'bossa', 'groove', 'tempo', 'bpm'
                        ]
                    },
                    tablature: {
                        filename: ['tab', 'tablature', 'guitar tab', 'bass tab'],
                        text: ['tab', 'tablature', 'fret', 'string', /[EADGBE][-|0-9]+/]
                    },
                    texte_pedagogique: {
                        filename: ['cours', 'lesson', 'tutorial', 'guide', 'method'],
                        text: ['learn', 'practice', 'exercise', 'lesson', 'apprendre', 'exercice']
                    },
                    regles_jeu: {
                        filename: ['rules', 'game', 'jeu', 'règles'],
                        text: ['player', 'turn', 'round', 'winner', 'joueur', 'tour', 'gagnant']
                    },
                    document_therapie: {
                        filename: ['therapy', 'couple', 'thérapie', 'therapist'],
                        text: ['therapist', 'patient', 'session', 'thérapeute', 'séance']
                    },
                    questionnaire_psy: {
                        filename: ['questionnaire', 'test', 'evaluation', 'assessment'],
                        text: ['question', 'answer', 'score', 'échelle', 'agree', 'disagree']
                    },
                    paper_scientifique: {
                        filename: ['paper', 'article', 'research', 'étude'],
                        text: ['abstract', 'introduction', 'methodology', 'results', 'conclusion']
                    },
                    manuel_technique: {
                        filename: ['manual', 'guide', 'documentation', 'specs'],
                        text: ['installation', 'configuration', 'troubleshooting', 'specification']
                    }
                }
            }
        };

        // ══════════════════════════════════════════════════════════════
        // MULTI-LLM API MANAGER V6.0
        // ══════════════════════════════════════════════════════════════
        
        class MultiLLMManager {
            constructor() {
                this.workerURL = 'https://ocr-universel-proxy.11drumboy11.workers.dev';
                this.mode = 'worker'; // 'worker' ou 'user_keys'
                this.userKeys = {};
                this.loadUserKeys();
                
                console.log('[MultiLLM] 🚀 Manager initialized');
                console.log(`[MultiLLM] Mode: ${this.mode}`);
                console.log(`[MultiLLM] Worker URL: ${this.workerURL}`);
            }
            
            // ═══ CONFIGURATION ═══
            
            switchMode(newMode) {
                if (!['worker', 'user_keys'].includes(newMode)) {
                    console.error('[MultiLLM] Mode invalide:', newMode);
                    return false;
                }
                
                this.mode = newMode;
                localStorage.setItem('multiLLM_mode', newMode);
                console.log(`[MultiLLM] 🔀 Mode switched to: ${newMode}`);
                return true;
            }
            
            setUserKey(provider, apiKey, model = null) {
                if (!this.validateKey(provider, apiKey)) {
                    console.error('[MultiLLM] ❌ Clé invalide pour provider:', provider);
                    return false;
                }
                
                this.userKeys[provider] = this.xorEncrypt(apiKey, 'ocr-v6-secret-2025');
                this.saveUserKeys();
                console.log(`[MultiLLM] ✅ Clé ${provider} sauvegardée`);
                return true;
            }
            
            validateKey(provider, key) {
                const patterns = {
                    'anthropic': /^sk-ant-api03-[A-Za-z0-9_-]{95,}$/,
                    'openai': /^sk-[A-Za-z0-9]{20,}$/,
                    'google': /^AIza[A-Za-z0-9_-]{35}$/,
                    'deepseek': /^sk-[A-Za-z0-9]{20,}$/,
                    'groq': /^gsk_[A-Za-z0-9]{20,}$/
                };
                
                return patterns[provider] && patterns[provider].test(key);
            }
            
            // ═══ STORAGE ═══
            
            saveUserKeys() {
                try {
                    localStorage.setItem('multiLLM_keys', JSON.stringify(this.userKeys));
                } catch (error) {
                    console.error('[MultiLLM] Erreur sauvegarde clés:', error);
                }
            }
            
            loadUserKeys() {
                try {
                    const saved = localStorage.getItem('multiLLM_keys');
                    const mode = localStorage.getItem('multiLLM_mode');
                    
                    if (saved) {
                        this.userKeys = JSON.parse(saved);
                    }
                    
                    if (mode) {
                        this.mode = mode;
                    }
                } catch (error) {
                    console.error('[MultiLLM] Erreur chargement clés:', error);
                }
            }
            
            getUserKey(provider) {
                if (!this.userKeys[provider]) {
                    return null;
                }
                
                try {
                    return this.xorDecrypt(this.userKeys[provider], 'ocr-v6-secret-2025');
                } catch (error) {
                    console.error('[MultiLLM] Erreur déchiffrement clé:', error);
                    return null;
                }
            }
            
            xorEncrypt(text, key) {
                let result = '';
                for (let i = 0; i < text.length; i++) {
                    result += String.fromCharCode(text.charCodeAt(i) ^ key.charCodeAt(i % key.length));
                }
                return btoa(result);
            }
            
            xorDecrypt(encrypted, key) {
                try {
                    const text = atob(encrypted);
                    let result = '';
                    for (let i = 0; i < text.length; i++) {
                        result += String.fromCharCode(text.charCodeAt(i) ^ key.charCodeAt(i % key.length));
                    }
                    return result;
                } catch (error) {
                    return null;
                }
            }
            
            // ═══ API CALLS ═══
            
            async sendPrompt(promptText, options = {}) {
                const {
                    provider = 'anthropic',
                    model = 'claude-sonnet-4-20250514',
                    max_tokens = 4096,
                    temperature = 0.3
                } = options;
                
                console.log(`[MultiLLM] 📤 Sending to ${provider}/${model}`);
                
                try {
                    let response;
                    
                    // ✅ FORCER APPEL DIRECT pour Groq et DeepSeek (Worker ne les supporte pas)
                    const directProviders = ['groq', 'deepseek'];
                    const useDirectAPI = directProviders.includes(provider) || this.mode === 'user_keys';
                    
                    if (this.mode === 'worker' && !useDirectAPI) {
                        console.log('[MultiLLM] Using Worker (Cloudflare)');
                        response = await this.callViaWorker(provider, model, promptText, max_tokens, temperature);
                    } else {
                        console.log('[MultiLLM] Using Direct API call');
                        response = await this.callDirectAPI(provider, model, promptText, max_tokens, temperature);
                    }
                    
                    console.log('[MultiLLM] ✅ Response received');
                    return this.parseResponse(provider, response);
                    
                } catch (error) {
                    console.error('[MultiLLM] ❌ Error:', error);
                    throw error;
                }
            }
            
            async callViaWorker(provider, model, prompt, max_tokens, temperature) {
                const response = await fetch(this.workerURL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        provider,
                        model,
                        max_tokens,
                        temperature,
                        messages: [
                            { role: 'user', content: prompt }
                        ]
                    })
                });
                
                if (!response.ok) {
                    const error = await response.text();
                    throw new Error(`Worker error: ${error}`);
                }
                
                return await response.json();
            }
            
            async callDirectAPI(provider, model, prompt, max_tokens, temperature) {
                const apiKey = this.xorDecrypt(this.userKeys[provider], 'ocr-v6-secret-2025');
                
                if (!apiKey) {
                    throw new Error(`Clé API ${provider} non configurée`);
                }
                
                const endpoints = {
                    'anthropic': 'https://api.anthropic.com/v1/messages',
                    'openai': 'https://api.openai.com/v1/chat/completions',
                    'google': 'https://generativelanguage.googleapis.com/v1beta/models',
                    'deepseek': 'https://api.deepseek.com/v1/chat/completions',
                    'groq': 'https://api.groq.com/openai/v1/chat/completions'
                };
                
                if (provider === 'anthropic') {
                    const response = await fetch(endpoints.anthropic, {
                        method: 'POST',
                        headers: {
                            'x-api-key': apiKey,
                            'anthropic-version': '2023-06-01',
                            'content-type': 'application/json'
                        },
                        body: JSON.stringify({
                            model,
                            max_tokens,
                            temperature,
                            messages: [{ role: 'user', content: prompt }]
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`API Anthropic error: ${response.status}`);
                    }
                    
                    return await response.json();
                }
                
                // DeepSeek, Groq, OpenAI (format compatible OpenAI)
                if (['openai', 'deepseek', 'groq'].includes(provider)) {
                    const response = await fetch(endpoints[provider], {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            model,
                            max_tokens,
                            temperature,
                            messages: [{ role: 'user', content: prompt }]
                        })
                    });
                    
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`API ${provider} error: ${response.status} - ${errorText}`);
                    }
                    
                    return await response.json();
                }
                
                throw new Error(`Provider ${provider} non supporté en mode direct`);
            }
            
            parseResponse(provider, response) {
                if (provider === 'anthropic') {
                    const text = response.content[0].text.trim();
                    
                    // Auto-nettoyage JSON
                    let cleaned = text.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
                    
                    try {
                        return {
                            text,
                            json: JSON.parse(cleaned),
                            usage: response.usage,
                            model: response.model
                        };
                    } catch (e) {
                        return {
                            text,
                            json: null,
                            usage: response.usage,
                            model: response.model
                        };
                    }
                }
                
                // Format OpenAI-compatible (OpenAI, DeepSeek, Groq)
                if (['openai', 'deepseek', 'groq'].includes(provider)) {
                    const text = response.choices[0].message.content.trim();
                    
                    // Auto-nettoyage JSON
                    let cleaned = text.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
                    
                    try {
                        return {
                            text,
                            json: JSON.parse(cleaned),
                            usage: response.usage,
                            model: response.model
                        };
                    } catch (e) {
                        return {
                            text,
                            json: null,
                            usage: response.usage,
                            model: response.model
                        };
                    }
                }
                
                return response;
            }
            
            // ═══ COST ESTIMATION ═══
            
            estimateCost(provider, model, inputTokens, outputTokens) {
                const pricing = {
                    anthropic: {
                        'claude-sonnet-4-20250514': { input: 3, output: 15 },
                        'claude-opus-4-20250514': { input: 15, output: 75 },
                        'claude-haiku-4.5-20250514': { input: 0.8, output: 4 }
                    },
                    openai: {
                        'gpt-4o': { input: 2.5, output: 10 },
                        'gpt-4o-mini': { input: 0.15, output: 0.6 },
                        'o1': { input: 15, output: 60 }
                    },
                    google: {
                        'gemini-1.5-pro': { input: 0.5, output: 1.5 },
                        'gemini-1.5-flash': { input: 0.075, output: 0.30 }
                    },
                    deepseek: {
                        'deepseek-chat': { input: 0.27, output: 1.10 },
                        'deepseek-reasoner': { input: 0.55, output: 2.19 }
                    },
                    groq: {
                        'llama-3.3-70b-versatile': { input: 0, output: 0 },
                        'llama-3.1-70b-versatile': { input: 0, output: 0 },
                        'mixtral-8x7b-32768': { input: 0, output: 0 }
                    }
                };
                
                const rates = pricing[provider]?.[model];
                if (!rates) return { cost: 0, currency: 'USD' };
                
                const cost = (inputTokens / 1000000 * rates.input) + (outputTokens / 1000000 * rates.output);
                
                return {
                    cost: cost.toFixed(4),
                    currency: 'USD',
                    breakdown: {
                        input: (inputTokens / 1000000 * rates.input).toFixed(4),
                        output: (outputTokens / 1000000 * rates.output).toFixed(4)
                    }
                };
            }
        }
        
        // Instance globale
        let multiLLM = new MultiLLMManager();

        // ══════════════════════════════════════════════════════════════
        // PROMPT MODULES (FROM V4)
        // ══════════════════════════════════════════════════════════════
        
        const PROMPT_MODULES = {
            technical: {
                scanned: `⚠️ DOCUMENT SCANNÉ - OCR REQUIS
- Qualité variable, possibles erreurs OCR
- Vérifier cohérence texte extrait
- Signaler ambiguïtés dans notes`,
                
                digital: `✓ DOCUMENT DIGITAL NATIF
- Texte propre, extraction fiable
- Structure préservée`,
                
                manuscrit: `⚠️ ÉCRITURE MANUSCRITE - OCR DIFFICILE
- Interpréter au mieux
- Signaler parties illisibles`,
                
                photo: `⚠️ PHOTO/CAPTURE - OCR REQUIS
- Qualité image variable
- Possible distorsion perspective`,
                
                image: `🖼️ IMAGE/VECTORIEL
- Possible contenu graphique dominant
- Texte peut être secondaire`,
                
                hybrid: `⚠️ DOCUMENT HYBRIDE (MIXTE)
- Pages scannées + pages digitales
- Adapter traitement par section`
            },
            
            content: {
                partition_musicale: `🎸 EXTRACTION PARTITION MUSICALE

CRITICAL: Extract ALL musical content with COMPLETE accuracy.

Structure JSON:
{
  "morceaux": [
    {
      "titre": "exact title",
      "tonalite": "key (e.g. Bb, F#m)",
      "tempo": "tempo/feel (e.g. Medium Swing, 120 bpm)",
      "grille_accords": {
        "nombre_mesures": NUMBER,
        "structure": "form (AABA, Blues, etc)",
        "mesures": ["Gm7", "C7", "Fm7", "Bb7", ...]
      },
      "techniques_requises": ["Walking bass", "Chord tones", ...],
      "analyse_harmonique": {
        "cadences": ["ii-V-I bars 5-8", ...],
        "substitutions": ["tritone sub bar 12", ...],
        "modulations": [...]
      }
    }
  ]
}

INSTRUCTIONS:
1. EXTRACT ALL chord charts measure by measure
2. IDENTIFY ii-V-I cadences, turnarounds
3. NOTE bass techniques (walking, chord tones, chromatic approaches)
4. ANALYZE harmony (substitutions, modulations)
5. TRANSCRIBE tablature if present`,
                
                tablature: `🎼 EXTRACTION TABLATURE

Structure JSON:
{
  "tablatures": [
    {
      "titre": "title",
      "instrument": "4-string bass",
      "accordage": "standard (E-A-D-G)",
      "notation_complete": "E|------|\\nA|------|\\n...",
      "techniques": ["hammer-on", "pull-off", "slide", ...],
      "fingering": "1-3-4-3-1"
    }
  ]
}

INSTRUCTIONS:
1. TRANSCRIBE complete notation line by line
2. IDENTIFY techniques (H=hammer, P=pull-off, /=slide)
3. NOTE fingering if indicated`,
                
                texte_pedagogique: `📚 EXTRACTION PÉDAGOGIQUE

Structure JSON:
{
  "objectifs_apprentissage": ["clear learning objectives"],
  "prerequis": ["required prior knowledge"],
  "progression": {
    "etapes": [
      {
        "numero": 1,
        "titre": "step title",
        "objectif": "step objective",
        "duree_estimee": "estimated time",
        "exercices": [...]
      }
    ]
  }
}

INSTRUCTIONS:
1. IDENTIFY explicit learning objectives
2. LIST prerequisites
3. STRUCTURE pedagogical progression
4. EXTRACT all exercises with instructions`,
                
                regles_jeu: `🎲 EXTRACTION RÈGLES JEU

Structure JSON:
{
  "nom_jeu": "game name",
  "nombre_joueurs": "player count",
  "composants": [{"nom": "component", "quantite": "quantity"}],
  "mise_en_place": {"etapes": ["setup steps"]},
  "deroulement": {"phases_tour": ["turn phases"]},
  "conditions_victoire": "win conditions"
}

INSTRUCTIONS:
1. LIST all components
2. DESCRIBE setup step by step
3. STRUCTURE turn sequence`,
                
                document_therapie: `💑 EXTRACTION DOCUMENT THÉRAPIE

Structure JSON:
{
  "type_document": "protocole | cas_clinique | evaluation",
  "domaine": "couple | individuel | famille",
  "cas_cliniques": [
    {
      "presentation": "case presentation",
      "problematique": "issue",
      "intervention": "therapeutic intervention",
      "evolution": "outcome"
    }
  ],
  "outils_therapeutiques": [...]
}

INSTRUCTIONS:
1. IDENTIFY document type
2. EXTRACT complete clinical cases
3. LIST tools used`,
                
                questionnaire_psy: `📋 EXTRACTION QUESTIONNAIRE PSY

Structure JSON:
{
  "nom_questionnaire": "Big Five | NEO-PI | Gottman",
  "echelles": [
    {
      "nom": "scale name",
      "description": "what it measures",
      "items": [1, 6, 11, ...]
    }
  ],
  "items": [
    {
      "numero": 1,
      "texte": "item text",
      "echelle_inversee": true/false
    }
  ]
}

INSTRUCTIONS:
1. IDENTIFY questionnaire
2. LIST all scales/dimensions
3. EXTRACT ALL items in order`,
                
                paper_scientifique: `🔬 EXTRACTION PAPER SCIENTIFIQUE

Structure JSON:
{
  "titre": "paper title",
  "auteurs": ["author list"],
  "abstract": "complete abstract",
  "methodologie": {
    "participants": "sample description",
    "procedure": "research procedure"
  },
  "resultats": {
    "principaux": ["key findings"]
  },
  "bibliographie": [...]
}

INSTRUCTIONS:
1. EXTRACT complete abstract
2. STRUCTURE methodology
3. LIST key results`,
                
                manuel_technique: `🔧 EXTRACTION MANUEL TECHNIQUE

Structure JSON:
{
  "produit": "product name",
  "specifications": ["technical specs"],
  "installation": {
    "prerequis": ["requirements"],
    "etapes": ["steps"]
  },
  "procedures": [...],
  "troubleshooting": [...]
}

INSTRUCTIONS:
1. LIST technical specifications
2. STRUCTURE installation procedure
3. COMPILE troubleshooting guide`
            }
        };

        // ══════════════════════════════════════════════════════════════
        // OCR CACHE (IndexedDB)
        // ══════════════════════════════════════════════════════════════
        
        async function initOCRCache() {
            if (!window.idb) {
                console.warn('IndexedDB not available');
                return null;
            }
            
            try {
                const db = await idb.openDB('ocr-cache-v5', 1, {
                    upgrade(db) {
                        if (!db.objectStoreNames.contains('texts')) {
                            db.createObjectStore('texts', { keyPath: 'hash' });
                        }
                    }
                });
                
                return {
                    async get(fileHash) {
                        return await db.get('texts', fileHash);
                    },
                    
                    async set(fileHash, result) {
                        await db.put('texts', {
                            hash: fileHash,
                            result,
                            timestamp: Date.now(),
                            filename: STATE.fileName
                        });
                    },
                    
                    async hashFile(file) {
                        const buffer = await file.arrayBuffer();
                        const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
                        return Array.from(new Uint8Array(hashBuffer))
                            .map(b => b.toString(16).padStart(2, '0'))
                            .join('');
                    }
                };
            } catch (error) {
                console.error('Failed to init OCR cache:', error);
                return null;
            }
        }

        // ══════════════════════════════════════════════════════════════
        // OCR WORKER POOL (PARALLEL)
        // ══════════════════════════════════════════════════════════════
        
        class OCRWorkerPool {
            constructor() {
                const memory = navigator.deviceMemory || 4;
                const cores = navigator.hardwareConcurrency || 2;
                
                this.maxWorkers = Math.min(
                    Math.floor(memory / 0.2),
                    cores,
                    4
                );
                
                this.workers = [];
                this.queue = [];
                
                console.log(`OCR Worker Pool: ${this.maxWorkers} workers max`);
            }
            
            async recognize(file) {
                if (STATE.ocrCache) {
                    const fileHash = await STATE.ocrCache.hashFile(file);
                    const cached = await STATE.ocrCache.get(fileHash);
                    
                    if (cached && Date.now() - cached.timestamp < 7 * 24 * 3600 * 1000) {
                        console.log('Cache hit:', file.name);
                        showStatus('Texte trouvé en cache !', 'success');
                        return cached.result;
                    }
                }
                
                return new Promise((resolve, reject) => {
                    this.queue.push({ file, resolve, reject });
                    this.processQueue();
                });
            }
            
            async processQueue() {
                while (this.workers.length < this.maxWorkers && this.queue.length > 0) {
                    const job = this.queue.shift();
                    
                    this.executeOCR(job);
                }
            }
            
            async executeOCR(job) {
                const workerIndex = this.workers.length;
                this.workers.push(job);
                
                try {
                    showStatus(`OCR en cours (worker ${workerIndex + 1})...`, 'info');
                    
                    const { data: { text, confidence } } = await Tesseract.recognize(
                        job.file,
                        'fra+eng',
                        {
                            logger: m => {
                                if (m.status === 'recognizing text') {
                                    const pct = Math.round(m.progress * 100);
                                    updateProgress(30 + pct * 0.5, `OCR Worker ${workerIndex + 1}`, `${pct}%`);
                                }
                            }
                        }
                    );
                    
                    const result = {
                        text: text.trim(),
                        confidence: confidence / 100,
                        wordCount: text.split(/\s+/).length,
                        method: 'tesseract_ocr_parallel'
                    };
                    
                    if (STATE.ocrCache) {
                        const fileHash = await STATE.ocrCache.hashFile(job.file);
                        await STATE.ocrCache.set(fileHash, result);
                    }
                    
                    job.resolve(result);
                    
                } catch (error) {
                    console.error('OCR error:', error);
                    job.reject(error);
                    
                } finally {
                    this.workers = this.workers.filter(w => w !== job);
                    this.processQueue();
                }
            }
        }

        // ══════════════════════════════════════════════════════════════
        // BATCH PROGRESS TRACKER
        // ══════════════════════════════════════════════════════════════
        
        class BatchProgressTracker {
            constructor() {
                this.items = new Map(); // fileId -> progress data
            }
            
            initFile(fileId, fileName, totalPages) {
                this.items.set(fileId, {
                    fileId,
                    fileName,
                    totalPages,
                    currentPage: 0,
                    phase: 'queued', // queued | extracting | analyzing | generating | completed | error
                    progress: 0,     // 0-100%
                    startTime: null,
                    endTime: null,
                    error: null,
                    lastMessage: ''
                });
            }
            
            updateProgress(fileId, phase, progress, message = '') {
                const item = this.items.get(fileId);
                if (!item) return;
                
                item.phase = phase;
                item.progress = Math.min(100, Math.max(0, progress));
                item.lastMessage = message;
                
                if (phase === 'extracting' && !item.startTime) {
                    item.startTime = Date.now();
                }
                
                if (phase === 'completed' || phase === 'error') {
                    item.endTime = Date.now();
                }
                
                // Update UI
                this.renderFileProgress(fileId);
            }
            
            setError(fileId, error) {
                const item = this.items.get(fileId);
                if (!item) return;
                
                item.phase = 'error';
                item.error = error;
                item.endTime = Date.now();
                
                this.renderFileProgress(fileId);
            }
            
            renderFileProgress(fileId) {
                const item = this.items.get(fileId);
                if (!item) return;
                
                const card = document.querySelector(`[data-file-id="${fileId}"]`);
                if (!card) return;
                
                // Update progress bar
                const progressBar = card.querySelector('.batch-progress-fill');
                if (progressBar) {
                    progressBar.style.width = `${item.progress}%`;
                }
                
                // Update status badge
                const statusBadge = card.querySelector('.batch-file-status');
                if (statusBadge) {
                    statusBadge.textContent = this.getPhaseLabel(item.phase);
                    statusBadge.className = `batch-file-status status-${item.phase}`;
                }
                
                // Update message
                const messageDiv = card.querySelector('.batch-progress-message');
                if (messageDiv) {
                    messageDiv.textContent = item.lastMessage || '';
                }
                
                // Show/hide error message
                let errorDiv = card.querySelector('.batch-error-message');
                if (item.error) {
                    if (!errorDiv) {
                        errorDiv = document.createElement('div');
                        errorDiv.className = 'batch-error-message';
                        card.appendChild(errorDiv);
                    }
                    errorDiv.textContent = item.error;
                } else if (errorDiv) {
                    errorDiv.remove();
                }
            }
            
            getPhaseLabel(phase) {
                const labels = {
                    queued: 'En attente',
                    extracting: 'Extraction...',
                    analyzing: 'Analyse...',
                    generating: 'Génération prompts...',
                    completed: 'Terminé',
                    error: 'Erreur'
                };
                return labels[phase] || phase;
            }
            
            getFileData(fileId) {
                return this.items.get(fileId);
            }
            
            getAllCompleted() {
                return Array.from(this.items.values()).filter(item => item.phase === 'completed');
            }
            
            getAllErrors() {
                return Array.from(this.items.values()).filter(item => item.phase === 'error');
            }
            
            clear() {
                this.items.clear();
            }
        }

        // ══════════════════════════════════════════════════════════════
        // BATCH ERROR HANDLER
        // ══════════════════════════════════════════════════════════════
        
        class BatchErrorHandler {
            constructor(config) {
                this.maxRetries = config.retryAttempts || 2;
                this.continueOnError = config.continueOnError !== false;
                this.errors = new Map(); // fileId -> error details
            }
            
            async processWithRetry(fileId, processFunc) {
                let attempt = 0;
                let lastError = null;
                
                while (attempt <= this.maxRetries) {
                    try {
                        const result = await processFunc();
                        return { success: true, result };
                        
                    } catch (error) {
                        lastError = error;
                        attempt++;
                        
                        console.error(`Attempt ${attempt}/${this.maxRetries + 1} failed for ${fileId}:`, error);
                        
                        if (attempt <= this.maxRetries) {
                            // Exponential backoff: 2^attempt seconds
                            const backoffMs = Math.pow(2, attempt) * 1000;
                            console.log(`Waiting ${backoffMs}ms before retry...`);
                            await this.sleep(backoffMs);
                        }
                    }
                }
                
                // All retries exhausted
                this.logError(fileId, lastError, attempt);
                
                if (this.continueOnError) {
                    return { success: false, error: lastError };
                } else {
                    throw lastError;
                }
            }
            
            logError(fileId, error, attempts) {
                this.errors.set(fileId, {
                    error: error.message || String(error),
                    stack: error.stack,
                    attempts,
                    timestamp: Date.now()
                });
            }
            
            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
            
            getErrorReport() {
                const report = [];
                this.errors.forEach((details, fileId) => {
                    report.push({
                        fileId,
                        error: details.error,
                        attempts: details.attempts,
                        timestamp: new Date(details.timestamp).toISOString()
                    });
                });
                return report;
            }
            
            clearErrors() {
                this.errors.clear();
            }
            
            hasErrors() {
                return this.errors.size > 0;
            }
        }

        // ══════════════════════════════════════════════════════════════
        // BATCH CONTROLLER
        // ══════════════════════════════════════════════════════════════
        
        class BatchController {
            constructor() {
                this.status = 'idle';
                this.pauseRequested = false;
                this.progressTracker = new BatchProgressTracker();
                this.errorHandler = new BatchErrorHandler(STATE.batch.config);
            }
            
            async startBatch() {
                if (this.status === 'running') {
                    console.warn('Batch already running');
                    return;
                }
                
                if (STATE.batch.queue.length === 0) {
                    showStatus('Aucun fichier dans la file batch', 'warning');
                    return;
                }
                
                this.status = 'running';
                this.pauseRequested = false;
                STATE.batch.status = 'running';
                STATE.batch.startTime = Date.now();
                
                // Update UI
                updateBatchButtons();
                document.getElementById('batchStats').style.display = 'grid';
                
                showStatus('Démarrage du batch...', 'info');
                
                await this.processBatchQueue();
            }
            
            pauseBatch() {
                if (this.status !== 'running') return;
                
                this.pauseRequested = true;
                STATE.batch.status = 'paused';
                STATE.batch.pausedAt = Date.now();
                
                updateBatchButtons();
                showStatus('Pause demandée... Fin du fichier en cours', 'info');
            }
            
            async resumeBatch() {
                if (this.status !== 'paused') return;
                
                this.pauseRequested = false;
                this.status = 'running';
                STATE.batch.status = 'running';
                
                updateBatchButtons();
                showStatus('Reprise du batch...', 'success');
                
                await this.processBatchQueue();
            }
            
            async processBatchQueue() {
                const queue = STATE.batch.queue;
                const config = STATE.batch.config;
                
                while (STATE.batch.currentIndex < queue.length && !this.pauseRequested) {
                    const concurrentPromises = [];
                    
                    // Process maxConcurrent files in parallel
                    for (let i = 0; i < config.maxConcurrent && STATE.batch.currentIndex < queue.length; i++) {
                        const index = STATE.batch.currentIndex++;
                        const item = queue[index];
                        
                        // Skip already completed or errored
                        if (item.status === 'completed' || item.status === 'error') continue;
                        
                        const promise = this.processFileInBatch(item, index);
                        concurrentPromises.push(promise);
                    }
                    
                    await Promise.all(concurrentPromises);
                    
                    // Update stats
                    updateBatchStats();
                }
                
                // Check if paused or completed
                if (this.pauseRequested) {
                    this.status = 'paused';
                    showStatus('Batch en pause', 'info');
                } else {
                    this.status = 'completed';
                    STATE.batch.status = 'completed';
                    
                    // ═══ CONSOLIDATION DES RÉSULTATS ═══
                    STATE.batch.consolidatedResults = [];
                    for (const item of queue) {
                        if (item.status === 'completed' && item.result) {
                            const result = item.result;
                            STATE.batch.consolidatedResults.push({
                                filename: result.fileName || item.file.name,
                                pages: result.analysis?.structure?.page_count || 1,
                                wordCount: result.analysis?.text_metrics?.word_count || 
                                          (result.extractedText ? result.extractedText.split(/\s+/).length : 0),
                                text: result.extractedText || '',
                                analysis: result.analysis,
                                prompt: result.prompt
                            });
                        }
                    }
                    console.log(`[Batch] ${STATE.batch.consolidatedResults.length} résultats consolidés`);
                    
                    showStatus(`Batch terminé ! ${STATE.batch.stats.completed} fichiers traités`, 'success');
                    updateBatchButtons();
                }
            }
            
            async processFileInBatch(item, index) {
                try {
                    item.status = 'processing';
                    this.progressTracker.initFile(item.id, item.file.name, 1);
                    
                    // Update UI
                    renderBatchItem(item, index);
                    
                    // Process with retry logic
                    const result = await this.errorHandler.processWithRetry(
                        item.id,
                        async () => await this.processFile(item)
                    );
                    
                    if (result.success) {
                        item.status = 'completed';
                        item.result = result.result;
                        STATE.batch.stats.completed++;
                        this.progressTracker.updateProgress(item.id, 'completed', 100, 'Fichier traité avec succès');
                    } else {
                        item.status = 'error';
                        item.error = result.error.message || String(result.error);
                        STATE.batch.stats.errors++;
                        this.progressTracker.setError(item.id, item.error);
                    }
                    
                } catch (error) {
                    item.status = 'error';
                    item.error = error.message || String(error);
                    STATE.batch.stats.errors++;
                    this.progressTracker.setError(item.id, item.error);
                }
                
                renderBatchItem(item, index);
            }
            
            async processFile(item) {
                // Phase 1: Extraction
                this.progressTracker.updateProgress(item.id, 'extracting', 10, 'Extraction du texte...');
                
                const fileType = item.file.name.split('.').pop().toLowerCase();
                let extractedText = '';
                
                // Extract text based on file type
                try {
                    if (fileType === 'pdf') {
                        extractedText = await this.extractPDFText(item.file);
                    } else if (['txt', 'md', 'markdown'].includes(fileType)) {
                        extractedText = await item.file.text();
                    } else if (['docx', 'doc'].includes(fileType)) {
                        extractedText = await this.extractDOCXText(item.file);
                    } else if (['xlsx', 'xls'].includes(fileType)) {
                        extractedText = await this.extractExcelText(item.file);
                    } else if (['epub'].includes(fileType)) {
                        extractedText = await this.extractEPUBText(item.file);
                    } else if (['html', 'htm'].includes(fileType)) {
                        extractedText = await this.extractHTMLText(item.file);
                    } else if (['csv', 'tsv'].includes(fileType)) {
                        extractedText = await this.extractCSVText(item.file);
                    } else if (['json'].includes(fileType)) {
                        extractedText = await this.extractJSONText(item.file);
                    } else if (['xml'].includes(fileType)) {
                        extractedText = await this.extractXMLText(item.file);
                    } else if (['yaml', 'yml'].includes(fileType)) {
                        extractedText = await this.extractYAMLText(item.file);
                    } else if (['png', 'jpg', 'jpeg', 'gif', 'webp', 'tiff', 'tif'].includes(fileType)) {
                        // Images need OCR
                        extractedText = await this.extractImageTextOCR(item.file);
                    } else {
                        // Generic text extraction attempt
                        extractedText = await item.file.text();
                    }
                } catch (error) {
                    console.error(`Error extracting ${fileType}:`, error);
                    throw new Error(`Impossible d'extraire le texte de ${fileType}: ${error.message}`);
                }
                
                this.progressTracker.updateProgress(item.id, 'extracting', 40, 'Texte extrait');
                
                // Phase 2: Analysis
                this.progressTracker.updateProgress(item.id, 'analyzing', 50, 'Analyse du contenu...');
                
                // Create extractedData object with required properties
                const extractedData = {
                    text: extractedText,
                    method: `batch_${fileType}`,
                    confidence: 0.9,
                    wordCount: extractedText.split(/\s+/).length
                };
                
                const analysis = await detectDocumentMultiDimensionalFromText(
                    item.file, 
                    extractedText, 
                    extractedData
                );
                
                this.progressTracker.updateProgress(item.id, 'analyzing', 70, 'Analyse terminée');
                
                // Phase 3: Generate prompt
                this.progressTracker.updateProgress(item.id, 'generating', 80, 'Génération du prompt...');
                
                const prompt = generatePrompt({
                    file: item.file,
                    fileName: item.file.name,
                    extractedText,
                    analysis,
                    totalPages: 1
                });
                
                this.progressTracker.updateProgress(item.id, 'generating', 100, 'Prompt généré');
                
                return {
                    fileName: item.file.name,
                    extractedText,
                    analysis,
                    prompt
                };
            }
            
            async extractPDFText(file) {
                const arrayBuffer = await file.arrayBuffer();
                const pdfDoc = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                let fullText = '';
                
                for (let i = 1; i <= pdfDoc.numPages; i++) {
                    const page = await pdfDoc.getPage(i);
                    const textContent = await page.getTextContent();
                    const pageText = textContent.items.map(item => item.str).join(' ');
                    fullText += pageText + '\n';
                }
                
                return fullText;
            }
            
            async extractDOCXText(file) {
                const arrayBuffer = await file.arrayBuffer();
                const result = await mammoth.extractRawText({ arrayBuffer });
                return result.value;
            }
            
            async extractExcelText(file) {
                const arrayBuffer = await file.arrayBuffer();
                const data = new Uint8Array(arrayBuffer);
                const workbook = XLSX.read(data, { type: 'array' });
                let text = '';
                
                workbook.SheetNames.forEach(sheetName => {
                    const sheet = workbook.Sheets[sheetName];
                    const csv = XLSX.utils.sheet_to_csv(sheet);
                    text += `Sheet: ${sheetName}\n${csv}\n\n`;
                });
                
                return text;
            }
            
            async extractEPUBText(file) {
                // EPUB is a ZIP containing HTML/XHTML
                const arrayBuffer = await file.arrayBuffer();
                const zip = await JSZip.loadAsync(arrayBuffer);
                let text = '';
                
                // Find content files (usually in OEBPS or content folder)
                for (const [path, zipEntry] of Object.entries(zip.files)) {
                    if (path.match(/\.(html|xhtml|xml)$/i) && !zipEntry.dir) {
                        const content = await zipEntry.async('text');
                        // Strip HTML tags
                        const stripped = content.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ');
                        text += stripped + '\n';
                    }
                }
                
                return text || 'Unable to extract EPUB text';
            }
            
            async extractHTMLText(file) {
                const content = await file.text();
                // Create temporary div to parse HTML
                const div = document.createElement('div');
                div.innerHTML = content;
                return div.textContent || div.innerText || '';
            }
            
            async extractCSVText(file) {
                const content = await file.text();
                const parsed = Papa.parse(content);
                return parsed.data.map(row => row.join(' | ')).join('\n');
            }
            
            async extractJSONText(file) {
                const content = await file.text();
                const json = JSON.parse(content);
                return JSON.stringify(json, null, 2);
            }
            
            async extractXMLText(file) {
                const content = await file.text();
                // Strip XML tags for simple text extraction
                return content.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ');
            }
            
            async extractYAMLText(file) {
                const content = await file.text();
                try {
                    const data = jsyaml.load(content);
                    return JSON.stringify(data, null, 2);
                } catch (error) {
                    return content; // Return raw if parsing fails
                }
            }
            
            async extractImageTextOCR(file) {
                // Check cache first
                if (STATE.ocrCache) {
                    const fileHash = await STATE.ocrCache.hashFile(file);
                    const cached = await STATE.ocrCache.get(fileHash);
                    if (cached) {
                        return cached.result.text;
                    }
                }
                
                // Perform OCR
                const { data: { text } } = await Tesseract.recognize(
                    file,
                    'fra+eng',
                    {
                        logger: () => {} // Silent for batch
                    }
                );
                
                // Cache result
                if (STATE.ocrCache) {
                    const fileHash = await STATE.ocrCache.hashFile(file);
                    await STATE.ocrCache.set(fileHash, { text, confidence: 0.9, method: 'batch_ocr' });
                }
                
                return text;
            }
        }

        // ══════════════════════════════════════════════════════════════
        // EXPORT MANAGER
        // ══════════════════════════════════════════════════════════════
        
        class ExportManager {
            constructor() {
                this.formats = ['markdown', 'pdf', 'excel', 'jsonld', 'yaml', 'obsidian', 'notion', 'anki'];
                this.options = {
                    includeMetadata: true,
                    analysisFormat: 'complete',
                    includeRawText: true
                };
            }
            
            updateOptions() {
                this.options.includeMetadata = document.getElementById('exportIncludeMetadata')?.checked || true;
                this.options.analysisFormat = document.getElementById('exportAnalysisFormat')?.value || 'complete';
                this.options.includeRawText = document.getElementById('exportIncludeRawText')?.checked || true;
            }
            
            // ═══ MARKDOWN EXPORT ═══
            async exportMarkdown() {
                this.updateOptions();
                
                let markdown = `# ${STATE.fileName}\n\n`;
                
                // Metadata
                if (this.options.includeMetadata) {
                    markdown += `## Métadonnées\n\n`;
                    markdown += `- **Fichier**: ${STATE.fileName}\n`;
                    markdown += `- **Pages**: ${STATE.totalPages}\n`;
                    markdown += `- **Format**: ${STATE.fileType.toUpperCase()}\n`;
                    markdown += `- **Date**: ${new Date().toLocaleDateString('fr-FR')}\n`;
                    markdown += `- **Taille**: ${(STATE.fileSize / 1024 / 1024).toFixed(2)} MB\n\n`;
                }
                
                // Analysis
                if (this.options.analysisFormat !== 'none' && STATE.analysis) {
                    markdown += `## Analyse\n\n`;
                    
                    if (STATE.analysis.technical) {
                        markdown += `### Technique\n\n`;
                        markdown += `- **Format**: ${STATE.analysis.technical.format}\n`;
                        markdown += `- **Qualité**: ${STATE.analysis.technical.quality || 'N/A'}\n`;
                        markdown += `- **OCR requis**: ${STATE.analysis.technical.ocr_required ? 'Oui' : 'Non'}\n\n`;
                    }
                    
                    if (STATE.analysis.composition) {
                        markdown += `### Composition\n\n`;
                        markdown += `- **Type primaire**: ${STATE.analysis.composition.primary}\n`;
                        if (STATE.analysis.composition.secondary?.length > 0) {
                            markdown += `- **Types secondaires**: ${STATE.analysis.composition.secondary.join(', ')}\n`;
                        }
                        markdown += `\n`;
                    }
                }
                
                // Content
                if (this.options.includeRawText && STATE.extractedText) {
                    markdown += `## Contenu Extrait\n\n`;
                    markdown += `\`\`\`\n${STATE.extractedText.substring(0, 5000)}\n\`\`\`\n\n`;
                    if (STATE.extractedText.length > 5000) {
                        markdown += `*... (${STATE.extractedText.length - 5000} caractères supplémentaires)*\n\n`;
                    }
                }
                
                // Parts/Sections
                if (STATE.parts && STATE.parts.length > 0) {
                    markdown += `## Parties\n\n`;
                    STATE.parts.forEach((part, index) => {
                        markdown += `### Partie ${index + 1} (Pages ${part.startPage}-${part.endPage})\n\n`;
                        if (part.json) {
                            markdown += `- **Statut**: ${part.status}\n`;
                            markdown += `- **Modules**: ${Object.keys(part.json).length}\n\n`;
                        }
                    });
                }
                
                markdown += `---\n\n*Généré avec OCR Universel V6.0 ULTIMATE - API Multi-LLM*\n`;
                
                return markdown;
            }
            
            // ═══ YAML EXPORT ═══
            async exportYAML() {
                this.updateOptions();
                
                const data = {
                    metadata: {
                        fileName: STATE.fileName,
                        totalPages: STATE.totalPages,
                        fileType: STATE.fileType,
                        fileSize: STATE.fileSize,
                        exportDate: new Date().toISOString(),
                        generator: 'OCR Universel V6.0 ULTIMATE - API Multi-LLM'
                    }
                };
                
                if (this.options.analysisFormat !== 'none' && STATE.analysis) {
                    data.analysis = {
                        technical: STATE.analysis.technical || {},
                        composition: STATE.analysis.composition || {},
                        content: STATE.analysis.content || {}
                    };
                }
                
                if (this.options.includeRawText && STATE.extractedText) {
                    data.content = {
                        text: STATE.extractedText,
                        wordCount: STATE.extractedText.split(/\s+/).length,
                        characterCount: STATE.extractedText.length
                    };
                }
                
                if (STATE.parts && STATE.parts.length > 0) {
                    data.parts = STATE.parts.map((part, index) => ({
                        partNumber: index + 1,
                        startPage: part.startPage,
                        endPage: part.endPage,
                        status: part.status,
                        hasJSON: !!part.json
                    }));
                }
                
                return jsyaml.dump(data, { indent: 2, lineWidth: 120 });
            }
            
            // ═══ JSON-LD EXPORT (Knowledge Graph) ═══
            async exportJSONLD() {
                this.updateOptions();
                
                const jsonld = {
                    "@context": "https://schema.org",
                    "@type": "DigitalDocument",
                    "name": STATE.fileName,
                    "encodingFormat": STATE.fileType,
                    "contentSize": `${(STATE.fileSize / 1024 / 1024).toFixed(2)} MB`,
                    "dateCreated": new Date().toISOString(),
                    "creator": {
                        "@type": "SoftwareApplication",
                        "name": "OCR Universel V6.0 ULTIMATE - API Multi-LLM",
                        "applicationCategory": "OCR Software",
                        "operatingSystem": "Web Browser"
                    }
                };
                
                if (STATE.analysis) {
                    jsonld.about = {
                        "@type": "Thing",
                        "name": STATE.analysis.composition?.primary || "Document",
                        "description": `Type: ${STATE.analysis.technical?.format || 'unknown'}`
                    };
                }
                
                if (STATE.extractedText && this.options.includeRawText) {
                    jsonld.text = STATE.extractedText.substring(0, 1000);
                    jsonld.wordCount = STATE.extractedText.split(/\s+/).length;
                }
                
                if (STATE.parts && STATE.parts.length > 0) {
                    jsonld.hasPart = STATE.parts.map((part, index) => ({
                        "@type": "Chapter",
                        "position": index + 1,
                        "pageStart": part.startPage,
                        "pageEnd": part.endPage
                    }));
                }
                
                return JSON.stringify(jsonld, null, 2);
            }
            
            // ═══ EXCEL EXPORT ═══
            async exportExcel() {
                this.updateOptions();
                
                const workbook = XLSX.utils.book_new();
                
                // Sheet 1: Metadata
                const metadataData = [
                    ['Propriété', 'Valeur'],
                    ['Nom du fichier', STATE.fileName],
                    ['Pages totales', STATE.totalPages],
                    ['Type de fichier', STATE.fileType],
                    ['Taille', `${(STATE.fileSize / 1024 / 1024).toFixed(2)} MB`],
                    ['Date export', new Date().toLocaleDateString('fr-FR')]
                ];
                
                if (STATE.analysis) {
                    metadataData.push(['Format technique', STATE.analysis.technical?.format || 'N/A']);
                    metadataData.push(['Type primaire', STATE.analysis.composition?.primary || 'N/A']);
                }
                
                const ws1 = XLSX.utils.aoa_to_sheet(metadataData);
                XLSX.utils.book_append_sheet(workbook, ws1, 'Métadonnées');
                
                // Sheet 2: Analysis
                if (STATE.analysis && this.options.analysisFormat !== 'none') {
                    const analysisData = [['Catégorie', 'Propriété', 'Valeur']];
                    
                    if (STATE.analysis.technical) {
                        Object.entries(STATE.analysis.technical).forEach(([key, value]) => {
                            analysisData.push(['Technique', key, String(value)]);
                        });
                    }
                    
                    if (STATE.analysis.composition) {
                        Object.entries(STATE.analysis.composition).forEach(([key, value]) => {
                            analysisData.push(['Composition', key, JSON.stringify(value)]);
                        });
                    }
                    
                    const ws2 = XLSX.utils.aoa_to_sheet(analysisData);
                    XLSX.utils.book_append_sheet(workbook, ws2, 'Analyse');
                }
                
                // Sheet 3: Parts
                if (STATE.parts && STATE.parts.length > 0) {
                    const partsData = [['Partie', 'Page début', 'Page fin', 'Statut']];
                    STATE.parts.forEach((part, index) => {
                        partsData.push([index + 1, part.startPage, part.endPage, part.status]);
                    });
                    
                    const ws3 = XLSX.utils.aoa_to_sheet(partsData);
                    XLSX.utils.book_append_sheet(workbook, ws3, 'Parties');
                }
                
                return XLSX.write(workbook, { type: 'binary', bookType: 'xlsx' });
            }
            
            // ═══ OBSIDIAN VAULT EXPORT ═══
            async exportObsidian() {
                this.updateOptions();
                
                const vaultName = STATE.fileName.replace(/\.[^/.]+$/, '');
                const zip = new JSZip();
                const folder = zip.folder(vaultName);
                
                // Main note
                let mainNote = `# ${STATE.fileName}\n\n`;
                mainNote += `[[Metadata]] | [[Analysis]] | [[Content]]\n\n`;
                mainNote += `## Vue d'ensemble\n\n`;
                mainNote += `Ce document a été traité avec OCR Universel V6.0.\n\n`;
                
                if (STATE.analysis) {
                    mainNote += `**Type**: #${STATE.analysis.composition?.primary || 'document'}\n`;
                    mainNote += `**Format**: ${STATE.analysis.technical?.format || 'unknown'}\n\n`;
                }
                
                folder.file(`${vaultName}.md`, mainNote);
                
                // Metadata note
                let metadataNote = `# Metadata\n\n`;
                metadataNote += `[[${vaultName}|← Retour]]\n\n`;
                metadataNote += `- Fichier: ${STATE.fileName}\n`;
                metadataNote += `- Pages: ${STATE.totalPages}\n`;
                metadataNote += `- Taille: ${(STATE.fileSize / 1024 / 1024).toFixed(2)} MB\n`;
                folder.file('Metadata.md', metadataNote);
                
                // Analysis note
                if (STATE.analysis) {
                    let analysisNote = `# Analysis\n\n`;
                    analysisNote += `[[${vaultName}|← Retour]]\n\n`;
                    analysisNote += `## Technique\n\n`;
                    analysisNote += `\`\`\`json\n${JSON.stringify(STATE.analysis.technical, null, 2)}\n\`\`\`\n\n`;
                    folder.file('Analysis.md', analysisNote);
                }
                
                // Content note
                if (STATE.extractedText && this.options.includeRawText) {
                    let contentNote = `# Content\n\n`;
                    contentNote += `[[${vaultName}|← Retour]]\n\n`;
                    contentNote += STATE.extractedText;
                    folder.file('Content.md', contentNote);
                }
                
                return await zip.generateAsync({ type: 'blob' });
            }
            
            // ═══ NOTION CSV EXPORT ═══
            async exportNotion() {
                this.updateOptions();
                
                const rows = [
                    ['Nom', 'Type', 'Pages', 'Taille', 'Format technique', 'Type primaire', 'Date']
                ];
                
                rows.push([
                    STATE.fileName,
                    STATE.fileType,
                    STATE.totalPages,
                    `${(STATE.fileSize / 1024 / 1024).toFixed(2)} MB`,
                    STATE.analysis?.technical?.format || 'N/A',
                    STATE.analysis?.composition?.primary || 'N/A',
                    new Date().toLocaleDateString('fr-FR')
                ]);
                
                return Papa.unparse(rows);
            }
            
            // ═══ ANKI FLASHCARDS EXPORT ═══
            async exportAnki() {
                this.updateOptions();
                
                let ankiText = '';
                
                // Main card
                ankiText += `Document: ${STATE.fileName}\t`;
                ankiText += `Type: ${STATE.analysis?.composition?.primary || 'Document'}, `;
                ankiText += `${STATE.totalPages} pages, `;
                ankiText += `Format: ${STATE.analysis?.technical?.format || 'unknown'}\n`;
                
                // Analysis cards
                if (STATE.analysis && this.options.analysisFormat !== 'none') {
                    if (STATE.analysis.technical) {
                        ankiText += `Format technique de ${STATE.fileName}\t${STATE.analysis.technical.format}\n`;
                        ankiText += `Qualité OCR de ${STATE.fileName}\t${STATE.analysis.technical.quality || 'N/A'}\n`;
                    }
                    
                    if (STATE.analysis.composition) {
                        ankiText += `Type primaire de ${STATE.fileName}\t${STATE.analysis.composition.primary}\n`;
                        if (STATE.analysis.composition.weights) {
                            Object.entries(STATE.analysis.composition.weights).forEach(([type, weight]) => {
                                ankiText += `Poids ${type} dans ${STATE.fileName}\t${Math.round(weight * 100)}%\n`;
                            });
                        }
                    }
                }
                
                // Parts cards
                if (STATE.parts && STATE.parts.length > 1) {
                    STATE.parts.forEach((part, index) => {
                        ankiText += `Partie ${index + 1} de ${STATE.fileName}\tPages ${part.startPage}-${part.endPage}\n`;
                    });
                }
                
                return ankiText;
            }
            
            // ═══ PDF REPORT EXPORT (using jsPDF via HTML) ═══
            async exportPDF() {
                // Note: This is a simplified version
                // In production, you'd use jsPDF library
                showStatus('Export PDF: Utilisez le bouton "Imprimer" du navigateur et "Enregistrer en PDF"', 'info');
                
                // Evaluate all variables first
                const fileName = STATE.fileName || 'Document';
                const totalPages = STATE.totalPages || 0;
                const fileType = STATE.fileType ? STATE.fileType.toUpperCase() : 'N/A';
                const fileSize = STATE.file ? (STATE.fileSize / 1024 / 1024).toFixed(2) : '0';
                const currentDate = new Date().toLocaleDateString('fr-FR');
                
                const printWindow = window.open('', '_blank');
                let html = '<!DOCTYPE html><html><head>';
                html += '<title>' + fileName + ' - Report</title>';
                html += '<style>';
                html += 'body { font-family: Arial, sans-serif; padding: 40px; line-height: 1.6; }';
                html += 'h1 { color: #8FAFB1; border-bottom: 3px solid #C8D0C3; padding-bottom: 10px; }';
                html += 'h2 { color: #8FAFB1; margin-top: 30px; }';
                html += '.metadata { background: #E6D7C3; padding: 20px; border-radius: 8px; margin: 20px 0; }';
                html += '.metadata p { margin: 5px 0; }';
                html += 'table { width: 100%; border-collapse: collapse; margin: 20px 0; }';
                html += 'th, td { border: 1px solid #ddd; padding: 12px; text-align: left; }';
                html += 'th { background: #8FAFB1; color: white; }';
                html += '.footer { text-align: center; margin-top: 50px; color: #666; font-size: 12px; }';
                html += '</style></head><body>';
                html += '<h1>' + fileName + '</h1>';
                html += '<div class="metadata"><h2>Métadonnées</h2>';
                html += '<p><strong>Fichier:</strong> ' + fileName + '</p>';
                html += '<p><strong>Pages:</strong> ' + totalPages + '</p>';
                html += '<p><strong>Type:</strong> ' + fileType + '</p>';
                html += '<p><strong>Taille:</strong> ' + fileSize + ' MB</p>';
                html += '<p><strong>Date:</strong> ' + currentDate + '</p>';
                html += '</div>';
                
                if (STATE.analysis) {
                    const techFormat = STATE.analysis.technical?.format || 'N/A';
                    const techQuality = STATE.analysis.technical?.quality || 'N/A';
                    const compPrimary = STATE.analysis.composition?.primary || 'N/A';
                    
                    html += '<h2>Analyse</h2>';
                    html += '<table>';
                    html += '<tr><th>Propriété</th><th>Valeur</th></tr>';
                    html += '<tr><td>Format technique</td><td>' + techFormat + '</td></tr>';
                    html += '<tr><td>Qualité</td><td>' + techQuality + '</td></tr>';
                    html += '<tr><td>Type primaire</td><td>' + compPrimary + '</td></tr>';
                    html += '</table>';
                }
                
                html += '<div class="footer">';
                html += 'Généré avec OCR Universel V6.0 ULTIMATE - API Multi-LLM - ' + currentDate;
                html += '</div></body></html>';
                
                printWindow.document.write(html);
                printWindow.document.close();
                
                return null; // User handles print/save
            }
        }

        // ══════════════════════════════════════════════════════════════
        // INITIALIZATION
        // ══════════════════════════════════════════════════════════════
        
        (async () => {
            STATE.ocrCache = await initOCRCache();
            STATE.ocrWorkerPool = new OCRWorkerPool();
            STATE.batchController = new BatchController();
            STATE.exportManager = new ExportManager();
        })();

        // ══════════════════════════════════════════════════════════════
        // TEMPLATES
        // ══════════════════════════════════════════════════════════════
        
        const TEMPLATES = {
            realbook_jazz: {
                name: 'Real Book Jazz',
                analysis: {
                    technical: { format: 'scanned', quality: 'medium', ocr_required: true },
                    content: {
                        detected: [
                            { type: 'partition_musicale', score: 85, confidence: 0.85 },
                            { type: 'texte_pedagogique', score: 35, confidence: 0.35 }
                        ],
                        selected: ['partition_musicale', 'texte_pedagogique']
                    },
                    composition: {
                        primary: 'partition_musicale',
                        secondary: ['texte_pedagogique'],
                        weights: { partition_musicale: 0.70, texte_pedagogique: 0.30 },
                        auto_weights: { partition_musicale: 0.70, texte_pedagogique: 0.30 }
                    }
                },
                format: 32,
                platform: 'chatgpt',
                model: 'gpt-4o'
            },
            
            sade_songbook: {
                name: 'Sade Songbook',
                analysis: {
                    technical: { format: 'digital', quality: 'high', ocr_required: false },
                    content: {
                        detected: [{ type: 'partition_musicale', score: 100, confidence: 1.0 }],
                        selected: ['partition_musicale']
                    },
                    composition: {
                        primary: 'partition_musicale',
                        secondary: [],
                        weights: { partition_musicale: 1.0 },
                        auto_weights: { partition_musicale: 1.0 }
                    }
                },
                format: 32,
                platform: 'chatgpt',
                model: 'gpt-4o'
            },
            
            therapy_doc: {
                name: 'Document Thérapie',
                analysis: {
                    technical: { format: 'digital', quality: 'high', ocr_required: false },
                    content: {
                        detected: [
                            { type: 'document_therapie', score: 80, confidence: 0.80 },
                            { type: 'questionnaire_psy', score: 20, confidence: 0.20 }
                        ],
                        selected: ['document_therapie', 'questionnaire_psy']
                    },
                    composition: {
                        primary: 'document_therapie',
                        secondary: ['questionnaire_psy'],
                        weights: { document_therapie: 0.80, questionnaire_psy: 0.20 },
                        auto_weights: { document_therapie: 0.80, questionnaire_psy: 0.20 }
                    }
                },
                format: 32,
                platform: 'claude',
                model: 'claude-sonnet-4-20250514'
            },
            
            scientific_paper: {
                name: 'Paper Scientifique',
                analysis: {
                    technical: { format: 'digital', quality: 'high', ocr_required: false },
                    content: {
                        detected: [{ type: 'paper_scientifique', score: 100, confidence: 1.0 }],
                        selected: ['paper_scientifique']
                    },
                    composition: {
                        primary: 'paper_scientifique',
                        secondary: [],
                        weights: { paper_scientifique: 1.0 },
                        auto_weights: { paper_scientifique: 1.0 }
                    }
                },
                format: 32,
                platform: 'chatgpt',
                model: 'gpt-4o'
            }
        };
        
        function loadTemplate(templateId) {
            const template = TEMPLATES[templateId];
            if (!template) return;
            
            showStatus(`Template "${template.name}" chargé !`, 'success');
            
            STATE.format = template.format;
            STATE.platform = template.platform;
            STATE.gptModel = template.model;
            STATE.analysis = template.analysis;
            
            document.getElementById('dropZone').scrollIntoView({ behavior: 'smooth' });
        }

        // ══════════════════════════════════════════════════════════════
        // DRAG & DROP
        // ══════════════════════════════════════════════════════════════
        
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        
        dropZone.addEventListener('click', () => fileInput.click());
        
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        });
        
        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('drag-over');
        });
        
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]).then(() => {
                    // ✅ SCROLL vers section traitement après upload
                    scrollToProcessingSection();
                });
            }
        });
        
        fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                await handleFile(file);
                // ✅ SCROLL vers section traitement après upload
                scrollToProcessingSection();
            }
        });

        // ══════════════════════════════════════════════════════════════
        // STATUS & PROGRESS
        // ══════════════════════════════════════════════════════════════
        
        function showStatus(message, type = 'info') {
            const statusEl = document.getElementById('statusMessage');
            statusEl.textContent = message;
            statusEl.className = 'status-message status-' + type;
            statusEl.style.display = 'block';
            
            setTimeout(() => {
                statusEl.style.display = 'none';
            }, 5000);
        }
        
        function updateProgress(percent, stage, text) {
            const progressBar = document.getElementById('progressBar');
            const progressStage = document.getElementById('progressStage');
            const progressText = document.getElementById('progressText');
            const progressContainer = document.getElementById('progressContainer');
            
            progressContainer.style.display = 'block';
            progressBar.style.width = percent + '%';
            progressBar.textContent = Math.round(percent) + '%';
            progressStage.textContent = stage;
            progressText.textContent = text;
        }

        // ══════════════════════════════════════════════════════════════
        // BATCH FUNCTIONS
        // ══════════════════════════════════════════════════════════════
        
        // Setup batch file input and drag & drop listeners
        document.addEventListener('DOMContentLoaded', () => {
            const batchInput = document.getElementById('batchFileInput');
            const batchUploadZone = document.querySelector('.batch-upload');
            
            // File input change listener
            if (batchInput) {
                batchInput.addEventListener('change', (e) => {
                    const files = Array.from(e.target.files);
                    addFilesToBatch(files);
                    e.target.value = ''; // Reset input
                });
            }
            
            // Drag & Drop listeners
            if (batchUploadZone) {
                batchUploadZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    batchUploadZone.style.borderColor = 'var(--mer)';
                    batchUploadZone.style.backgroundColor = 'var(--vert-sauge)';
                });
                
                batchUploadZone.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    batchUploadZone.style.borderColor = '';
                    batchUploadZone.style.backgroundColor = '';
                });
                
                batchUploadZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    batchUploadZone.style.borderColor = '';
                    batchUploadZone.style.backgroundColor = '';
                    
                    const files = Array.from(e.dataTransfer.files);
                    if (files.length > 0) {
                        addFilesToBatch(files);
                    }
                });
            }
        });
        
        function addFilesToBatch(files) {
            if (!files || files.length === 0) return;
            
            files.forEach(file => {
                const fileId = crypto.randomUUID();
                const batchItem = {
                    id: fileId,
                    file: file,
                    status: 'queued',
                    progress: 0,
                    error: null,
                    result: null
                };
                
                STATE.batch.queue.push(batchItem);
                STATE.batch.stats.total++;
            });
            
            renderBatchQueue();
            updateBatchStats();
            updateBatchButtons();
            
            showStatus(`${files.length} fichier(s) ajouté(s) à la file batch`, 'success');
        }
        
        function renderBatchQueue() {
            const queueContainer = document.getElementById('batchQueue');
            
            if (STATE.batch.queue.length === 0) {
                queueContainer.innerHTML = `
                    <div class="batch-empty">
                        <div class="batch-empty-icon">📄</div>
                        <p>Aucun fichier dans la file batch</p>
                        <p style="font-size:0.9em;">Sélectionnez plusieurs fichiers pour commencer</p>
                    </div>
                `;
                return;
            }
            
            queueContainer.innerHTML = '';
            STATE.batch.queue.forEach((item, index) => {
                renderBatchItem(item, index);
            });
        }
        
        function renderBatchItem(item, index) {
            const queueContainer = document.getElementById('batchQueue');
            let card = document.querySelector(`[data-file-id="${item.id}"]`);
            
            if (!card) {
                card = document.createElement('div');
                card.className = 'batch-item';
                card.setAttribute('data-file-id', item.id);
                queueContainer.appendChild(card);
            }
            
            const fileSize = (item.file.size / 1024 / 1024).toFixed(2);
            
            card.innerHTML = `
                <div class="batch-item-header">
                    <span class="batch-file-name">${item.file.name} (${fileSize} MB)</span>
                    <span class="batch-file-status status-${item.status}">${getStatusLabel(item.status)}</span>
                    <button class="batch-remove-btn" onclick="removeBatchItem(${index})" ${item.status === 'processing' ? 'disabled' : ''}>×</button>
                </div>
                <div class="batch-progress-bar">
                    <div class="batch-progress-fill" style="width: ${item.progress}%"></div>
                </div>
                <div class="batch-progress-message">${item.status === 'processing' ? 'Traitement en cours...' : ''}</div>
                ${item.error ? `<div class="batch-error-message">${item.error}</div>` : ''}
            `;
        }
        
        function getStatusLabel(status) {
            const labels = {
                queued: 'En attente',
                processing: 'En cours',
                completed: 'Terminé',
                error: 'Erreur'
            };
            return labels[status] || status;
        }
        
        function removeBatchItem(index) {
            const item = STATE.batch.queue[index];
            if (!item) return;
            
            if (item.status === 'processing') {
                showStatus('Impossible de supprimer un fichier en cours de traitement', 'warning');
                return;
            }
            
            STATE.batch.queue.splice(index, 1);
            STATE.batch.stats.total--;
            
            if (item.status === 'completed') STATE.batch.stats.completed--;
            if (item.status === 'error') STATE.batch.stats.errors--;
            
            renderBatchQueue();
            updateBatchStats();
            updateBatchButtons();
        }
        
        function clearBatch() {
            if (STATE.batch.status === 'running') {
                showStatus('Impossible d\'effacer pendant le traitement. Mettez en pause d\'abord.', 'warning');
                return;
            }
            
            if (!confirm(`Effacer tous les ${STATE.batch.queue.length} fichiers ?`)) return;
            
            STATE.batch.queue = [];
            STATE.batch.currentIndex = 0;
            STATE.batch.stats = {
                total: 0,
                completed: 0,
                errors: 0,
                skipped: 0
            };
            
            if (STATE.batchController) {
                STATE.batchController.progressTracker.clear();
                STATE.batchController.errorHandler.clearErrors();
            }
            
            renderBatchQueue();
            updateBatchStats();
            updateBatchButtons();
            
            showStatus('File batch effacée', 'info');
        }
        
        async function startBatch() {
            if (!STATE.batchController) {
                showStatus('Batch controller non initialisé', 'error');
                return;
            }
            
            await STATE.batchController.startBatch();
        }
        
        function pauseBatch() {
            if (!STATE.batchController) return;
            STATE.batchController.pauseBatch();
        }
        
        async function resumeBatch() {
            if (!STATE.batchController) return;
            await STATE.batchController.resumeBatch();
        }
        
        function updateBatchStats() {
            document.getElementById('batchStatTotal').textContent = STATE.batch.stats.total;
            document.getElementById('batchStatCompleted').textContent = STATE.batch.stats.completed;
            document.getElementById('batchStatErrors').textContent = STATE.batch.stats.errors;
            
            if (STATE.batch.startTime) {
                const elapsed = Math.floor((Date.now() - STATE.batch.startTime) / 1000);
                document.getElementById('batchStatTime').textContent = `${elapsed}s`;
            }
        }
        
        function updateBatchButtons() {
            const startBtn = document.getElementById('batchStartBtn');
            const pauseBtn = document.getElementById('batchPauseBtn');
            const resumeBtn = document.getElementById('batchResumeBtn');
            const exportBtn = document.getElementById('batchExportBtn');
            const promptBtn = document.getElementById('batchPromptBtn');
            
            const hasFiles = STATE.batch.queue.length > 0;
            const isRunning = STATE.batch.status === 'running';
            const isPaused = STATE.batch.status === 'paused';
            const hasCompleted = STATE.batch.stats.completed > 0;
            
            startBtn.disabled = !hasFiles || isRunning || isPaused;
            pauseBtn.disabled = !isRunning;
            resumeBtn.disabled = !isPaused;
            exportBtn.disabled = !hasCompleted;
            promptBtn.disabled = !hasCompleted;
        }
        
        function updateBatchConfig() {
            STATE.batch.config.maxConcurrent = parseInt(document.getElementById('batchMaxConcurrent').value) || 3;
            STATE.batch.config.retryAttempts = parseInt(document.getElementById('batchRetryAttempts').value) || 2;
            STATE.batch.config.continueOnError = document.getElementById('batchContinueOnError').checked;
            STATE.batch.config.mergeStrategy = document.getElementById('batchMergeStrategy').value;
            
            if (STATE.batchController) {
                STATE.batchController.errorHandler = new BatchErrorHandler(STATE.batch.config);
            }
        }
        
        function applyBatchTemplate(templateName) {
            const templates = {
                books_documents: {
                    name: '📚 Livres & Documents',
                    config: {
                        maxConcurrent: 2,
                        retryAttempts: 2,
                        continueOnError: true,
                        mergeStrategy: 'by_type'
                    },
                    settings: {
                        platform: 'chatgpt',
                        model: 'gpt-4o',
                        format: 32
                    }
                },
                media_collection: {
                    name: '🎨 Collection Média',
                    config: {
                        maxConcurrent: 3,
                        retryAttempts: 2,
                        continueOnError: true,
                        mergeStrategy: 'chronological'
                    },
                    settings: {
                        platform: 'chatgpt',
                        model: 'gpt-4o',
                        format: 32
                    }
                },
                academic_research: {
                    name: '🔬 Académique & Recherche',
                    config: {
                        maxConcurrent: 3,
                        retryAttempts: 2,
                        continueOnError: true,
                        mergeStrategy: 'alphabetical'
                    },
                    settings: {
                        platform: 'claude',
                        model: 'claude-opus-4-20250514',
                        format: 32
                    }
                },
                business_docs: {
                    name: '💼 Documents Professionnels',
                    config: {
                        maxConcurrent: 4,
                        retryAttempts: 1,
                        continueOnError: true,
                        mergeStrategy: 'chronological'
                    },
                    settings: {
                        platform: 'claude',
                        model: 'claude-sonnet-4-20250514',
                        format: 32
                    }
                },
                custom: {
                    name: '⚙️ Configuration Personnalisée',
                    config: {
                        maxConcurrent: 3,
                        retryAttempts: 2,
                        continueOnError: true,
                        mergeStrategy: 'flat'
                    },
                    settings: {
                        platform: STATE.platform,
                        model: STATE.platform === 'chatgpt' ? STATE.gptModel : STATE.claudeModel,
                        format: STATE.format
                    }
                }
            };
            
            const template = templates[templateName];
            if (!template) return;
            
            // Apply config
            Object.assign(STATE.batch.config, template.config);
            
            // Update UI
            document.getElementById('batchMaxConcurrent').value = template.config.maxConcurrent;
            document.getElementById('batchRetryAttempts').value = template.config.retryAttempts;
            document.getElementById('batchContinueOnError').checked = template.config.continueOnError;
            document.getElementById('batchMergeStrategy').value = template.config.mergeStrategy;
            
            // Apply settings to global STATE
            STATE.platform = template.settings.platform;
            STATE.format = template.settings.format;
            
            if (STATE.platform === 'chatgpt') {
                STATE.gptModel = template.settings.model;
            } else {
                STATE.claudeModel = template.settings.model;
            }
            
            updateBatchConfig();
            showStatus(`Template "${template.name}" appliqué`, 'success');
        }
        
        async function exportPartialBatch() {
            const completedItems = STATE.batch.queue.filter(item => item.status === 'completed');
            
            if (completedItems.length === 0) {
                showStatus('Aucun fichier complété à exporter', 'warning');
                return;
            }
            
            showStatus(`Export de ${completedItems.length} fichier(s) complété(s)...`, 'info');
            
            try {
                const zip = new JSZip();
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                const batchFolder = zip.folder(`batch_partial_${timestamp}`);
                
                // Add completed results
                completedItems.forEach((item, index) => {
                    if (item.result) {
                        const fileName = item.file.name.replace(/\.[^/.]+$/, '');
                        batchFolder.file(`${index + 1}_${fileName}.json`, JSON.stringify(item.result, null, 2));
                    }
                });
                
                // Add batch report
                const report = {
                    export_date: new Date().toISOString(),
                    total_files: STATE.batch.stats.total,
                    completed: STATE.batch.stats.completed,
                    errors: STATE.batch.stats.errors,
                    merge_strategy: STATE.batch.config.mergeStrategy,
                    files: completedItems.map(item => ({
                        name: item.file.name,
                        size: item.file.size,
                        status: item.status
                    }))
                };
                
                batchFolder.file('batch_report.json', JSON.stringify(report, null, 2));
                
                // Generate and download
                const blob = await zip.generateAsync({ type: 'blob' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `batch_partial_${timestamp}.zip`;
                a.click();
                URL.revokeObjectURL(url);
                
                showStatus('Export partiel téléchargé avec succès !', 'success');
                
            } catch (error) {
                console.error('Export error:', error);
                showStatus('Erreur lors de l\'export : ' + error.message, 'error');
            }
        }

        // ══════════════════════════════════════════════════════════════
        // EXPORT FUNCTIONS
        // ══════════════════════════════════════════════════════════════
        
        // ════════════════════════════════════════════════════════════
        // V6.3.0 - TOGGLE EXPORTS AVANCÉS
        // ════════════════════════════════════════════════════════════
        
        function toggleAdvancedExports() {
            const section = document.getElementById('advancedExportsSection');
            const toggleText = document.getElementById('toggleAdvancedText');
            
            if (section.classList.contains('visible')) {
                section.classList.remove('visible');
                toggleText.textContent = '▼ Afficher (5 formats)';
            } else {
                section.classList.add('visible');
                toggleText.textContent = '▲ Masquer';
            }
        }
        
        // ════════════════════════════════════════════════════════════
        
        async function exportFormat(format) {
            if (!STATE.exportManager) {
                showStatus('Export Manager non initialisé', 'error');
                return;
            }
            
            if (!STATE.file) {
                showStatus('Aucun fichier chargé pour l\'export', 'warning');
                return;
            }
            
            showStatus(`Export ${format} en cours...`, 'info');
            
            try {
                let content, filename, mimeType, extension;
                
                switch (format) {
                    case 'markdown':
                        content = await STATE.exportManager.exportMarkdown();
                        filename = STATE.fileName.replace(/\.[^/.]+$/, '.md');
                        mimeType = 'text/markdown';
                        extension = 'md';
                        break;
                        
                    case 'yaml':
                        content = await STATE.exportManager.exportYAML();
                        filename = STATE.fileName.replace(/\.[^/.]+$/, '.yaml');
                        mimeType = 'text/yaml';
                        extension = 'yaml';
                        break;
                        
                    case 'jsonld':
                        content = await STATE.exportManager.exportJSONLD();
                        filename = STATE.fileName.replace(/\.[^/.]+$/, '.jsonld');
                        mimeType = 'application/ld+json';
                        extension = 'jsonld';
                        break;
                        
                    case 'excel':
                        const xlsxData = await STATE.exportManager.exportExcel();
                        const xlsxBlob = new Blob([s2ab(xlsxData)], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
                        downloadBlob(xlsxBlob, STATE.fileName.replace(/\.[^/.]+$/, '.xlsx'));
                        showStatus('Excel exporté avec succès !', 'success');
                        return;
                        
                    case 'obsidian':
                        const obsidianBlob = await STATE.exportManager.exportObsidian();
                        downloadBlob(obsidianBlob, STATE.fileName.replace(/\.[^/.]+$/, '_vault.zip'));
                        showStatus('Vault Obsidian exporté avec succès !', 'success');
                        return;
                        
                    case 'notion':
                        content = await STATE.exportManager.exportNotion();
                        filename = STATE.fileName.replace(/\.[^/.]+$/, '_notion.csv');
                        mimeType = 'text/csv';
                        extension = 'csv';
                        break;
                        
                    case 'anki':
                        content = await STATE.exportManager.exportAnki();
                        filename = STATE.fileName.replace(/\.[^/.]+$/, '_anki.txt');
                        mimeType = 'text/plain';
                        extension = 'txt';
                        break;
                        
                    case 'pdf':
                        await STATE.exportManager.exportPDF();
                        return; // PDF handled separately
                        
                    default:
                        showStatus(`Format ${format} non supporté`, 'error');
                        return;
                }
                
                // Download text-based formats
                const blob = new Blob([content], { type: mimeType });
                downloadBlob(blob, filename);
                
                // Show preview
                showExportPreview(content, format);
                
                showStatus(`${format.toUpperCase()} exporté avec succès !`, 'success');
                
            } catch (error) {
                console.error(`Export ${format} error:`, error);
                showStatus(`Erreur export ${format}: ${error.message}`, 'error');
            }
        }
        
        async function exportAllFormats() {
            if (!STATE.file) {
                showStatus('Aucun fichier chargé pour l\'export', 'warning');
                return;
            }
            
            showStatus('Export de tous les formats en cours...', 'info');
            
            try {
                const zip = new JSZip();
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                const baseName = STATE.fileName.replace(/\.[^/.]+$/, '');
                const exportFolder = zip.folder(`${baseName}_exports_${timestamp}`);
                
                // Markdown
                const markdown = await STATE.exportManager.exportMarkdown();
                exportFolder.file(`${baseName}.md`, markdown);
                
                // YAML
                const yaml = await STATE.exportManager.exportYAML();
                exportFolder.file(`${baseName}.yaml`, yaml);
                
                // JSON-LD
                const jsonld = await STATE.exportManager.exportJSONLD();
                exportFolder.file(`${baseName}.jsonld`, jsonld);
                
                // Excel
                const xlsxData = await STATE.exportManager.exportExcel();
                exportFolder.file(`${baseName}.xlsx`, s2ab(xlsxData), { binary: true });
                
                // Notion CSV
                const notionCsv = await STATE.exportManager.exportNotion();
                exportFolder.file(`${baseName}_notion.csv`, notionCsv);
                
                // Anki
                const ankiTxt = await STATE.exportManager.exportAnki();
                exportFolder.file(`${baseName}_anki.txt`, ankiTxt);
                
                // Obsidian vault
                const obsidianBlob = await STATE.exportManager.exportObsidian();
                const obsidianArrayBuffer = await obsidianBlob.arrayBuffer();
                exportFolder.file(`${baseName}_obsidian_vault.zip`, obsidianArrayBuffer);
                
                // Add README
                const readme = `# ${baseName} - Exports Multiples
                
Ce dossier contient ${baseName} exporté dans 7 formats différents :

1. **${baseName}.md** - Markdown formaté
2. **${baseName}.yaml** - Configuration YAML
3. **${baseName}.jsonld** - Knowledge graph (Schema.org)
4. **${baseName}.xlsx** - Feuille de calcul Excel
5. **${baseName}_notion.csv** - Import Notion
6. **${baseName}_anki.txt** - Flashcards Anki
7. **${baseName}_obsidian_vault.zip** - Vault Obsidian

Généré le ${new Date().toLocaleString('fr-FR')} avec OCR Universel V6.0 ULTIMATE - API Multi-LLM
`;
                exportFolder.file('README.txt', readme);
                
                // Generate and download ZIP
                const blob = await zip.generateAsync({ type: 'blob' });
                downloadBlob(blob, `${baseName}_all_exports_${timestamp}.zip`);
                
                showStatus('Tous les formats exportés avec succès !', 'success');
                
            } catch (error) {
                console.error('Export all error:', error);
                showStatus('Erreur lors de l\'export multiple: ' + error.message, 'error');
            }
        }
        
        function downloadBlob(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function s2ab(s) {
            const buf = new ArrayBuffer(s.length);
            const view = new Uint8Array(buf);
            for (let i = 0; i < s.length; i++) {
                view[i] = s.charCodeAt(i) & 0xFF;
            }
            return buf;
        }
        
        function showExportPreview(content, format) {
            const preview = document.getElementById('exportPreview');
            const previewContent = document.getElementById('exportPreviewContent');
            
            if (!preview || !previewContent) return;
            
            preview.style.display = 'block';
            
            // Truncate if too long
            const maxLength = 2000;
            let displayContent = content;
            if (content.length > maxLength) {
                displayContent = content.substring(0, maxLength) + '\n\n... (contenu tronqué)';
            }
            
            previewContent.textContent = displayContent;
            
            // Scroll to preview
            preview.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
        
        // Show export section after processing
        function showExportSection() {
            const exportSection = document.getElementById('exportSection');
            if (exportSection) {
                exportSection.style.display = 'block';
                exportSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }

        // ══════════════════════════════════════════════════════════════
        // FILE HANDLING
        // ══════════════════════════════════════════════════════════════
        
        // ════════════════════════════════════════════════════════════
        // V6.3.0 - DÉTECTION FICHIERS LOURDS
        // ════════════════════════════════════════════════════════════
        
        function checkIfHeavyFile(file) {
            const sizeMB = file.size / 1024 / 1024;
            const fileType = file.name.split('.').pop().toLowerCase();
            
            // Seuils par type de fichier
            const thresholds = {
                'pdf': 50,      // 50 MB pour PDFs
                'png': 20,      // 20 MB pour images (Tesseract lourd)
                'jpg': 20,
                'jpeg': 20,
                'tiff': 30,
                'default': 100  // 100 MB pour autres formats
            };
            
            const threshold = thresholds[fileType] || thresholds['default'];
            const isHeavy = sizeMB > threshold;
            
            let message = '';
            let recommendation = '';
            
            if (isHeavy) {
                if (fileType === 'pdf') {
                    message = `Document volumineux (${sizeMB.toFixed(1)} MB). Analyse complète peut prendre plusieurs minutes.`;
                    recommendation = 'Considérez une analyse par échantillonnage pour plus de rapidité.';
                } else if (['png', 'jpg', 'jpeg', 'tiff'].includes(fileType)) {
                    message = `Image volumineuse (${sizeMB.toFixed(1)} MB). OCR Tesseract peut être lent.`;
                    recommendation = 'Sur mobile ou connexion lente, préférez une résolution réduite.';
                } else {
                    message = `Fichier volumineux (${sizeMB.toFixed(1)} MB).`;
                    recommendation = 'Le traitement peut prendre du temps.';
                }
            }
            
            return {
                isHeavy,
                sizeMB,
                threshold,
                message,
                recommendation,
                fileType
            };
        }
        
        // ════════════════════════════════════════════════════════════
        
        async function handleFile(file) {
            STATE.file = file;
            STATE.fileName = file.name;
            STATE.fileSize = file.size;  // ✅ SAUVEGARDER LA TAILLE
            STATE.fileType = file.name.split('.').pop().toLowerCase();
            STATE.startTime = Date.now();
            
            showStatus(`Fichier chargé: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`, 'success');
            
            // ════════════════════════════════════════════════════════════
            // V6.3.0 - DÉTECTION FICHIER LOURD
            // ════════════════════════════════════════════════════════════
            const isHeavy = checkIfHeavyFile(file);
            if (isHeavy.isHeavy) {
                showStatus(`⚠️ ${isHeavy.message}`, 'warning');
                console.log('[PERF] Heavy file detected:', isHeavy);
            }
            // ════════════════════════════════════════════════════════════
            
            updateProgress(10, 'Analyse du fichier', 'Détection du format...');
            
            try {
                STATE.detectionResult = await detectDocumentType(file);
                STATE.documentType = STATE.detectionResult.type;
                
                // ✅ extractedText est maintenant géré dans detectDocumentType
                // Pour les PDFs, c'est fait dans detectDocumentMultiDimensional
                // Pour les autres formats, c'est fait dans detectDocumentMultiDimensionalFromText
                
                console.log('[DEBUG] handleFile - extractedText length:', STATE.extractedText?.length || 0);
                console.log('[DEBUG] handleFile - totalPages:', STATE.totalPages);
                
                displayDetectionResult(STATE.detectionResult);
                
                updateProgress(100, 'Analyse terminée', 'Prêt à traiter');
                
                document.getElementById('detectionSection').style.display = 'block';
                document.getElementById('apiQuickActions').style.display = 'block';  // ✅ AJOUTÉ
                document.getElementById('compositionSection').style.display = 'block';
                document.getElementById('configSection').style.display = 'block';
                
                // ✅ SCROLL AUTOMATIQUE après upload
                scrollAfterUpload();
                
            } catch (error) {
                console.error('Error handling file:', error);
                showStatus('Erreur lors de l\'analyse: ' + error.message, 'error');
            }
        }

        // ══════════════════════════════════════════════════════════════
        // FORMAT DETECTION & EXTRACTION (21 FORMATS)
        // ══════════════════════════════════════════════════════════════
        
        async function detectDocumentType(file) {
            const fileExt = file.name.split('.').pop().toLowerCase();
            
            updateProgress(20, 'Extraction du contenu', 'Format: ' + fileExt.toUpperCase());
            
            if (fileExt === 'pdf') {
                return await detectDocumentMultiDimensional(file);
            }
            
            if (['png', 'jpg', 'jpeg', 'gif', 'webp', 'tiff', 'tif'].includes(fileExt)) {
                const extracted = await extractTextFromImage(file);
                return await detectDocumentMultiDimensionalFromText(file, extracted.text, extracted);
            }
            
            if (['xlsx', 'xls', 'ods'].includes(fileExt)) {
                const extracted = await extractTextFromExcel(file);
                return await detectDocumentMultiDimensionalFromText(file, extracted.text, extracted);
            }
            
            if (['pptx', 'ppt', 'odp'].includes(fileExt)) {
                const extracted = await extractTextFromPPT(file);
                return await detectDocumentMultiDimensionalFromText(file, extracted.text, extracted);
            }
            
            if (['docx', 'doc', 'odt'].includes(fileExt)) {
                const extracted = await extractTextFromDOCX(file);
                return await detectDocumentMultiDimensionalFromText(file, extracted.text, extracted);
            }
            
            if (fileExt === 'epub') {
                const extracted = await extractTextFromEPUB(file);
                return await detectDocumentMultiDimensionalFromText(file, extracted.text, extracted);
            }
            
            if (fileExt === 'zip') {
                return await handleZipFile(file);
            }
            
            if (['cbz', 'cbr'].includes(fileExt)) {
                const extracted = await extractTextFromComics(file);
                return await detectDocumentMultiDimensionalFromText(file, extracted.text, extracted);
            }
            
            if (['csv', 'tsv'].includes(fileExt)) {
                const extracted = await extractTextFromCSV(file);
                return await detectDocumentMultiDimensionalFromText(file, extracted.text, extracted);
            }
            
            if (['json', 'xml'].includes(fileExt)) {
                const extracted = await extractTextFromStructured(file, fileExt);
                return await detectDocumentMultiDimensionalFromText(file, extracted.text, extracted);
            }
            
            if (['yaml', 'yml'].includes(fileExt)) {
                const extracted = await extractTextFromYAML(file);
                return await detectDocumentMultiDimensionalFromText(file, extracted.text, extracted);
            }
            
            if (fileExt === 'svg') {
                const extracted = await extractTextFromSVG(file);
                return await detectDocumentMultiDimensionalFromText(file, extracted.text, extracted);
            }
            
            if (fileExt === 'rtf') {
                const extracted = await extractTextFromRTF(file);
                return await detectDocumentMultiDimensionalFromText(file, extracted.text, extracted);
            }
            
            if (['mobi', 'azw', 'azw3'].includes(fileExt)) {
                const extracted = await extractTextFromMobi(file);
                return await detectDocumentMultiDimensionalFromText(file, extracted.text, extracted);
            }
            
            if (['html', 'htm', 'md', 'markdown', 'txt'].includes(fileExt)) {
                const extracted = await extractTextFromPlainFile(file);
                return await detectDocumentMultiDimensionalFromText(file, extracted.text, extracted);
            }
            
            throw new Error('Format non supporté: ' + fileExt);
        }
        
        // ══════════════════════════════════════════════════════════════
        // PDF EXTRACTION (FIX ENCRYPTION)
        // ══════════════════════════════════════════════════════════════
        
        async function detectDocumentMultiDimensional(file) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                const pdfDoc = await PDFLib.PDFDocument.load(arrayBuffer, {
                    ignoreEncryption: true
                });
                
                const numPages = pdfDoc.getPageCount();
                STATE.totalPages = numPages;
                STATE.pdfDocument = pdfDoc;
                
                const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
                
                // ✅ EXTRAIRE LE TEXTE DE TOUTES LES PAGES
                console.log('[DEBUG] Extracting text from all', numPages, 'pages...');
                let fullText = '';
                
                for (let pageNum = 1; pageNum <= numPages; pageNum++) {
                    try {
                        const page = await pdf.getPage(pageNum);
                        const textContent = await page.getTextContent();
                        const pageText = textContent.items.map(item => item.str).join(' ');
                        fullText += pageText + '\n';
                    } catch (pageError) {
                        console.error(`Error extracting page ${pageNum}:`, pageError);
                    }
                }
                
                // ✅ STOCKER LE TEXTE COMPLET
                STATE.extractedText = fullText;
                console.log('[DEBUG] Full text extracted, length:', fullText.length);
                console.log('[DEBUG] handleFile - extractedText length:', fullText.length);
                console.log('[DEBUG] handleFile - totalPages:', numPages);
                
                // ✅ SCROLL AUTOMATIQUE VERS SECTION TRAITEMENT
                scrollToProcessingSection();
                
                // Utiliser la première page pour la détection
                const page1 = await pdf.getPage(1);
                const textContent1 = await page1.getTextContent();
                const text = textContent1.items.map(item => item.str).join(' ').toLowerCase();
                const textLength = text.length;
                
                let metadata = {};
                try {
                    const title = pdfDoc.getTitle();
                    if (title) metadata.title = title;
                } catch (e) {}
                
                const technical = await detectTechnicalFormat(file, pdfDoc, numPages, textLength);
                const content = detectContentTypes(file.name, metadata, text);
                const composition = calculateComposition(content.detected);
                
                const analysis = {
                    technical,
                    content,
                    composition
                };
                
                STATE.analysis = analysis;
                STATE.documentType = composition.primary || 'text_standard';
                STATE.detectionResult = {
                    type: composition.primary,
                    confidence: content.detected[0]?.confidence || 0.7
                };
                
                return analysis;
                
            } catch (error) {
                console.error('Erreur détection PDF:', error);
                STATE.extractedText = '';
                return {
                    technical: { format: 'digital', quality: 'unknown', ocr_required: false, density: 0 },
                    content: { detected: [{ type: 'text_standard', score: 50, confidence: 0.5 }], selected: [], domains: [] },
                    composition: { primary: 'text_standard', secondary: [], weights: { text_standard: 1.0 }, auto_weights: { text_standard: 1.0 } }
                };
            }
        }
        
        // ══════════════════════════════════════════════════════════════
        // TECHNICAL FORMAT DETECTION
        // ══════════════════════════════════════════════════════════════
        
        async function detectTechnicalFormat(file, pdfDoc, numPages, textLength) {
            const densityMB = file.size / numPages / (1024 * 1024);
            const hasText = textLength > 100;
            
            let format = 'digital';
            let quality = 'high';
            let ocr_required = false;
            
            if (!hasText || densityMB > 0.5) {
                format = densityMB > 0.5 ? 'photo' : 'scanned';
                quality = 'medium';
                ocr_required = true;
            } else if (densityMB < 0.15 && hasText) {
                format = 'digital';
                quality = 'high';
                ocr_required = false;
            }
            
            return {
                format,
                quality,
                layout: hasText ? 'mixed' : 'image',
                density: densityMB,
                ocr_required,
                hybrid_details: null
            };
        }
        
        // ══════════════════════════════════════════════════════════════
        // CONTENT TYPE DETECTION
        // ══════════════════════════════════════════════════════════════
        
        function detectContentTypes(fileName, metadata, text) {
            const scores = {};
            const detected = [];
            
            Object.keys(CONFIG.PATTERNS.content).forEach(type => {
                scores[type] = 0;
            });
            
            Object.entries(CONFIG.PATTERNS.content).forEach(([type, patterns]) => {
                const fnLower = fileName.toLowerCase();
                patterns.filename.forEach(keyword => {
                    if (fnLower.includes(keyword.toLowerCase())) {
                        scores[type] += 15 / patterns.filename.length;
                    }
                });
            });
            
            if (metadata && metadata.title) {
                const titleLower = metadata.title.toLowerCase();
                Object.entries(CONFIG.PATTERNS.content).forEach(([type, patterns]) => {
                    if (patterns.metadata) {
                        patterns.metadata.forEach(keyword => {
                            if (titleLower.includes(keyword.toLowerCase())) {
                                scores[type] += 10 / patterns.metadata.length;
                            }
                        });
                    }
                });
            }
            
            Object.entries(CONFIG.PATTERNS.content).forEach(([type, patterns]) => {
                let matches = 0;
                
                patterns.text.forEach(keyword => {
                    if (keyword instanceof RegExp) {
                        const found = text.match(keyword);
                        if (found && found.length > 0) {
                            matches += found.length;
                        }
                    } else {
                        const regex = new RegExp(keyword.toLowerCase(), 'g');
                        const found = text.match(regex);
                        if (found) {
                            matches += found.length;
                        }
                    }
                });
                
                if (type === 'partition_musicale') {
                    const chordMatches = text.match(/\b[A-G][#b♯♭]?(m|maj|min|M)?[0-9]?\b/g);
                    if (chordMatches && chordMatches.length >= 10) {
                        scores[type] += 50;
                    } else {
                        scores[type] += Math.min(50, matches * 2);
                    }
                } else {
                    scores[type] += Math.min(50, matches * 5);
                }
            });
            
            Object.entries(scores).forEach(([type, score]) => {
                if (score >= 15) {
                    detected.push({
                        type,
                        score: Math.round(score),
                        confidence: Math.min(1.0, score / 100)
                    });
                }
            });
            
            detected.sort((a, b) => b.score - a.score);
            
            if (detected.length === 0) {
                detected.push({ type: 'text_standard', score: 50, confidence: 0.5 });
            }
            
            return {
                detected,
                selected: [],
                domains: []
            };
        }
        
        // ══════════════════════════════════════════════════════════════
        // COMPOSITION CALCULATION
        // ══════════════════════════════════════════════════════════════
        
        function calculateComposition(detected) {
            if (!detected || detected.length === 0) {
                return {
                    primary: 'text_standard',
                    secondary: [],
                    weights: { text_standard: 1.0 },
                    auto_weights: { text_standard: 1.0 }
                };
            }
            
            const primary = detected[0].type;
            const secondary = detected.slice(1, 3).map(d => d.type);
            
            const totalScore = detected.reduce((sum, d) => sum + d.score, 0);
            const weights = {};
            const auto_weights = {};
            
            detected.forEach(d => {
                const weight = d.score / totalScore;
                weights[d.type] = weight;
                auto_weights[d.type] = weight;
            });
            
            return {
                primary,
                secondary,
                weights,
                auto_weights,
                manual_override: false
            };
        }
        
        // ══════════════════════════════════════════════════════════════
        // DETECTION FROM TEXT (NON-PDF)
        // ══════════════════════════════════════════════════════════════
        
        async function detectDocumentMultiDimensionalFromText(file, text, extractedData) {
            try {
                STATE.extractedText = text;
                STATE.totalPages = 1;
                
                // Ensure extractedData has required properties with defaults
                const safeExtractedData = {
                    method: extractedData?.method || 'unknown',
                    confidence: extractedData?.confidence || 0.9,
                    text: extractedData?.text || text,
                    ...extractedData
                };
                
                const technical = {
                    format: safeExtractedData.method.includes('ocr') ? 'photo' : 'digital',
                    quality: safeExtractedData.confidence >= 0.9 ? 'high' : safeExtractedData.confidence >= 0.7 ? 'medium' : 'low',
                    ocr_required: safeExtractedData.method.includes('ocr'),
                    ocr_confidence: safeExtractedData.confidence || 1.0,
                    density: (file.size / 1024 / 1024) / STATE.totalPages || 0
                };
                
                const content = detectContentTypes(file.name, {}, text.toLowerCase());
                const composition = calculateComposition(content.detected);
                
                const analysis = {
                    technical,
                    content,
                    composition,
                    extractedData: safeExtractedData
                };
                
                STATE.analysis = analysis;
                STATE.documentType = composition.primary || 'text_standard';
                STATE.detectionResult = {
                    type: composition.primary,
                    confidence: content.detected[0]?.confidence || 0.7
                };
                
                return analysis;
                
            } catch (error) {
                console.error('Erreur détection depuis texte:', error);
                return {
                    technical: { format: 'digital', quality: 'unknown', ocr_required: false, density: 0 },
                    content: { detected: [{ type: 'text_standard', score: 50, confidence: 0.5 }], selected: [], domains: [] },
                    composition: { primary: 'text_standard', secondary: [], weights: { text_standard: 1.0 }, auto_weights: { text_standard: 1.0 } }
                };
            }
        }
        
        // ══════════════════════════════════════════════════════════════
        // IMAGE EXTRACTION (OCR WITH CACHE & PARALLEL)
        // ══════════════════════════════════════════════════════════════
        
        async function extractTextFromImage(file) {
            try {
                if (STATE.ocrWorkerPool) {
                    return await STATE.ocrWorkerPool.recognize(file);
                }
                
                if (STATE.ocrCache) {
                    const fileHash = await STATE.ocrCache.hashFile(file);
                    const cached = await STATE.ocrCache.get(fileHash);
                    
                    if (cached && Date.now() - cached.timestamp < 7 * 24 * 3600 * 1000) {
                        console.log('Cache hit:', file.name);
                        showStatus('Texte trouvé en cache !', 'success');
                        return cached.result;
                    }
                }
                
                updateProgress(30, 'OCR en cours', 'Extraction texte...');
                showStatus('OCR en cours... (30-60s)', 'info');
                
                const { data: { text, confidence } } = await Tesseract.recognize(
                    file,
                    'fra+eng',
                    {
                        logger: m => {
                            if (m.status === 'recognizing text') {
                                const pct = Math.round(m.progress * 100);
                                updateProgress(30 + pct * 0.5, 'OCR en cours', `${pct}% - Extraction texte...`);
                            }
                        }
                    }
                );
                
                const result = {
                    text: text.trim(),
                    confidence: confidence / 100,
                    wordCount: text.split(/\s+/).length,
                    method: 'tesseract_ocr'
                };
                
                if (STATE.ocrCache) {
                    const fileHash = await STATE.ocrCache.hashFile(file);
                    await STATE.ocrCache.set(fileHash, result);
                }
                
                showStatus('OCR terminé !', 'success');
                updateProgress(80, 'OCR terminé', 'Analyse du contenu...');
                
                return result;
                
            } catch (error) {
                console.error('Erreur OCR:', error);
                showStatus('Erreur OCR: ' + error.message, 'error');
                return {
                    text: '',
                    confidence: 0,
                    wordCount: 0,
                    method: 'ocr_failed',
                    error: error.message
                };
            }
        }
        
        // ══════════════════════════════════════════════════════════════
        // EXCEL EXTRACTION
        // ══════════════════════════════════════════════════════════════
        
        async function extractTextFromExcel(file) {
            try {
                updateProgress(30, 'Extraction Excel', 'Lecture des feuilles...');
                
                const arrayBuffer = await file.arrayBuffer();
                const workbook = XLSX.read(arrayBuffer);
                
                let allText = '';
                const sheets = [];
                
                workbook.SheetNames.forEach(sheetName => {
                    const sheet = workbook.Sheets[sheetName];
                    const text = XLSX.utils.sheet_to_txt(sheet);
                    
                    sheets.push({ name: sheetName, text });
                    allText += `\n--- ${sheetName} ---\n${text}`;
                });
                
                updateProgress(80, 'Excel traité', 'Analyse...');
                
                return {
                    text: allText,
                    confidence: 1.0,
                    wordCount: allText.split(/\s+/).length,
                    method: 'sheetjs_excel',
                    sheets
                };
                
            } catch (error) {
                console.error('Erreur Excel:', error);
                return {
                    text: '',
                    confidence: 0,
                    wordCount: 0,
                    method: 'excel_failed',
                    error: error.message
                };
            }
        }
        
        // ══════════════════════════════════════════════════════════════
        // POWERPOINT EXTRACTION
        // ══════════════════════════════════════════════════════════════
        
        async function extractTextFromPPT(file) {
            try {
                updateProgress(30, 'Extraction PowerPoint', 'Lecture slides...');
                
                const zip = await JSZip.loadAsync(file);
                const slides = [];
                let allText = '';
                
                for (let i = 1; i <= 200; i++) {
                    const slideFile = zip.file(`ppt/slides/slide${i}.xml`);
                    if (!slideFile) break;
                    
                    const xml = await slideFile.async('string');
                    const text = extractTextFromXML(xml);
                    
                    slides.push({ num: i, text });
                    allText += `\n--- SLIDE ${i} ---\n${text}`;
                }
                
                updateProgress(80, 'PowerPoint traité', 'Analyse...');
                
                return {
                    text: allText,
                    confidence: 1.0,
                    wordCount: allText.split(/\s+/).length,
                    method: 'jszip_pptx',
                    slides
                };
                
            } catch (error) {
                console.error('Erreur PowerPoint:', error);
                return {
                    text: '',
                    confidence: 0,
                    wordCount: 0,
                    method: 'pptx_failed',
                    error: error.message
                };
            }
        }
        
        function extractTextFromXML(xml) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(xml, 'text/xml');
            const textElements = doc.querySelectorAll('a\\:t, t');
            return Array.from(textElements).map(el => el.textContent).join(' ');
        }
        
        // ══════════════════════════════════════════════════════════════
        // WORD EXTRACTION
        // ══════════════════════════════════════════════════════════════
        
        async function extractTextFromDOCX(file) {
            try {
                updateProgress(30, 'Extraction Word', 'Lecture...');
                
                const arrayBuffer = await file.arrayBuffer();
                const result = await mammoth.extractRawText({ arrayBuffer });
                
                updateProgress(80, 'Word traité', 'Analyse...');
                
                return {
                    text: result.value.trim(),
                    confidence: result.messages.length === 0 ? 1.0 : 0.9,
                    wordCount: result.value.split(/\s+/).length,
                    method: 'mammoth_docx'
                };
                
            } catch (error) {
                console.error('Erreur Word:', error);
                return {
                    text: '',
                    confidence: 0,
                    wordCount: 0,
                    method: 'docx_failed',
                    error: error.message
                };
            }
        }
        
        // ══════════════════════════════════════════════════════════════
        // EPUB EXTRACTION
        // ══════════════════════════════════════════════════════════════
        
        async function extractTextFromEPUB(file) {
            try {
                updateProgress(30, 'Extraction EPUB', 'Décompression...');
                
                const zip = await JSZip.loadAsync(file);
                let allText = '';
                
                const contentFiles = Object.keys(zip.files).filter(name => 
                    name.endsWith('.html') || name.endsWith('.xhtml')
                );
                
                for (const filename of contentFiles) {
                    const content = await zip.file(filename).async('string');
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(content, 'text/html');
                    const text = doc.body ? doc.body.textContent : '';
                    allText += text + '\n\n';
                }
                
                updateProgress(80, 'EPUB traité', 'Analyse...');
                
                return {
                    text: allText.trim(),
                    confidence: 1.0,
                    wordCount: allText.split(/\s+/).length,
                    method: 'jszip_epub'
                };
                
            } catch (error) {
                console.error('Erreur EPUB:', error);
                return {
                    text: '',
                    confidence: 0,
                    wordCount: 0,
                    method: 'epub_failed',
                    error: error.message
                };
            }
        }
        
        // ══════════════════════════════════════════════════════════════
        // CSV EXTRACTION
        // ══════════════════════════════════════════════════════════════
        
        async function extractTextFromCSV(file) {
            try {
                const text = await file.text();
                const delimiter = file.name.endsWith('.tsv') ? '\t' : ',';
                
                const result = Papa.parse(text, {
                    delimiter,
                    header: true,
                    skipEmptyLines: true
                });
                
                let allText = '';
                result.data.forEach((row, idx) => {
                    allText += `Ligne ${idx + 1}: ${JSON.stringify(row)}\n`;
                });
                
                return {
                    text: allText,
                    confidence: 1.0,
                    wordCount: allText.split(/\s+/).length,
                    method: 'papaparse_csv'
                };
                
            } catch (error) {
                console.error('Erreur CSV:', error);
                return {
                    text: '',
                    confidence: 0,
                    wordCount: 0,
                    method: 'csv_failed',
                    error: error.message
                };
            }
        }
        
        // ══════════════════════════════════════════════════════════════
        // STRUCTURED (JSON/XML)
        // ══════════════════════════════════════════════════════════════
        
        async function extractTextFromStructured(file, type) {
            try {
                const text = await file.text();
                
                let parsed;
                if (type === 'json') {
                    parsed = JSON.parse(text);
                } else {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(text, 'text/xml');
                    parsed = doc.documentElement.textContent;
                }
                
                const prettyText = type === 'json' ? JSON.stringify(parsed, null, 2) : parsed;
                
                return {
                    text: prettyText,
                    confidence: 1.0,
                    wordCount: prettyText.split(/\s+/).length,
                    method: type + '_parse'
                };
                
            } catch (error) {
                console.error('Erreur ' + type.toUpperCase() + ':', error);
                return {
                    text: '',
                    confidence: 0,
                    wordCount: 0,
                    method: type + '_failed',
                    error: error.message
                };
            }
        }
        
        // ══════════════════════════════════════════════════════════════
        // YAML EXTRACTION
        // ══════════════════════════════════════════════════════════════
        
        async function extractTextFromYAML(file) {
            try {
                const text = await file.text();
                const parsed = jsyaml.load(text);
                const prettyText = JSON.stringify(parsed, null, 2);
                
                return {
                    text: prettyText,
                    confidence: 1.0,
                    wordCount: prettyText.split(/\s+/).length,
                    method: 'jsyaml_parse'
                };
                
            } catch (error) {
                console.error('Erreur YAML:', error);
                return {
                    text: '',
                    confidence: 0,
                    wordCount: 0,
                    method: 'yaml_failed',
                    error: error.message
                };
            }
        }
        
        // ══════════════════════════════════════════════════════════════
        // SVG EXTRACTION
        // ══════════════════════════════════════════════════════════════
        
        async function extractTextFromSVG(file) {
            try {
                const text = await file.text();
                const parser = new DOMParser();
                const svg = parser.parseFromString(text, 'image/svg+xml');
                
                const textElements = svg.querySelectorAll('text, tspan');
                const extractedText = Array.from(textElements)
                    .map(el => el.textContent)
                    .filter(t => t.trim())
                    .join('\n');
                
                return {
                    text: extractedText,
                    confidence: 1.0,
                    wordCount: extractedText.split(/\s+/).length,
                    method: 'svg_parse'
                };
                
            } catch (error) {
                console.error('Erreur SVG:', error);
                return {
                    text: '',
                    confidence: 0,
                    wordCount: 0,
                    method: 'svg_failed',
                    error: error.message
                };
            }
        }
        
        // ══════════════════════════════════════════════════════════════
        // RTF EXTRACTION
        // ══════════════════════════════════════════════════════════════
        
        async function extractTextFromRTF(file) {
            try {
                const text = await file.text();
                const cleanText = text
                    .replace(/\\[a-z]+[0-9]*\s?/g, ' ')
                    .replace(/[{}]/g, '')
                    .trim();
                
                return {
                    text: cleanText,
                    confidence: 0.8,
                    wordCount: cleanText.split(/\s+/).length,
                    method: 'rtf_basic_parse'
                };
                
            } catch (error) {
                console.error('Erreur RTF:', error);
                return {
                    text: '',
                    confidence: 0,
                    wordCount: 0,
                    method: 'rtf_failed',
                    error: error.message
                };
            }
        }
        
        // ══════════════════════════════════════════════════════════════
        // MOBI EXTRACTION
        // ══════════════════════════════════════════════════════════════
        
        async function extractTextFromMobi(file) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                const text = new TextDecoder('utf-8').decode(arrayBuffer);
                const cleanText = text.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
                
                return {
                    text: cleanText,
                    confidence: 0.7,
                    wordCount: cleanText.split(/\s+/).length,
                    method: 'mobi_basic_parse'
                };
                
            } catch (error) {
                console.error('Erreur MOBI:', error);
                return {
                    text: '',
                    confidence: 0,
                    wordCount: 0,
                    method: 'mobi_failed',
                    error: error.message
                };
            }
        }
        
        // ══════════════════════════════════════════════════════════════
        // COMICS EXTRACTION
        // ══════════════════════════════════════════════════════════════
        
        async function extractTextFromComics(file) {
            try {
                const zip = await JSZip.loadAsync(file);
                const images = [];
                
                Object.keys(zip.files).forEach(filename => {
                    if (/\.(jpg|jpeg|png|gif|webp)$/i.test(filename)) {
                        images.push(filename);
                    }
                });
                
                let text = `Comic avec ${images.length} pages`;
                
                return {
                    text,
                    confidence: 0.5,
                    wordCount: text.split(/\s+/).length,
                    method: 'cbz_parse',
                    pages: images.length
                };
                
            } catch (error) {
                console.error('Erreur Comics:', error);
                return {
                    text: '',
                    confidence: 0,
                    wordCount: 0,
                    method: 'cbz_failed',
                    error: error.message
                };
            }
        }
        
        // ══════════════════════════════════════════════════════════════
        // PLAIN TEXT EXTRACTION
        // ══════════════════════════════════════════════════════════════
        
        async function extractTextFromPlainFile(file) {
            try {
                const text = await file.text();
                
                let cleanText = text;
                if (file.name.endsWith('.html') || file.name.endsWith('.htm')) {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(text, 'text/html');
                    cleanText = doc.body ? doc.body.textContent : text;
                }
                
                return {
                    text: cleanText.trim(),
                    confidence: 1.0,
                    wordCount: cleanText.split(/\s+/).length,
                    method: 'direct_read'
                };
                
            } catch (error) {
                console.error('Erreur lecture texte:', error);
                return {
                    text: '',
                    confidence: 0,
                    wordCount: 0,
                    method: 'read_failed',
                    error: error.message
                };
            }
        }
        
        // ══════════════════════════════════════════════════════════════
        // ZIP RECURSIVE
        // ══════════════════════════════════════════════════════════════
        
        async function handleZipFile(file) {
            try {
                const zip = await JSZip.loadAsync(file);
                const files = [];
                
                zip.forEach((relativePath, zipEntry) => {
                    if (zipEntry.dir) return;
                    
                    const ext = relativePath.split('.').pop().toLowerCase();
                    const supported = ['pdf', 'png', 'jpg', 'jpeg', 'docx', 'pptx', 'xlsx', 'txt'];
                    
                    if (supported.includes(ext)) {
                        files.push({ path: relativePath, entry: zipEntry, ext });
                    }
                });
                
                const results = [];
                for (let i = 0; i < files.length; i++) {
                    const f = files[i];
                    updateProgress(20 + (i / files.length) * 60, 'ZIP', `${i + 1}/${files.length}: ${f.path}`);
                    
                    const blob = await f.entry.async('blob');
                    const extractedFile = new File([blob], f.path);
                    
                    try {
                        const result = await detectDocumentType(extractedFile);
                        results.push({ path: f.path, result });
                    } catch (err) {
                        console.error('Error processing', f.path, err);
                    }
                }
                
                const merged = {
                    technical: { format: 'digital', quality: 'high', ocr_required: false, density: 0.5 },
                    content: {
                        detected: [{ type: 'text_standard', score: 80, confidence: 0.8 }],
                        selected: ['text_standard'],
                        domains: []
                    },
                    composition: {
                        primary: 'text_standard',
                        secondary: [],
                        weights: { text_standard: 1.0 },
                        auto_weights: { text_standard: 1.0 }
                    },
                    zipFiles: results
                };
                
                return merged;
                
            } catch (error) {
                console.error('Erreur ZIP:', error);
                return {
                    technical: { format: 'digital', quality: 'unknown', ocr_required: false, density: 0 },
                    content: { detected: [{ type: 'text_standard', score: 50, confidence: 0.5 }], selected: [], domains: [] },
                    composition: { primary: 'text_standard', secondary: [], weights: { text_standard: 1.0 }, auto_weights: { text_standard: 1.0 } }
                };
            }
        }
        
        // ══════════════════════════════════════════════════════════════
        // DISPLAY DETECTION RESULT
        // ══════════════════════════════════════════════════════════════
        
        function displayDetectionResult(analysis) {
            const detectionSection = document.getElementById('detectionSection');
            
            if (!analysis || !analysis.technical || !analysis.content) {
                detectionSection.innerHTML = '<p>Erreur analyse</p>';
                return;
            }
            
            const tech = analysis.technical;
            const content = analysis.content;
            const comp = analysis.composition;
            
            const contentNames = {
                'partition_musicale': 'Partition Musicale',
                'tablature': 'Tablature',
                'texte_pedagogique': 'Texte Pédagogique',
                'regles_jeu': 'Règles de Jeu',
                'document_therapie': 'Document Thérapie',
                'questionnaire_psy': 'Questionnaire Psychologique',
                'paper_scientifique': 'Paper Scientifique',
                'manuel_technique': 'Manuel Technique',
                'text_standard': 'Texte Standard'
            };
            
            let detectedHTML = '';
            content.detected.slice(0, 5).forEach((item, idx) => {
                const name = contentNames[item.type] || item.type;
                const isPrimary = idx === 0;
                const badge = isPrimary ? '<span style="background:#4CAF50;color:white;padding:3px 10px;border-radius:6px;font-size:0.8em;margin-left:10px;">PRINCIPAL</span>' : '';
                
                detectedHTML += `
                    <div style="padding:12px;background:${isPrimary ? '#E8F5E9' : 'var(--sable)'};border-radius:8px;margin-bottom:8px;">
                        <div style="display:flex;justify-content:space-between;align-items:center;">
                            <div>
                                <strong>${name}</strong> ${badge}
                                <div style="font-size:0.85em;color:var(--gris-secondaire);margin-top:4px;">
                                    Score: ${item.score} | Confiance: ${Math.round(item.confidence * 100)}%
                                </div>
                            </div>
                            <div style="background:var(--mer);color:white;padding:6px 14px;border-radius:12px;font-weight:600;">
                                ${Math.round((comp.weights[item.type] || 0) * 100)}%
                            </div>
                        </div>
                    </div>
                `;
            });
            
            const densityText = tech.density?.toFixed(3) || 'N/A';
            
            detectionSection.innerHTML = `
                <h2>Analyse Multi-Dimensionnelle</h2>
                
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-top:20px;">
                    <div class="card">
                        <h4>Dimension Technique</h4>
                        <div class="info-grid">
                            <div class="info-item">
                                <div class="info-label">Format:</div>
                                <div class="info-value">${tech.format.toUpperCase()}</div>
                            </div>
                            <div class="info-item">
                                <div class="info-label">Qualité:</div>
                                <div class="info-value">${tech.quality}</div>
                            </div>
                            <div class="info-item">
                                <div class="info-label">Densité:</div>
                                <div class="info-value">${densityText} MB/p</div>
                            </div>
                            <div class="info-item">
                                <div class="info-label">OCR requis:</div>
                                <div class="info-value">${tech.ocr_required ? 'Oui' : 'Non'}</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h4>Dimension Sémantique</h4>
                        ${detectedHTML}
                    </div>
                </div>
                
                <div class="card" style="margin-top:20px;">
                    <h4>Composition Adaptative</h4>
                    <p>
                        <strong>Principal:</strong> ${contentNames[comp.primary]} (${Math.round(comp.weights[comp.primary] * 100)}%)
                        ${comp.secondary.length > 0 ? '<br><strong>Secondaire:</strong> ' + comp.secondary.map(s => `${contentNames[s]} (${Math.round(comp.weights[s] * 100)}%)`).join(', ') : ''}
                    </p>
                </div>
            `;
            
            showCompositionOverride();
        }
        
        // ══════════════════════════════════════════════════════════════
        // COMPOSITION OVERRIDE UI
        // ══════════════════════════════════════════════════════════════
        
        function showCompositionOverride() {
            if (!STATE.analysis) return;
            
            const detected = STATE.analysis.content.detected || [];
            
            const checkboxes = document.querySelectorAll('#contentCheckboxes input[type="checkbox"]');
            checkboxes.forEach(cb => {
                const isDetected = detected.some(d => d.type === cb.value);
                cb.checked = isDetected;
            });
            
            if (detected.length > 0) {
                displayWeightSliders(detected.map(d => d.type));
            }
        }
        
        function updateTechnicalFormat() {
            if (!STATE.analysis) return;
            
            const value = document.getElementById('technicalOverride').value;
            if (value !== 'auto') {
                STATE.analysis.technical.format = value;
                STATE.analysis.technical.manual_override = true;
            }
        }
        
        function updateComposition() {
            if (!STATE.analysis) return;
            
            const checkboxes = document.querySelectorAll('#contentCheckboxes input[type="checkbox"]:checked');
            const selectedTypes = Array.from(checkboxes).map(cb => cb.value);
            
            if (selectedTypes.length === 0) {
                document.getElementById('weightsSection').style.display = 'none';
                return;
            }
            
            STATE.analysis.content.selected = selectedTypes;
            STATE.analysis.composition.manual_override = true;
            
            displayWeightSliders(selectedTypes);
            recalculateWeights(selectedTypes);
        }
        
        function displayWeightSliders(types) {
            const slidersList = document.getElementById('slidersList');
            const weightsSection = document.getElementById('weightsSection');
            
            if (types.length === 0) {
                weightsSection.style.display = 'none';
                return;
            }
            
            weightsSection.style.display = 'block';
            
            const weights = STATE.analysis.composition.weights;
            
            // ✨ MAPPING COMPLET: 18 types (10 universels + 8 complémentaires)
            const names = {
                // Types universels (10)
                'text_paragraphs': 'Texte',
                'images_photos': 'Images',
                'tables_data': 'Tableaux',
                'charts_graphs': 'Graphiques',
                'diagrams_schemas': 'Diagrammes',
                'forms_templates': 'Formulaires',
                'lists_bullet_points': 'Listes',
                'code_technical': 'Code',
                'mathematical_formulas': 'Math',
                'annotations_highlights': 'Annotations',
                // Types complémentaires (8)
                'musical_notation': 'Notation Musicale',
                'citations_references': 'Citations',
                'exercises_questions': 'Exercices',
                'callouts_boxes': 'Encadrés',
                'index_glossary': 'Index',
                'case_studies': 'Études de Cas',
                'links_urls': 'Liens',
                'infographics': 'Infographies',
                // Anciens types (compatibilité rétro-active)
                'partition_musicale': 'Partition',
                'tablature': 'Tablature',
                'texte_pedagogique': 'Pédagogie',
                'regles_jeu': 'Jeu',
                'document_therapie': 'Thérapie',
                'questionnaire_psy': 'Questionnaire',
                'paper_scientifique': 'Scientifique',
                'manuel_technique': 'Technique'
            };
            
            let html = '';
            types.forEach(type => {
                const weight = (weights[type] || 0) * 100;
                const name = names[type] || type;
                
                html += `
                    <div class="slider-item">
                        <label>${name}</label>
                        <input type="range" min="0" max="100" value="${weight}" 
                               id="slider_${type}" oninput="updateWeightsManual()">
                        <span id="value_${type}">${Math.round(weight)}%</span>
                    </div>
                `;
            });
            
            slidersList.innerHTML = html;
        }
        
        function recalculateWeights(selectedTypes) {
            const detected = STATE.analysis.content.detected;
            const totalScore = detected
                .filter(d => selectedTypes.includes(d.type))
                .reduce((sum, d) => sum + d.score, 0);
            
            const newWeights = {};
            selectedTypes.forEach(type => {
                const item = detected.find(d => d.type === type);
                newWeights[type] = item ? item.score / totalScore : 1 / selectedTypes.length;
            });
            
            STATE.analysis.composition.weights = newWeights;
            STATE.analysis.composition.primary = selectedTypes[0];
            STATE.analysis.composition.secondary = selectedTypes.slice(1);
            
            displayWeightSliders(selectedTypes);
        }
        
        function updateWeightsManual() {
            const checkboxes = document.querySelectorAll('#contentCheckboxes input[type="checkbox"]:checked');
            const selectedTypes = Array.from(checkboxes).map(cb => cb.value);
            
            let total = 0;
            const rawWeights = {};
            
            selectedTypes.forEach(type => {
                const slider = document.getElementById('slider_' + type);
                const value = parseInt(slider.value);
                rawWeights[type] = value;
                total += value;
            });
            
            const normalized = {};
            selectedTypes.forEach(type => {
                normalized[type] = total > 0 ? rawWeights[type] / total : 1 / selectedTypes.length;
                document.getElementById('value_' + type).textContent = Math.round(normalized[type] * 100) + '%';
            });
            
            STATE.analysis.composition.weights = normalized;
        }
        
        function resetWeights() {
            if (!STATE.analysis) return;
            
            STATE.analysis.composition.weights = { ...STATE.analysis.composition.auto_weights };
            STATE.analysis.composition.manual_override = false;
            
            const checkboxes = document.querySelectorAll('#contentCheckboxes input[type="checkbox"]:checked');
            const selectedTypes = Array.from(checkboxes).map(cb => cb.value);
            
            displayWeightSliders(selectedTypes);
        }
        
        // ══════════════════════════════════════════════════════════════
        // CONFIGURATION
        // ══════════════════════════════════════════════════════════════
        
        function selectPlatform(platform) {
            STATE.platform = platform;
            
            document.getElementById('platformChatGPT').classList.remove('selected');
            document.getElementById('platformClaude').classList.remove('selected');
            
            if (platform === 'chatgpt') {
                document.getElementById('platformChatGPT').classList.add('selected');
                document.getElementById('gptSelectorGroup').style.display = 'block';
                document.getElementById('claudeSelectorGroup').style.display = 'none';
            } else {
                document.getElementById('platformClaude').classList.add('selected');
                document.getElementById('gptSelectorGroup').style.display = 'none';
                document.getElementById('claudeSelectorGroup').style.display = 'block';
            }
            
            updateIndicators();
        }
        
        function updateIndicators() {
            STATE.format = parseInt(document.getElementById('formatSelector').value);
            STATE.gptModel = document.getElementById('gptSelector').value;
            STATE.claudeModel = document.getElementById('claudeSelector').value;
            
            let config;
            if (STATE.platform === 'chatgpt') {
                config = CONFIG.gpt[STATE.gptModel];
            } else {
                config = CONFIG.claude[STATE.claudeModel];
            }
            
            document.getElementById('qualityIndicator').textContent = config.quality;
            document.getElementById('speedIndicator').textContent = config.speed;
            document.getElementById('detailsIndicator').textContent = config.details;
            
            document.getElementById('formatDesc').innerHTML = `
                <strong>${STATE.format === 32 ? 'Format R&D (32 modules)' : 'Format Standard (7 modules)'}</strong><br>
                <p style="margin-top:10px;">${CONFIG.format[STATE.format]}</p>
            `;
        }
        
        // ══════════════════════════════════════════════════════════════
        // PROCESSING WORKFLOW
        // ══════════════════════════════════════════════════════════════
        
        function calculateAdaptiveBatchSize() {
            const analysis = STATE.analysis;
            if (!analysis || !analysis.technical || !analysis.composition) {
                return STATE.format === 32 ? 30 : 50;
            }
            
            const base = CONFIG.BATCH_FACTORS.base_batch_size;
            const tech = analysis.technical.format;
            const weights = analysis.composition.weights;
            
            const techFactor = CONFIG.BATCH_FACTORS.technical[tech] || 1.0;
            
            let contentFactor = 0;
            for (const [type, weight] of Object.entries(weights)) {
                const factor = CONFIG.BATCH_FACTORS.content[type] || 1.0;
                contentFactor += factor * weight;
            }
            
            if (contentFactor === 0) contentFactor = 1.0;
            
            const batchSize = Math.round(base * techFactor * contentFactor);
            const finalBatch = Math.max(5, Math.min(50, batchSize));
            
            console.log('Batch size:', finalBatch);
            
            return finalBatch;
        }
        
        async function processFile() {
            document.getElementById('configSection').style.display = 'none';
            document.getElementById('phase2').style.display = 'block';
            
            await splitDocument();
            
            document.getElementById('phase2').scrollIntoView({ 
                behavior: 'smooth', 
                block: 'start' 
            });
        }
        
        async function splitDocument() {
            let maxPagesPerPart = calculateAdaptiveBatchSize();
            
            const numParts = Math.ceil(STATE.totalPages / maxPagesPerPart);
            STATE.parts = [];
            
            if (STATE.fileType === 'pdf') {
                const arrayBuffer = await STATE.file.arrayBuffer();
                const pdfDoc = await PDFLib.PDFDocument.load(arrayBuffer, {
                    ignoreEncryption: true
                });
                
                for (let i = 0; i < numParts; i++) {
                    const startPage = i * maxPagesPerPart + 1;
                    const endPage = Math.min((i + 1) * maxPagesPerPart, STATE.totalPages);
                    
                    const newPdf = await PDFLib.PDFDocument.create();
                    const pages = await newPdf.copyPages(pdfDoc, 
                        Array.from({length: endPage - startPage + 1}, (_, j) => startPage - 1 + j)
                    );
                    pages.forEach(page => newPdf.addPage(page));
                    
                    const pdfBytes = await newPdf.save();
                    const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                    
                    STATE.parts.push({
                        num: i + 1,
                        startPage,
                        endPage,
                        file: blob,
                        status: 'pending',
                        json: null
                    });
                }
            } else {
                STATE.parts.push({
                    num: 1,
                    startPage: 1,
                    endPage: 1,
                    file: STATE.file,
                    status: 'pending',
                    json: null
                });
            }
            
            displayParts();
        }
        
        function displayParts() {
            let html = '';
            STATE.parts.forEach((part, index) => {
                html += `
                    <div class="part-card" id="part-${index}">
                        <div class="part-header">
                            <div class="part-title">Partie ${part.num} • Pages ${part.startPage}-${part.endPage}</div>
                            <span class="status-badge status-pending" id="status-${index}">En attente</span>
                        </div>
                        
                        <div class="prompt-output" id="prompt-${index}">${generatePrompt(part)}</div>
                        
                        <div class="btn-group">
                            <button class="btn btn-small" onclick="copyAndDownload(${index})">
                                Copier Prompt & Télécharger PDF
                            </button>
                        </div>
                        
                        <div style="margin-top:20px;">
                            <label style="font-weight:600;display:block;margin-bottom:10px;">
                                Collez ici le JSON généré :
                            </label>
                            <textarea id="json-text-${index}" placeholder="Collez le JSON ici..."></textarea>
                            <div class="btn-group">
                                <button class="btn btn-secondary btn-small" onclick="validateJSON(${index})">
                                    Valider JSON
                                </button>
                                <button class="btn btn-small" onclick="acceptJSON(${index})">
                                    Accepter & Continuer
                                </button>
                            </div>
                            <div id="validation-${index}" style="margin-top:15px;"></div>
                        </div>
                    </div>
                `;
            });
            document.getElementById('partsContainer').innerHTML = html;
        }
        
        // ══════════════════════════════════════════════════════════════
        // PROMPT GENERATION (ADAPTIVE)
        // ══════════════════════════════════════════════════════════════
        
        function generatePrompt(part) {
            const analysis = STATE.analysis || {};
            const tech = analysis.technical || { format: 'digital', quality: 'medium', ocr_required: false };
            const comp = analysis.composition || { primary: 'text_standard', secondary: [], weights: {} };
            
            let prompt = `━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
CONTRAT R&D ANTHROPIC - PROMPT ADAPTATIF MULTI-DIMENSIONNEL
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Document : ${STATE.fileName}
Pages ${part.startPage}-${part.endPage}
Format : ${STATE.format === 32 ? 'R&D COMPLET 32 MODULES' : 'STANDARD 7 MODULES'}

VOUS AVEZ DÉJÀ ACCEPTÉ ET VALIDÉ :
• Format : ${STATE.format} MODULES R&D ANTHROPIC
• Citations : Texte simple dans champ "citation"
• Compression : Intelligente AUTOMATIQUE
• Questions : ZÉRO

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
CONTEXTE TECHNIQUE
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
            
            const techModule = PROMPT_MODULES.technical[tech.format] || '';
            if (techModule) {
                prompt += techModule + '\n';
            }
            
            prompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
MODULES CONTENU (COMPOSITION ADAPTATIVE)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
            
            const primaryModule = PROMPT_MODULES.content[comp.primary];
            const primaryWeight = comp.weights[comp.primary] || 1.0;
            
            if (primaryModule) {
                prompt += `
MODULE PRINCIPAL (${Math.round(primaryWeight * 100)}%)
${'═'.repeat(80)}

${primaryModule}
`;
            }
            
            if (comp.secondary && comp.secondary.length > 0) {
                comp.secondary.forEach(type => {
                    const module = PROMPT_MODULES.content[type];
                    const weight = comp.weights[type] || 0;
                    
                    if (module && weight > 0) {
                        prompt += `
MODULE SECONDAIRE (${Math.round(weight * 100)}%)
${'-'.repeat(80)}

${module}
`;
                    }
                });
            }
            
            const jsonStructure = generateFusedJSONStructure(comp, STATE.format);
            
            prompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
STRUCTURE JSON FUSIONNÉE ADAPTATIVE
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

${jsonStructure}

Remplir TOUTES les sections présentes selon les modules activés.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
RÈGLE ABSOLUE - FORMAT JSON PUR
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

GÉNÉREZ JSON PUR UNIQUEMENT.
Commence EXACTEMENT par {
Termine EXACTEMENT par }
RIEN avant le {
RIEN après le }

TOUS LES MODULES INDIQUÉS SONT OBLIGATOIRES.
`;
            
            if (STATE.platform === 'chatgpt') {
                prompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
INSTRUCTIONS CHATGPT ANTI-PROCRASTINATION
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

CRITICAL RULES FOR CHATGPT:
1. Start IMMEDIATELY with JSON. NO preamble, NO explanation.
2. Complete ALL fields. Empty fields = FAILURE.
3. NO placeholders [TBD]. Extract actual data or use null.
4. NO questions, NO clarifications. Execute NOW.
5. Format already agreed. Do NOT ask for confirmation.

YOU ALREADY AGREED to this format in our previous contract.
PROCEED IMMEDIATELY.
`;
            }
            
            prompt += `
Générez le JSON complet maintenant.`;
            
            return prompt;
        }
        
        function generateFusedJSONStructure(composition, formatLevel) {
            const types = Object.keys(composition.weights || {});
            
            let structure = {
                metadata: {
                    type_composition: types,
                    weights: composition.weights,
                    format_level: formatLevel
                }
            };
            
            structure.structure_hierarchique = {};
            structure.index_conceptuel = {};
            structure.contenu_enrichi = {};
            
            if (types.includes('partition_musicale') || types.includes('tablature')) {
                structure.morceaux = [];
                structure.grilles_accords = [];
            }
            
            if (types.includes('tablature')) {
                structure.tablatures = [];
            }
            
            if (types.includes('texte_pedagogique')) {
                structure.objectifs_apprentissage = [];
                structure.exercices = [];
                structure.progression = {};
            }
            
            if (types.includes('regles_jeu')) {
                structure.composants = [];
                structure.deroulement = {};
                structure.conditions_victoire = "";
            }
            
            if (types.includes('document_therapie')) {
                structure.cas_cliniques = [];
                structure.outils_therapeutiques = [];
            }
            
            if (types.includes('questionnaire_psy')) {
                structure.echelles = [];
                structure.items = [];
                structure.scoring = {};
            }
            
            if (types.includes('paper_scientifique')) {
                structure.abstract = "";
                structure.methodologie = {};
                structure.resultats = {};
                structure.bibliographie = [];
            }
            
            if (types.includes('manuel_technique')) {
                structure.specifications = [];
                structure.procedures = [];
            }
            
            if (formatLevel === 32) {
                structure.graphe_connaissances = {};
                structure.taxonomie = {};
                structure.semantique = {};
                structure.pedagogie = {};
                structure.multimodal = {};
                structure.evaluation = {};
                structure.references = {};
                structure.citations_semantiques = {};
                structure.contexte_historique = {};
                structure.applications_pratiques = {};
                structure.controverses = {};
                structure.glossaire = {};
                structure.donnees_statistiques = {};
                structure.comparaisons = {};
                structure.implementation = {};
                structure.public_cible = {};
                structure.ressources_complementaires = {};
                structure.validation_qualite = {};
                structure.meta_analyse = {};
                structure.liens_externes = {};
                structure.temporalite = {};
                structure.patterns = {};
                structure.insights = {};
                structure.analytics = {};
            } else {
                structure.graphe_connaissances = {};
                structure.taxonomie = {};
                structure.analytics = {};
            }
            
            return JSON.stringify(structure, null, 2);
        }
        
        // ══════════════════════════════════════════════════════════════
        // COPY & DOWNLOAD
        // ══════════════════════════════════════════════════════════════
        
        async function copyAndDownload(index) {
            const part = STATE.parts[index];
            const prompt = generatePrompt(part);
            
            try {
                await navigator.clipboard.writeText(prompt);
                showStatus('Prompt copié dans le presse-papiers !', 'success');
            } catch (error) {
                console.error('Erreur copie:', error);
                showStatus('Erreur copie presse-papiers', 'error');
            }
            
            const url = URL.createObjectURL(part.file);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${STATE.fileName.replace(/\.[^/.]+$/, '')}_part${part.num}.pdf`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // ══════════════════════════════════════════════════════════════
        // JSON VALIDATION
        // ══════════════════════════════════════════════════════════════
        
        function validateJSON(index) {
            const textarea = document.getElementById(`json-text-${index}`);
            const validationDiv = document.getElementById(`validation-${index}`);
            
            try {
                const text = textarea.value.trim();
                const json = JSON.parse(text);
                
                validationDiv.innerHTML = `
                    <div class="status-message status-success" style="display:block;">
                        JSON valide ! ${Object.keys(json).length} clés trouvées.
                    </div>
                `;
                
                STATE.parts[index].json = json;
                
            } catch (error) {
                validationDiv.innerHTML = `
                    <div class="status-message status-error" style="display:block;">
                        Erreur JSON : ${error.message}
                    </div>
                `;
            }
        }
        
        function acceptJSON(index) {
            const textarea = document.getElementById(`json-text-${index}`);
            
            try {
                const text = textarea.value.trim();
                const json = JSON.parse(text);
                
                STATE.parts[index].json = json;
                STATE.parts[index].status = 'completed';
                
                document.getElementById(`status-${index}`).textContent = 'Terminé';
                document.getElementById(`status-${index}`).className = 'status-badge status-completed';
                
                showStatus(`Partie ${STATE.parts[index].num} acceptée !`, 'success');
                
                const allCompleted = STATE.parts.every(p => p.status === 'completed');
                if (allCompleted) {
                    showStatus('Toutes les parties terminées ! Génération ZIP...', 'success');
                    setTimeout(() => {
                        downloadZIP();
                    }, 1000);
                }
                
            } catch (error) {
                showStatus('Erreur : JSON invalide', 'error');
            }
        }
        
        // ✅ NOUVEAU : Télécharger le résultat API comme ZIP complet
        async function downloadAPIResultAsZIP(jsonData, provider, model) {
            if (typeof JSZip === 'undefined') {
                alert('Bibliothèque JSZip non chargée');
                return;
            }
            
            showStatus('Génération du ZIP complet...', 'info');
            
            try {
                const zip = new JSZip();
                const folderName = STATE.fileName.replace(/\.[^/.]+$/, '');
                const folder = zip.folder(folderName);
                
                // 1. knowledge_index.json
                folder.file('knowledge_index.json', JSON.stringify(jsonData, null, 2));
                
                // 2. knowledge.md
                const markdownContent = generateKnowledgeMD(jsonData);
                folder.file('knowledge.md', markdownContent);
                
                // 3. index.html (viewer)
                const htmlContent = generateIndexHTML(jsonData);
                folder.file('index.html', htmlContent);
                
                // 4. README.md
                const readmeContent = `# ${folderName} - Base de Connaissances

## Document
- Nom : ${STATE.fileName}
- Pages : ${STATE.totalPages}
- Taille : ${((STATE.fileSize || 0) / 1024 / 1024).toFixed(2)} MB
- Provider : ${provider}
- Model : ${model}

## Fichiers
- **knowledge_index.json** : Base de connaissances structurée (32 modules)
- **knowledge.md** : Version Markdown lisible
- **index.html** : Viewer HTML interactif
- **README.md** : Ce fichier
- **${STATE.fileName}** : Document original

## Utilisation

### Consulter la base de connaissances
Ouvrez \`index.html\` dans votre navigateur pour une vue interactive.

### Utiliser le JSON
Le fichier \`knowledge_index.json\` contient 32 modules structurés :
- metadata, structure_hierarchique, index_conceptuel
- contenu_enrichi, graphe_connaissances, taxonomie
- semantique, pedagogie, multimodal, evaluation
- et 22 autres modules...

### Lire en Markdown
Le fichier \`knowledge.md\` est une version lisible pour édition.

---
Généré avec **OCR Universel V6.0 ULTIMATE**  
Provider: ${provider} | Model: ${model}  
Date: ${new Date().toLocaleString('fr-FR')}
`;
                folder.file('README.md', readmeContent);
                
                // 5. Document original
                folder.file(STATE.fileName, STATE.file);
                
                // Générer et télécharger le ZIP
                const blob = await zip.generateAsync({
                    type: 'blob',
                    compression: 'DEFLATE',
                    compressionOptions: { level: 6 }
                });
                
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${folderName}_${provider}_complete.zip`;
                a.click();
                URL.revokeObjectURL(url);
                
                showStatus('✅ ZIP complet téléchargé avec succès !', 'success');
                
            } catch (error) {
                console.error('Error creating ZIP:', error);
                showStatus('❌ Erreur lors de la création du ZIP', 'error');
            }
        }
        
        // ══════════════════════════════════════════════════════════════
        // EXPORT ZIP
        // ══════════════════════════════════════════════════════════════
        
        async function downloadZIP() {
            if (typeof JSZip === 'undefined') {
                alert('Bibliothèque JSZip non chargée');
                return;
            }
            
            const zip = new JSZip();
            const merged = mergeAllJSON();
            const folderName = STATE.fileName.replace(/\.[^/.]+$/, '');
            const folder = zip.folder(folderName);
            
            folder.file('knowledge_index.json', JSON.stringify(merged, null, 2));
            folder.file('README.md', generateREADME());
            folder.file(STATE.fileName, STATE.file);
            
            const blob = await zip.generateAsync({type: 'blob'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = folderName + '_OCR_v6.0.zip';
            a.click();
            URL.revokeObjectURL(url);
            
            showStatus('ZIP téléchargé avec succès !', 'success');
            
            showStatistics();
            showExportSection();
        }
        
        function mergeAllJSON() {
            if (STATE.parts.length === 1) return STATE.parts[0].json;
            
            const merged = JSON.parse(JSON.stringify(STATE.parts[0].json));
            
            for (let i = 1; i < STATE.parts.length; i++) {
                const part = STATE.parts[i].json;
                if (part.structure_hierarchique?.sections) {
                    merged.structure_hierarchique.sections.push(...part.structure_hierarchique.sections);
                }
            }
            
            return merged;
        }
        
        function generateREADME() {
            return `# ${STATE.fileName.replace(/\.[^/.]+$/, '')} - Base de Connaissances

## Document
- Nom : ${STATE.fileName}
- Pages : ${STATE.totalPages}
- Format : ${STATE.format} modules
- Plateforme : ${STATE.platform}

## Fichiers
- knowledge_index.json : Base de connaissances structurée
- knowledge.md : Version Markdown lisible
- index.html : Viewer HTML interactif
- README.md : Ce fichier
- ${STATE.fileName} : Document original

Généré avec OCR Universel V6.0 ULTIMATE - API Multi-LLM
`;
        }
        
        // ✅ NOUVEAU : Générer knowledge.md
        function generateKnowledgeMD(jsonData) {
            let md = `# ${STATE.fileName.replace(/\.[^/.]+$/, '')} - Base de Connaissances\n\n`;
            
            md += `## Métadonnées\n`;
            if (jsonData.metadata) {
                md += `- Type: ${jsonData.metadata.type_composition?.join(', ') || 'N/A'}\n`;
                md += `- Format Level: ${jsonData.metadata.format_level || 'N/A'}\n`;
            }
            md += `\n`;
            
            md += `## Structure Hiérarchique\n`;
            if (jsonData.structure_hierarchique?.chapitres) {
                md += `### Chapitres\n`;
                jsonData.structure_hierarchique.chapitres.forEach((ch, i) => {
                    md += `${i + 1}. ${ch}\n`;
                });
            }
            md += `\n`;
            
            md += `## Index Conceptuel\n`;
            if (jsonData.index_conceptuel?.mots_clés) {
                md += `### Mots-clés\n`;
                jsonData.index_conceptuel.mots_clés.forEach(kw => {
                    md += `- ${kw}\n`;
                });
            }
            if (jsonData.index_conceptuel?.concepts) {
                md += `\n### Concepts\n`;
                jsonData.index_conceptuel.concepts.forEach(c => {
                    md += `- ${c}\n`;
                });
            }
            md += `\n`;
            
            md += `## Contenu Enrichi\n`;
            if (jsonData.contenu_enrichi?.résumé) {
                md += `### Résumé\n${jsonData.contenu_enrichi.résumé}\n\n`;
            }
            if (jsonData.contenu_enrichi?.analyse) {
                md += `### Analyse\n${jsonData.contenu_enrichi.analyse}\n\n`;
            }
            if (jsonData.contenu_enrichi?.exemples) {
                md += `### Exemples\n`;
                jsonData.contenu_enrichi.exemples.forEach(ex => {
                    md += `- ${ex}\n`;
                });
                md += `\n`;
            }
            
            md += `## Graphe de Connaissances\n`;
            if (jsonData.graphe_connaissances?.nœuds) {
                md += `### Nœuds\n`;
                jsonData.graphe_connaissances.nœuds.forEach(n => {
                    md += `- ${n}\n`;
                });
            }
            md += `\n`;
            
            md += `## Taxonomie\n`;
            if (jsonData.taxonomie) {
                md += `- Domaine: ${jsonData.taxonomie.domaine || 'N/A'}\n`;
                md += `- Sous-domaine: ${jsonData.taxonomie.sous_domaine || 'N/A'}\n`;
            }
            md += `\n`;
            
            md += `## Glossaire\n`;
            if (jsonData.glossaire?.termes) {
                jsonData.glossaire.termes.forEach((terme, i) => {
                    const def = jsonData.glossaire.définitions?.[i] || 'N/A';
                    md += `### ${terme}\n${def}\n\n`;
                });
            }
            
            md += `## Références\n`;
            if (jsonData.references?.livres) {
                md += `### Livres\n`;
                jsonData.references.livres.forEach(l => {
                    md += `- ${l}\n`;
                });
            }
            if (jsonData.references?.articles) {
                md += `\n### Articles\n`;
                jsonData.references.articles.forEach(a => {
                    md += `- ${a}\n`;
                });
            }
            md += `\n`;
            
            md += `---\n\n*Généré avec OCR Universel V6.0 ULTIMATE*\n`;
            
            return md;
        }
        
        // ✅ NOUVEAU : Générer index.html viewer
        function generateIndexHTML(jsonData) {
            const fileName = STATE.fileName.replace(/\.[^/.]+$/, '');
            return `<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${fileName} - Knowledge Viewer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        h1 { 
            color: #667eea;
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        h2 { 
            color: #764ba2;
            font-size: 1.8em;
            margin-top: 30px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }
        h3 { 
            color: #667eea;
            font-size: 1.3em;
            margin-top: 20px;
            margin-bottom: 10px;
        }
        .metadata {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .metadata-item {
            display: inline-block;
            margin-right: 30px;
            margin-bottom: 10px;
        }
        .metadata-label {
            font-weight: 600;
            color: #666;
        }
        .metadata-value {
            color: #333;
        }
        .tag {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            margin: 5px;
            font-size: 0.9em;
        }
        .card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #667eea;
        }
        ul { 
            list-style: none;
            padding-left: 0;
        }
        li {
            padding: 8px 0;
            padding-left: 25px;
            position: relative;
        }
        li:before {
            content: "▸";
            position: absolute;
            left: 0;
            color: #667eea;
            font-weight: bold;
        }
        .footer {
            text-align: center;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
            color: #666;
            font-size: 0.9em;
        }
        pre {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>📚 ${fileName}</h1>
        <p style="color: #666; font-size: 1.1em; margin-bottom: 20px;">Base de connaissances enrichie</p>
        
        <div class="metadata">
            <div class="metadata-item">
                <span class="metadata-label">Type:</span>
                <span class="metadata-value">${jsonData.metadata?.type_composition?.join(', ') || 'N/A'}</span>
            </div>
            <div class="metadata-item">
                <span class="metadata-label">Format:</span>
                <span class="metadata-value">${jsonData.metadata?.format_level || 'N/A'} modules</span>
            </div>
            <div class="metadata-item">
                <span class="metadata-label">Domaine:</span>
                <span class="metadata-value">${jsonData.taxonomie?.domaine || 'N/A'}</span>
            </div>
        </div>
        
        ${jsonData.structure_hierarchique?.chapitres ? `
        <h2>📖 Structure</h2>
        <div class="card">
            <h3>Chapitres</h3>
            <ul>
                ${jsonData.structure_hierarchique.chapitres.map(ch => `<li>${ch}</li>`).join('')}
            </ul>
        </div>
        ` : ''}
        
        ${jsonData.index_conceptuel?.mots_clés ? `
        <h2>🏷️ Mots-clés</h2>
        <div>
            ${jsonData.index_conceptuel.mots_clés.map(kw => `<span class="tag">${kw}</span>`).join('')}
        </div>
        ` : ''}
        
        ${jsonData.contenu_enrichi?.résumé ? `
        <h2>📝 Résumé</h2>
        <div class="card">
            ${jsonData.contenu_enrichi.résumé}
        </div>
        ` : ''}
        
        ${jsonData.contenu_enrichi?.analyse ? `
        <h2>🔍 Analyse</h2>
        <div class="card">
            ${jsonData.contenu_enrichi.analyse}
        </div>
        ` : ''}
        
        ${jsonData.glossaire?.termes ? `
        <h2>📚 Glossaire</h2>
        ${jsonData.glossaire.termes.map((terme, i) => `
            <div class="card">
                <h3>${terme}</h3>
                <p>${jsonData.glossaire.définitions?.[i] || 'N/A'}</p>
            </div>
        `).join('')}
        ` : ''}
        
        <h2>🗂️ Données complètes (JSON)</h2>
        <pre>${JSON.stringify(jsonData, null, 2)}</pre>
        
        <div class="footer">
            <p>Généré avec <strong>OCR Universel V6.0 ULTIMATE</strong></p>
            <p>Multi-LLM API Manager | Format 32 modules</p>
        </div>
    </div>
</body>
</html>`;
        }
        
        // ══════════════════════════════════════════════════════════════
        // STATISTICS
        // ══════════════════════════════════════════════════════════════
        
        function showStatistics() {
            const stats = {
                totalPages: STATE.totalPages,
                totalWords: STATE.extractedText ? STATE.extractedText.split(/\s+/).length : 0,
                avgConfidence: STATE.analysis?.technical?.ocr_confidence || 1.0,
                processingTime: STATE.startTime ? (Date.now() - STATE.startTime) / 1000 : 0,
                format: STATE.fileType.toUpperCase(),
                size: (STATE.fileSize / 1024 / 1024).toFixed(2) + ' MB'
            };
            
            const statsGrid = document.getElementById('statsGrid');
            statsGrid.innerHTML = `
                <div class="stat-card">
                    <div class="stat-value">${stats.totalPages}</div>
                    <div class="stat-label">Pages</div>
                </div>
                <div class="stat-card" style="background:linear-gradient(135deg, #11998e, #38ef7d);">
                    <div class="stat-value">${stats.totalWords.toLocaleString()}</div>
                    <div class="stat-label">Mots extraits</div>
                </div>
                <div class="stat-card" style="background:linear-gradient(135deg, #ee0979, #ff6a00);">
                    <div class="stat-value">${Math.round(stats.avgConfidence * 100)}%</div>
                    <div class="stat-label">Confiance</div>
                </div>
                <div class="stat-card" style="background:linear-gradient(135deg, #4568dc, #b06ab3);">
                    <div class="stat-value">${Math.round(stats.processingTime)}s</div>
                    <div class="stat-label">Temps</div>
                </div>
                <div class="stat-card" style="background:linear-gradient(135deg, #f093fb, #f5576c);">
                    <div class="stat-value">${stats.format}</div>
                    <div class="stat-label">Format</div>
                </div>
                <div class="stat-card" style="background:linear-gradient(135deg, #4facfe, #00f2fe);">
                    <div class="stat-value">${stats.size}</div>
                    <div class="stat-label">Taille</div>
                </div>
            `;
            
            document.getElementById('statsSection').style.display = 'block';
            document.getElementById('statsSection').scrollIntoView({ behavior: 'smooth' });
        }
        
        // ══════════════════════════════════════════════════════════════
        // API V6.0 - INTERFACE 3 MODES
        // ══════════════════════════════════════════════════════════════
        
        function openPromptModal() {
            if (!STATE.batch || !STATE.batch.consolidatedResults || STATE.batch.consolidatedResults.length === 0) {
                showStatus('Aucun document traité. Lancez d\'abord le batch processing.', 'error');
                return;
            }
            
            document.getElementById('promptModal').style.display = 'block';
            selectMode('manual'); // Mode Manuel par défaut
        }
        
        function closePromptModal() {
            document.getElementById('promptModal').style.display = 'none';
        }
        
        // ══════════════════════════════════════════════════════════════
        // SYSTÈME DE TABS MODERNES + SMOOTH SCROLLING
        // ══════════════════════════════════════════════════════════════
        
        // ✅ Fonction switchModeTab déplacée plus bas (ligne ~8885)
        
        // ✅ SMOOTH SCROLL INTELLIGENT
        function smoothScrollToElement(element, offset = -20) {
            if (!element) return;
            
            const elementPosition = element.getBoundingClientRect().top;
            const offsetPosition = elementPosition + window.pageYOffset + offset;
            
            window.scrollTo({
                top: offsetPosition,
                behavior: 'smooth'
            });
            
            // Highlight temporaire
            highlightElement(element);
        }
        
        // ✅ HIGHLIGHT TEMPORAIRE
        function highlightElement(element) {
            if (!element) return;
            
            // Ajouter la class highlight
            element.classList.add('highlight-flash');
            
            // Retirer après 2 secondes
            setTimeout(() => {
                element.classList.remove('highlight-flash');
            }, 2000);
        }
        
        // ✅ SCROLL APRÈS UPLOAD PDF
        function scrollToProcessingSection() {
            const section = document.getElementById('processingSection') || 
                           document.querySelector('.processing-status');
            if (section) {
                setTimeout(() => {
                    smoothScrollToElement(section, -100);
                }, 500);
            }
        }
        
        // ✅ SCROLL APRÈS SÉLECTION PROVIDER
        function scrollToProviderConfig() {
            const config = document.getElementById('providerConfig');
            if (config && config.style.display !== 'none') {
                setTimeout(() => {
                    smoothScrollTo('providerConfig');
                }, 300);
            }
        }
        
        // ✅ SCROLL VERS DOCUMENT ACTIF EN BATCH
        function scrollToActiveDocument(documentIndex) {
            // Utiliser la nouvelle fonction
            scrollToBatchDocument(documentIndex);
        }
        
        // Fonction obsolète, gardée pour compatibilité
        function smoothScrollToElement(element) {
            if (element) {
                element.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }
        
        // ✅ SCROLL VERS MODALE (CENTRE DE L'ÉCRAN)
        function centerModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal && modal.style.display !== 'none') {
                const modalContent = modal.querySelector('.modal-content, .api-result-content');
                if (modalContent) {
                    // Centre la modale verticalement
                    setTimeout(() => {
                        modalContent.scrollIntoView({ 
                            behavior: 'smooth', 
                            block: 'center' 
                        });
                        highlightElement(modalContent);
                    }, 100);
                }
            }
        }
        
        // ══════════════════════════════════════════════════════════════
        // ANCIENNE FONCTION selectMode (compatibilité)
        // ══════════════════════════════════════════════════════════════
        
        function selectMode(modeName) {
            // Rediriger vers la nouvelle fonction
            switchModeTab(modeName);
        }
        
        // ═══ MODE 2: USER KEYS - PROVIDER SELECTION ═══
        
        function selectProvider(providerId) {
            console.log('[DEBUG] selectProvider called with:', providerId);
            
            // Désélectionner toutes les cartes
            document.querySelectorAll('.provider-card').forEach(card => {
                card.classList.remove('selected');
            });
            
            // Sélectionner la carte cliquée
            const selectedCard = document.querySelector(`[data-provider="${providerId}"]`);
            if (selectedCard) {
                selectedCard.classList.add('selected');
                console.log('[DEBUG] Card selected:', providerId);
            } else {
                console.error('[DEBUG] Card not found for:', providerId);
            }
            
            // Mettre à jour la config
            const providerNames = {
                'anthropic': 'Anthropic Claude',
                'openai': 'OpenAI GPT',
                'google': 'Google Gemini',
                'deepseek': 'DeepSeek',
                'groq': 'Groq'
            };
            
            // Remplir les modèles
            const models = {
                'anthropic': [
                    { value: 'claude-sonnet-4-20250514', label: 'Claude Sonnet 4 (Recommandé)' },
                    { value: 'claude-opus-4-20250514', label: 'Claude Opus 4 (Premium)' },
                    { value: 'claude-haiku-4.5-20250514', label: 'Claude Haiku 4.5 (Rapide)' }
                ],
                'openai': [
                    { value: 'gpt-4o', label: 'GPT-4o' },
                    { value: 'gpt-4o-mini', label: 'GPT-4o Mini' },
                    { value: 'o1', label: 'o1 (Raisonnement)' }
                ],
                'google': [
                    { value: 'gemini-1.5-pro', label: 'Gemini 1.5 Pro' },
                    { value: 'gemini-1.5-flash', label: 'Gemini 1.5 Flash' }
                ],
                'deepseek': [
                    { value: 'deepseek-chat', label: 'DeepSeek-V3 (Recommandé - $0.27/M)' },
                    { value: 'deepseek-reasoner', label: 'DeepSeek-R1 (Raisonnement - $0.55/M)' }
                ],
                'groq': [
                    { value: 'llama-3.3-70b-versatile', label: 'Llama 3.3 70B (GRATUIT) 🎁' },
                    { value: 'llama-3.1-70b-versatile', label: 'Llama 3.1 70B (GRATUIT) 🎁' },
                    { value: 'mixtral-8x7b-32768', label: 'Mixtral 8x7B (GRATUIT) 🎁' }
                ]
            };
            
            const placeholders = {
                'anthropic': 'sk-ant-api03-...',
                'openai': 'sk-...',
                'google': 'AIza...',
                'deepseek': 'sk-...',
                'groq': 'gsk_...'
            };
            
            const labels = {
                'anthropic': 'Clé API Anthropic:',
                'openai': 'Clé API OpenAI:',
                'google': 'Clé API Google:',
                'deepseek': 'Clé API DeepSeek:',
                'groq': 'Clé API Groq:'
            };
            
            const modelSelect = document.getElementById('userModel');
            modelSelect.innerHTML = '';
            models[providerId].forEach(model => {
                const option = document.createElement('option');
                option.value = model.value;
                option.textContent = model.label;
                modelSelect.appendChild(option);
            });
            console.log('[DEBUG] Models populated:', models[providerId].length, 'models');
            
            document.getElementById('userKeyLabel').textContent = labels[providerId];
            document.getElementById('userApiKey').placeholder = placeholders[providerId];
            document.getElementById('userApiKey').value = '';
            
            // Afficher la config
            document.getElementById('providerConfig').style.display = 'block';
            console.log('[DEBUG] Provider config displayed');
            
            // ✅ SCROLL AUTOMATIQUE VERS CONFIG
            scrollToProviderConfig();
            
            // Sauvegarder le provider sélectionné
            STATE.selectedProvider = providerId;
            console.log('[DEBUG] STATE.selectedProvider set to:', STATE.selectedProvider);
            
            // Calculer le coût
            updateUserCost();
            
            showStatus(`✅ ${providerNames[providerId]} sélectionné`, 'success');
            console.log('[DEBUG] Status shown:', `${providerNames[providerId]} sélectionné`);
        }
        
        // ══════════════════════════════════════════════════════════════
        // NOUVEAU SYSTÈME ACCORDÉON
        // ══════════════════════════════════════════════════════════════
        
        function toggleProviderAccordion(providerId) {
            console.log(`[ACCORDION] Toggling: ${providerId}`);
            
            // Fermer tous les autres accordéons
            document.querySelectorAll('.provider-accordion').forEach(acc => {
                if (acc.dataset.provider !== providerId) {
                    acc.classList.remove('active');
                    const content = acc.querySelector('.accordion-content');
                    if (content) content.style.display = 'none';
                }
            });
            
            // Toggle l'accordéon cliqué
            const accordion = document.querySelector(`.provider-accordion[data-provider="${providerId}"]`);
            const content = document.getElementById(`config-${providerId}`);
            
            if (accordion && content) {
                const isActive = accordion.classList.contains('active');
                
                if (isActive) {
                    // Fermer
                    accordion.classList.remove('active');
                    content.style.display = 'none';
                    console.log(`[ACCORDION] Closed: ${providerId}`);
                } else {
                    // Ouvrir
                    accordion.classList.add('active');
                    content.style.display = 'block';
                    console.log(`[ACCORDION] Opened: ${providerId}`);
                    
                    // Charger la clé sauvegardée si elle existe
                    const savedKey = multiLLM.getUserKey(providerId);
                    if (savedKey) {
                        document.getElementById(`key-${providerId}`).value = '••••••••••••••••';
                    }
                    
                    // Calculer le coût
                    updateProviderCost(providerId);
                    
                    // Scroll smooth vers l'accordéon
                    setTimeout(() => {
                        accordion.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }, 100);
                }
            }
        }
        
        function saveProviderKey(providerId) {
            console.log(`[SAVE] Saving key for: ${providerId}`);
            
            const keyInput = document.getElementById(`key-${providerId}`);
            const modelSelect = document.getElementById(`model-${providerId}`);
            
            if (!keyInput || !modelSelect) {
                console.error(`[SAVE] Missing inputs for ${providerId}`);
                return;
            }
            
            const apiKey = keyInput.value.trim();
            const model = modelSelect.value;
            
            // Vérifier si la clé est déjà masquée
            if (apiKey.startsWith('••••')) {
                showStatus('ℹ️ Clé déjà sauvegardée', 'info');
                return;
            }
            
            if (!apiKey) {
                showStatus('❌ Veuillez entrer une clé API', 'error');
                return;
            }
            
            // Sauvegarder via multiLLM
            const success = multiLLM.setUserKey(providerId, apiKey, model);
            
            if (success) {
                // Masquer la clé
                keyInput.value = '••••••••••••••••';
                showStatus(`✅ Clé ${providerId} sauvegardée`, 'success');
                
                // Afficher Quick Actions
                document.getElementById('apiQuickActions').style.display = 'block';
                
                console.log(`[SAVE] Key saved successfully for ${providerId}`);
            } else {
                showStatus('❌ Erreur de sauvegarde', 'error');
            }
        }
        
        function updateProviderCost(providerId) {
            const modelSelect = document.getElementById(`model-${providerId}`);
            if (!modelSelect) return;
            
            const model = modelSelect.value;
            
            // Prix par provider/model (input/output per 1M tokens)
            const pricing = {
                'deepseek': {
                    'deepseek-chat': { input: 0.27, output: 1.10 },
                    'deepseek-reasoner': { input: 0.55, output: 2.19 }
                },
                'groq': {
                    'llama-3.3-70b-versatile': { input: 0, output: 0 },
                    'llama-3.1-70b-versatile': { input: 0, output: 0 },
                    'mixtral-8x7b-32768': { input: 0, output: 0 }
                },
                'anthropic': {
                    'claude-sonnet-4-20250514': { input: 3.00, output: 15.00 },
                    'claude-opus-4-20250514': { input: 15.00, output: 75.00 },
                    'claude-haiku-4.5-20250514': { input: 1.00, output: 5.00 }
                },
                'openai': {
                    'gpt-4o': { input: 2.50, output: 10.00 },
                    'gpt-4o-mini': { input: 0.15, output: 0.60 },
                    'o1': { input: 15.00, output: 60.00 }
                },
                'google': {
                    'gemini-2.0-flash-exp': { input: 0, output: 0 },
                    'gemini-1.5-pro': { input: 1.25, output: 5.00 }
                }
            };
            
            const price = pricing[providerId]?.[model] || { input: 0, output: 0 };
            
            // Calcul pour 50K input, 4K output
            const inputCost = (50 / 1000) * price.input;
            const outputCost = (4 / 1000) * price.output;
            const totalCost = inputCost + outputCost;
            
            // Mise à jour de l'affichage
            document.getElementById(`cost-input-${providerId}`).textContent = `$${inputCost.toFixed(4)}`;
            document.getElementById(`cost-output-${providerId}`).textContent = `$${outputCost.toFixed(4)}`;
            document.getElementById(`cost-total-${providerId}`).textContent = `$${totalCost.toFixed(4)}`;
        }
        
        function updateUserModels() {
            // Fonction maintenue pour compatibilité mais obsolète
            // La sélection se fait désormais via selectProvider()
        }
        
        function updateUserCost() {
            if (!STATE.selectedProvider) return;
            
            const provider = STATE.selectedProvider;
            const model = document.getElementById('userModel').value;
            
            // Estimation pour un document OCR moyen
            const inputTokens = 50000;
            const outputTokens = 4000;
            
            const estimate = multiLLM.estimateCost(provider, model, inputTokens, outputTokens);
            
            document.getElementById('costInput').textContent = `$${estimate.breakdown.input}`;
            document.getElementById('costOutput').textContent = `$${estimate.breakdown.output}`;
            document.getElementById('costTotal').textContent = `$${estimate.cost}`;
        }
        
        // ════════════════════════════════════════════════════════════
        // V6.3.0 - GESTION SÉCURITÉ & LIMITES
        // ════════════════════════════════════════════════════════════
        
        function showSecurityWarning() {
            const warning = document.getElementById('securityWarning');
            if (warning && !localStorage.getItem('securityWarningAccepted')) {
                warning.classList.add('visible');
            }
        }
        
        function acceptSecurityWarning() {
            const warning = document.getElementById('securityWarning');
            if (warning) {
                warning.classList.remove('visible');
                localStorage.setItem('securityWarningAccepted', 'true');
                console.log('[SECURITY] User accepted security warning');
            }
        }
        
        function learnMoreSecurity() {
            alert(`DÉTAILS TECHNIQUES SUR LA SÉCURITÉ

MODE USER KEYS :
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
• Stockage : localStorage du navigateur (non chiffré)
• Obfuscation : XOR simple avec clé statique
• Protection : Aucune encryption forte
• Exposition : Code JavaScript peut accéder aux clés

RISQUES :
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⚠️ Toute extension malveillante peut lire les clés
⚠️ XOR est facilement réversible
⚠️ Les clés transitent en clair dans le navigateur
⚠️ Pas de protection contre l'inspection réseau

RECOMMANDATIONS :
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✅ Mode Worker : clés sécurisées côté serveur
✅ Usage limité : tests & développement uniquement
✅ Jamais en production avec données sensibles
✅ Créez des clés API dédiées avec quotas limités

Pour plus d'infos : https://docs.anthropic.com/en/api/security`);
        }
        
        // Afficher l'avertissement au chargement du Mode 2
        window.addEventListener('load', () => {
            // Vérifier si on est en Mode 2 (user-keys)
            const mode2Radio = document.querySelector('input[value="user-keys"]');
            if (mode2Radio) {
                mode2Radio.addEventListener('change', function() {
                    if (this.checked && !localStorage.getItem('securityWarningAccepted')) {
                        setTimeout(showSecurityWarning, 300);
                    }
                });
            }
        });
        
        // ════════════════════════════════════════════════════════════
        
        function saveUserKey() {
            console.log('[DEBUG] saveUserKey called');
            
            const provider = STATE.selectedProvider;
            console.log('[DEBUG] provider:', provider);
            
            const key = document.getElementById('userApiKey').value.trim();
            console.log('[DEBUG] key length:', key.length);
            console.log('[DEBUG] key starts with:', key.substring(0, 4));
            
            if (!provider) {
                console.error('[DEBUG] No provider selected!');
                showStatus('Sélectionnez d\'abord un provider', 'error');
                return;
            }
            
            if (!key) {
                console.error('[DEBUG] Empty key!');
                showStatus('Clé API vide', 'error');
                return;
            }
            
            // Si le champ contient des points, la clé est déjà sauvegardée
            if (key.startsWith('••••')) {
                console.log('[DEBUG] Key already saved (dots detected)');
                showStatus(`✅ Clé ${provider} déjà sauvegardée !`, 'info');
                return;
            }
            
            console.log('[DEBUG] Calling multiLLM.setUserKey...');
            const result = multiLLM.setUserKey(provider, key);
            console.log('[DEBUG] setUserKey result:', result);
            
            if (result) {
                console.log('[DEBUG] Key saved successfully!');
                showStatus(`✅ Clé ${provider} sauvegardée avec succès !`, 'success');
                document.getElementById('userApiKey').value = '••••••••••••••••';
                
                // Changer le texte du bouton
                const saveBtn = document.getElementById('saveKeyButton');
                if (saveBtn) {
                    const originalText = saveBtn.innerHTML;
                    saveBtn.innerHTML = '✅ Clé sauvegardée';
                    saveBtn.style.background = '#4CAF50';
                    
                    // Réactiver après 3 secondes
                    setTimeout(() => {
                        saveBtn.innerHTML = originalText;
                        saveBtn.style.background = 'linear-gradient(135deg, #FFD700, #FFA500)';
                    }, 3000);
                }
            } else {
                console.error('[DEBUG] Invalid key format!');
                showStatus(`❌ Format de clé ${provider} invalide`, 'error');
            }
        }
        
        async function sendWithUserKeys() {
            const provider = STATE.selectedProvider;
            const model = document.getElementById('userModel').value;
            
            if (!provider) {
                showStatus('Sélectionnez d\'abord un provider', 'error');
                return;
            }
            
            const maxTokens = 4096;  // Fixed for OCR
            const temperature = 0.3;  // Fixed for OCR
            
            const consolidatedPrompt = generateConsolidatedPrompt();
            
            const progress = document.getElementById('apiProgress');
            progress.style.display = 'block';
            const progressFill = document.getElementById('apiProgressFill');
            const progressText = document.getElementById('apiProgressText');
            
            progressFill.style.width = '20%';
            progressText.textContent = 'Envoi...';
            
            try {
                const startTime = Date.now();
                
                progressFill.style.width = '40%';
                progressText.textContent = 'Traitement...';
                
                const response = await multiLLM.sendPrompt(consolidatedPrompt, {
                    provider,
                    model,
                    max_tokens: maxTokens,
                    temperature
                });
                
                const duration = ((Date.now() - startTime) / 1000).toFixed(1);
                
                progressFill.style.width = '100%';
                progressText.textContent = 'Terminé !';
                
                const cost = multiLLM.estimateCost(
                    provider,
                    model,
                    response.usage?.input_tokens || 50000,
                    response.usage?.output_tokens || 4000
                );
                
                showAPIResult(response, { provider, model, duration, cost });
                
                setTimeout(() => {
                    progress.style.display = 'none';
                }, 2000);
                
            } catch (error) {
                console.error('API Error:', error);
                showStatus('Erreur API : ' + error.message, 'error');
                progress.style.display = 'none';
            }
        }
        
        // ═══ SINGLE FILE API ═══
        // ✅ SYSTÈME DE FALLBACK INTELLIGENT
        const MODEL_FALLBACKS = {
            'groq': [
                'llama-3.3-70b-versatile',
                'llama-3.1-70b-versatile',
                'llama3-70b-8192',
                'mixtral-8x7b-32768',
                'llama-3.3-70b-8192'
            ],
            'deepseek': [
                'deepseek-chat',
                'deepseek-coder',
                'deepseek-v3'
            ],
            'anthropic': [
                'claude-sonnet-4-20250514',
                'claude-4-20250514',
                'claude-opus-4-20250514',
                'claude-3-5-sonnet-20241022',
                'claude-3-5-sonnet-20240620'
            ],
            'openai': [
                'gpt-4o',
                'gpt-4o-2024-11-20',
                'gpt-4o-mini',
                'gpt-4-turbo',
                'gpt-4'
            ],
            'google': [
                'gemini-2.0-flash-exp',
                'gemini-1.5-pro',
                'gemini-1.5-flash'
            ]
        };
        
        // ✅ RÉCUPÉRATION DYNAMIQUE DES MODÈLES DISPONIBLES
        async function fetchAvailableModels(provider) {
            const apiKey = multiLLM.xorDecrypt(multiLLM.userKeys[provider], 'ocr-v6-secret-2025');
            if (!apiKey) return null;
            
            try {
                const endpoints = {
                    'openai': 'https://api.openai.com/v1/models',
                    'anthropic': null,  // Anthropic n'a pas d'endpoint /models
                    'groq': 'https://api.groq.com/openai/v1/models'
                };
                
                const endpoint = endpoints[provider];
                if (!endpoint) return null;
                
                const response = await fetch(endpoint, {
                    headers: {
                        'Authorization': `Bearer ${apiKey}`
                    }
                });
                
                if (!response.ok) return null;
                
                const data = await response.json();
                const models = data.data?.map(m => m.id) || [];
                
                console.log(`[DEBUG] Available ${provider} models:`, models);
                return models;
                
            } catch (error) {
                console.error(`[DEBUG] Failed to fetch ${provider} models:`, error);
                return null;
            }
        }
        
        async function sendSingleFileToAPI(provider, model) {
            console.log('[DEBUG] sendSingleFileToAPI called');
            console.log('[DEBUG] provider:', provider);
            console.log('[DEBUG] model:', model);
            console.log('[DEBUG] STATE.file:', STATE.file?.name);
            console.log('[DEBUG] STATE.extractedText length:', STATE.extractedText?.length);
            console.log('[DEBUG] STATE.detectionResult:', STATE.detectionResult);
            console.log('[DEBUG] STATE.documentType:', STATE.documentType);
            
            // Vérifier que le fichier est chargé
            if (!STATE.file) {
                console.error('[DEBUG] No file in STATE');
                showStatus('⚠️ Veuillez d\'abord uploader un fichier', 'error');
                return;
            }
            
            // Si extractedText n'existe pas, essayer de le récupérer depuis detectionResult
            if (!STATE.extractedText && STATE.detectionResult?.extracted?.text) {
                console.log('[DEBUG] Recovering extractedText from detectionResult');
                STATE.extractedText = STATE.detectionResult.extracted.text;
            }
            
            if (!STATE.extractedText) {
                console.error('[DEBUG] No extractedText in STATE');
                showStatus('⚠️ Le texte n\'a pas été extrait. Réessayez d\'uploader le fichier.', 'error');
                return;
            }
            
            // Vérifier que la clé existe
            const encryptedKey = multiLLM.userKeys[provider];
            console.log('[DEBUG] encryptedKey exists:', !!encryptedKey);
            
            if (!encryptedKey) {
                console.error('[DEBUG] No key for provider:', provider);
                showStatus(`⚠️ Clé ${provider} non configurée. Allez dans MODE 2 pour configurer.`, 'error');
                // Scroll vers le mode 2
                const panel = document.getElementById('panelUserKeys');
                if (panel) panel.scrollIntoView({ behavior: 'smooth' });
                return;
            }
            
            showStatus(`🚀 Envoi à ${provider}...`, 'info');
            console.log('[DEBUG] Starting API call...');
            
            try {
                // Générer le prompt pour ce fichier
                console.log('[DEBUG] Generating prompt...');
                const prompt = generatePrompt({
                    file: STATE.file,
                    fileName: STATE.fileName,
                    fileType: STATE.fileType,
                    extractedText: STATE.extractedText,
                    totalPages: STATE.totalPages,
                    detectionResult: STATE.detectionResult,
                    documentType: STATE.documentType,
                    analysis: STATE.analysis
                });
                
                console.log('[DEBUG] Prompt length:', prompt.length);
                
                const startTime = Date.now();
                
                // ✅ SYSTÈME DE FALLBACK AUTOMATIQUE
                let response;
                let actualModel = model;
                let fallbackUsed = false;
                
                // Essayer le modèle demandé
                console.log('[DEBUG] Calling multiLLM.sendPrompt...');
                try {
                    response = await multiLLM.sendPrompt(prompt, {
                        provider,
                        model,
                        max_tokens: 4096,
                        temperature: 0.3
                    });
                    console.log('[DEBUG] API response received');
                } catch (error) {
                    console.log('[DEBUG] Primary model failed:', error.message);
                    
                    // Si erreur model not found, essayer les fallbacks
                    if (error.message.includes('model') && error.message.includes('not') && MODEL_FALLBACKS[provider]) {
                        console.log('[DEBUG] Trying fallback models...');
                        const fallbacks = MODEL_FALLBACKS[provider].filter(m => m !== model);
                        
                        for (const fallbackModel of fallbacks) {
                            try {
                                console.log(`[DEBUG] Trying fallback: ${fallbackModel}`);
                                response = await multiLLM.sendPrompt(prompt, {
                                    provider,
                                    model: fallbackModel,
                                    max_tokens: 4096,
                                    temperature: 0.3
                                });
                                
                                actualModel = fallbackModel;
                                fallbackUsed = true;
                                console.log(`[DEBUG] ✅ Fallback successful with ${fallbackModel}`);
                                
                                showStatus(`⚠️ Modèle ${model} non disponible, utilisation de ${fallbackModel}`, 'warning');
                                
                                break;
                            } catch (fallbackError) {
                                console.log(`[DEBUG] Fallback ${fallbackModel} failed:`, fallbackError.message);
                                continue;
                            }
                        }
                        
                        // Si tous les fallbacks ont échoué
                        if (!response) {
                            throw new Error(`Tous les modèles ${provider} ont échoué. Le provider a peut-être changé ses modèles. Vérifiez la documentation à jour.`);
                        }
                    } else {
                        // Erreur non liée au modèle, re-throw
                        throw error;
                    }
                }
                
                console.log('[DEBUG] API response received');
                
                const duration = ((Date.now() - startTime) / 1000).toFixed(1);
                
                // Calculer le coût avec le modèle réellement utilisé
                const cost = multiLLM.estimateCost(
                    provider,
                    actualModel,  // ✅ Utiliser actualModel
                    response.usage?.input_tokens || 50000,
                    response.usage?.output_tokens || 4000
                );
                
                console.log('[DEBUG] Cost:', cost);
                console.log('[DEBUG] Model used:', actualModel, fallbackUsed ? '(fallback)' : '(primary)');
                
                // Sauvegarder dans STATE
                STATE.analysis = response.json;
                
                // Afficher le résultat avec le bon modèle
                console.log('[DEBUG] Displaying result...');
                displaySingleFileAPIResult(response, { 
                    provider, 
                    model: actualModel,  // ✅ Afficher actualModel
                    duration, 
                    cost 
                });
                
                // Message adapté selon si fallback utilisé
                const statusMsg = fallbackUsed 
                    ? `✅ Analyse ${provider} terminée en ${duration}s (modèle ${actualModel}) !`
                    : `✅ Analyse ${provider} terminée en ${duration}s !`;
                
                showStatus(statusMsg, 'success');
                
            } catch (error) {
                console.error('[DEBUG] API Error:', error);
                console.error('Single File API Error:', error);
                showStatus(`❌ Erreur ${provider}: ${error.message}`, 'error');
            }
        }
        
        function displaySingleFileAPIResult(response, metadata) {
            const { provider, model, duration, cost } = metadata;
            
            // ✅ STOCKER dans STATE au lieu d'embedder dans onclick
            STATE.lastAPIResult = response.json || response.text;
            
            // Créer une modale pour afficher le résultat
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.7);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                padding: 20px;
            `;
            
            const providerIcons = {
                'groq': '⚡',
                'deepseek': '💰',
                'anthropic': '🤖',
                'openai': '🟢',
                'google': '🔷'
            };
            
            const providerNames = {
                'groq': 'Groq',
                'deepseek': 'DeepSeek',
                'anthropic': 'Anthropic Claude',
                'openai': 'OpenAI GPT',
                'google': 'Google Gemini'
            };
            
            const jsonString = JSON.stringify(STATE.lastAPIResult, null, 2);
            
            modal.innerHTML = `
                <div style="background:white;border-radius:16px;max-width:900px;width:100%;max-height:90vh;overflow-y:auto;padding:30px;box-shadow:0 10px 40px rgba(0,0,0,0.3);">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;">
                        <h2 style="margin:0;color:var(--noir-principal);">${providerIcons[provider]} Résultat ${providerNames[provider]}</h2>
                        <button onclick="this.closest('div[style*=fixed]').remove()" style="background:none;border:none;font-size:28px;cursor:pointer;color:var(--gris-secondaire);">×</button>
                    </div>
                    
                    <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:15px;margin-bottom:20px;">
                        <div style="padding:15px;background:#E3F2FD;border-radius:8px;">
                            <div style="font-size:0.85em;color:var(--gris-secondaire);">Provider</div>
                            <div style="font-weight:600;color:var(--noir-principal);">${providerNames[provider]}</div>
                        </div>
                        <div style="padding:15px;background:#E8F5E9;border-radius:8px;">
                            <div style="font-size:0.85em;color:var(--gris-secondaire);">Modèle</div>
                            <div style="font-weight:600;color:var(--noir-principal);">${model}</div>
                        </div>
                        <div style="padding:15px;background:#FFF3E0;border-radius:8px;">
                            <div style="font-size:0.85em;color:var(--gris-secondaire);">Durée</div>
                            <div style="font-weight:600;color:var(--noir-principal);">${duration}s</div>
                        </div>
                        <div style="padding:15px;background:#E1BEE7;border-radius:8px;">
                            <div style="font-size:0.85em;color:var(--gris-secondaire);">Coût</div>
                            <div style="font-weight:600;color:var(--noir-principal);">$${cost.cost}</div>
                        </div>
                    </div>
                    
                    <div style="background:#F5F5F5;padding:20px;border-radius:8px;margin-bottom:20px;">
                        <h3 style="margin:0 0 10px 0;">📄 Document analysé</h3>
                        <div style="font-size:0.9em;color:var(--gris-secondaire);">${STATE.fileName} (${STATE.fileType.toUpperCase()})</div>
                    </div>
                    
                    <div style="background:#F5F5F5;padding:20px;border-radius:8px;margin-bottom:20px;max-height:400px;overflow-y:auto;">
                        <h3 style="margin:0 0 15px 0;">📊 Résultat JSON</h3>
                        <pre id="jsonResult" style="background:white;padding:15px;border-radius:6px;overflow-x:auto;font-size:0.85em;">${jsonString}</pre>
                    </div>
                    
                    <div style="display:flex;gap:10px;flex-wrap:wrap;">
                        <button id="copyJSONBtn" style="flex:1;min-width:150px;padding:12px;background:var(--mer);color:white;border:none;border-radius:8px;font-weight:600;cursor:pointer;">
                            📋 Copier le JSON
                        </button>
                        <button id="downloadJSONBtn" style="flex:1;min-width:150px;padding:12px;background:var(--accent);color:white;border:none;border-radius:8px;font-weight:600;cursor:pointer;">
                            💾 Télécharger JSON
                        </button>
                        <button id="downloadZIPBtn" style="flex:1;min-width:150px;padding:12px;background:linear-gradient(135deg, #FFD700, #FFA500);color:white;border:none;border-radius:8px;font-weight:600;cursor:pointer;box-shadow:0 4px 15px rgba(255,165,0,0.3);">
                            📦 Télécharger ZIP Complet
                        </button>
                    </div>
                    <div style="margin-top:15px;padding:15px;background:#FFF9E6;border-radius:8px;border-left:4px solid #FFD700;">
                        <p style="margin:0;font-size:0.9em;color:#666;">
                            <strong>📦 ZIP Complet contient :</strong><br>
                            • knowledge_index.json (32 modules)<br>
                            • knowledge.md (version Markdown)<br>
                            • index.html (viewer interactif)<br>
                            • README.md (métadonnées)<br>
                            • ${STATE.fileName} (document original)
                        </p>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // ✅ SCROLL ET HIGHLIGHT
            setTimeout(() => {
                const modalContent = modal.querySelector('div[style*="background:white"]');
                if (modalContent) {
                    highlightElement(modalContent);
                    modalContent.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }, 100);
            
            // ✅ Ajouter event listeners APRÈS l'insertion dans le DOM
            document.getElementById('copyJSONBtn').addEventListener('click', () => {
                navigator.clipboard.writeText(jsonString);
                alert('📋 JSON copié !');
            });
            
            document.getElementById('downloadJSONBtn').addEventListener('click', () => {
                downloadJSON(STATE.lastAPIResult, `${STATE.fileName}_${provider}_analysis.json`);
            });
            
            // ✅ NOUVEAU : Bouton ZIP complet
            document.getElementById('downloadZIPBtn').addEventListener('click', () => {
                downloadAPIResultAsZIP(STATE.lastAPIResult, provider, model);
            });
        }
        
        function downloadJSON(data, filename) {
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // ═══ MODE 3: WORKER ═══
        function toggleWorker() {
            const enabled = document.getElementById('workerEnabled').checked;
            const status = document.getElementById('workerStatus');
            const panel = document.getElementById('workerActivePanel');
            
            if (enabled) {
                status.textContent = 'Mode Worker activé ✅';
                panel.style.display = 'block';
            } else {
                status.textContent = 'Mode Worker désactivé';
                panel.style.display = 'none';
            }
        }
        
        async function sendWithWorker() {
            const model = document.getElementById('workerModel').value;
            const consolidatedPrompt = generateConsolidatedPrompt();
            
            const progress = document.getElementById('apiProgress');
            progress.style.display = 'block';
            const progressFill = document.getElementById('apiProgressFill');
            const progressText = document.getElementById('apiProgressText');
            
            progressFill.style.width = '20%';
            progressText.textContent = 'Envoi au Worker...';
            
            try {
                const startTime = Date.now();
                
                progressFill.style.width = '40%';
                progressText.textContent = 'Traitement par Cloudflare Worker...';
                
                const response = await multiLLM.callViaWorker('anthropic', model, consolidatedPrompt, 4096, 0.3);
                
                const duration = ((Date.now() - startTime) / 1000).toFixed(1);
                
                progressFill.style.width = '100%';
                progressText.textContent = 'Terminé !';
                
                const cost = { cost: '0.00 (gratuit)', breakdown: { input: '0.00', output: '0.00' } };
                
                showAPIResult(response, {
                    provider: 'anthropic',
                    model,
                    duration,
                    cost
                });
                
                setTimeout(() => {
                    progress.style.display = 'none';
                }, 2000);
                
            } catch (error) {
                console.error('Worker Error:', error);
                showStatus('Erreur Worker : ' + error.message, 'error');
                progress.style.display = 'none';
            }
        }
        
        // ═══ LEGACY FUNCTIONS (kept for compatibility) ═══
        function selectStrategy(strategyName) {
            // No longer used but kept for compatibility
        }
        
        function updateAPIMode() {
            // No longer used
        }
        
        function updateModelsList() {
            // No longer used
        }
        
        function updateCostEstimate() {
            const provider = document.getElementById('apiProvider').value;
            const model = document.getElementById('apiModel').value;
            
            // Estimation basée sur 3 documents moyens = ~50K tokens input, ~4K output
            const estimate = multiLLM.estimateCost(provider, model, 50000, 4000);
            
            document.getElementById('costEstimate').innerHTML = `
                Coût estimé : <strong>$${estimate.cost} USD</strong>
                <div style="font-size:0.85em;margin-top:5px;color:#555;">
                    Input: $${estimate.breakdown.input} • Output: $${estimate.breakdown.output}
                </div>
            `;
        }
        
        function saveAPIKey(provider) {
            const input = document.getElementById(`${provider}Key`);
            const key = input.value.trim();
            
            if (!key) {
                showStatus('Clé API vide', 'error');
                return;
            }
            
            if (multiLLM.setUserKey(provider, key)) {
                showStatus(`Clé ${provider} sauvegardée avec succès !`, 'success');
                input.value = '••••••••••••••••';
            } else {
                showStatus(`Format de clé ${provider} invalide`, 'error');
            }
        }
        
        async function sendToAPI() {
            const provider = document.getElementById('apiProvider').value;
            const model = document.getElementById('apiModel').value;
            const maxTokens = parseInt(document.getElementById('apiMaxTokens').value);
            const temperature = parseFloat(document.getElementById('apiTemperature').value);
            
            // Générer le prompt consolidé
            const consolidatedPrompt = generateConsolidatedPrompt();
            
            // Afficher progress
            const progress = document.getElementById('apiProgress');
            progress.classList.add('active');
            
            const progressFill = document.getElementById('apiProgressFill');
            const progressText = document.getElementById('apiProgressText');
            
            progressFill.style.width = '20%';
            progressText.textContent = 'Envoi de la requête...';
            
            try {
                const startTime = Date.now();
                
                progressFill.style.width = '40%';
                progressText.textContent = 'Traitement par l\'API...';
                
                const response = await multiLLM.sendPrompt(consolidatedPrompt, {
                    provider,
                    model,
                    max_tokens: maxTokens,
                    temperature
                });
                
                const duration = ((Date.now() - startTime) / 1000).toFixed(1);
                
                progressFill.style.width = '100%';
                progressText.textContent = 'Terminé !';
                
                // Calculer le coût
                const cost = multiLLM.estimateCost(
                    provider,
                    model,
                    response.usage?.input_tokens || 0,
                    response.usage?.output_tokens || 0
                );
                
                // Afficher le résultat
                showAPIResult(response, {
                    provider,
                    model,
                    duration,
                    cost
                });
                
                setTimeout(() => {
                    progress.classList.remove('active');
                }, 2000);
                
            } catch (error) {
                console.error('API Error:', error);
                showStatus('Erreur API : ' + error.message, 'error');
                progress.classList.remove('active');
            }
        }
        
        function generateConsolidatedPrompt() {
            const results = STATE.batch.consolidatedResults;
            const analysis = STATE.analysis;
            
            let prompt = `# ANALYSE BATCH OCR UNIVERSEL V6.0\n\n`;
            prompt += `**Documents traités :** ${results.length}\n`;
            prompt += `**Type principal :** ${analysis?.composition?.primary || 'text_standard'}\n\n`;
            
            prompt += `## DOCUMENTS\n\n`;
            results.forEach((doc, idx) => {
                prompt += `### Document ${idx + 1}: ${doc.filename}\n`;
                prompt += `**Pages :** ${doc.pages}\n`;
                prompt += `**Mots :** ${doc.wordCount?.toLocaleString() || 'N/A'}\n\n`;
                prompt += `**Contenu :**\n\`\`\`\n${doc.text.substring(0, 5000)}${doc.text.length > 5000 ? '...' : ''}\n\`\`\`\n\n`;
            });
            
            prompt += `\n## INSTRUCTIONS\n\n`;
            prompt += `Analysez ces ${results.length} documents et extrayez les informations structurées au format JSON.\n`;
            prompt += `Respectez la structure adaptée au type de contenu détecté.\n`;
            
            return prompt;
        }
        
        function showAPIResult(response, metadata) {
            const modal = document.getElementById('apiResultModal');
            
            document.getElementById('resultProvider').textContent = metadata.provider.toUpperCase();
            document.getElementById('resultModel').textContent = metadata.model;
            document.getElementById('resultDuration').textContent = metadata.duration + 's';
            document.getElementById('resultCost').textContent = '$' + metadata.cost.cost;
            
            const jsonDisplay = document.getElementById('jsonDisplay');
            if (response.json) {
                jsonDisplay.textContent = JSON.stringify(response.json, null, 2);
            } else {
                jsonDisplay.textContent = response.text;
            }
            
            // Stocker pour téléchargement
            window.currentAPIResult = response;
            
            modal.style.display = 'block';
            
            // ✅ CENTRER LA MODALE ET HIGHLIGHT
            centerModal('apiResultModal');
        }
        
        function closeAPIResult() {
            document.getElementById('apiResultModal').style.display = 'none';
        }
        
        function downloadAPIResult() {
            if (!window.currentAPIResult) return;
            
            const result = window.currentAPIResult.json || { text: window.currentAPIResult.text };
            const blob = new Blob([JSON.stringify(result, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `api_result_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            showStatus('Résultat téléchargé !', 'success');
        }
        
        async function copyAPIResult() {
            if (!window.currentAPIResult) return;
            
            const text = JSON.stringify(window.currentAPIResult.json || window.currentAPIResult.text, null, 2);
            
            try {
                await navigator.clipboard.writeText(text);
                showStatus('Résultat copié !', 'success');
            } catch (error) {
                showStatus('Erreur copie', 'error');
            }
        }
        
        // Stratégies manuelles (existantes)
        
        function copyAllPrompts() {
            const consolidatedPrompt = generateConsolidatedPrompt();
            
            navigator.clipboard.writeText(consolidatedPrompt).then(() => {
                showStatus('Prompt consolidé copié !', 'success');
            }).catch(error => {
                showStatus('Erreur copie', 'error');
            });
        }
        
        function downloadPromptTXT() {
            const consolidatedPrompt = generateConsolidatedPrompt();
            
            const blob = new Blob([consolidatedPrompt], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `prompt_consolidated_${new Date().toISOString().slice(0,10)}.txt`;
            a.click();
            URL.revokeObjectURL(url);
            
            showStatus('Prompt téléchargé !', 'success');
        }
        
        function downloadPromptJSON() {
            const results = STATE.batch.consolidatedResults;
            
            const jsonData = {
                metadata: {
                    generated: new Date().toISOString(),
                    documents_count: results.length,
                    tool: 'OCR Universel V6.0'
                },
                documents: results.map(doc => ({
                    filename: doc.filename,
                    pages: doc.pages,
                    wordCount: doc.wordCount,
                    text: doc.text
                }))
            };
            
            const blob = new Blob([JSON.stringify(jsonData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `prompt_data_${new Date().toISOString().slice(0,10)}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            showStatus('JSON téléchargé !', 'success');
        }

        // ══════════════════════════════════════════════════════════════
        // MODE SELECTION FUNCTIONS
        // ══════════════════════════════════════════════════════════════
        
        // ══════════════════════════════════════════════════════════════
        // FONCTIONS MINIMALISTES
        // ══════════════════════════════════════════════════════════════
        
        /**
         * Switch entre les modes (radio buttons)
         */
        function switchMode(mode) {
            console.log(`[MODE] Switching to: ${mode}`);
            
            // ✅ FERMER TOUS LES ACCORDÉONS ACTIFS
            document.querySelectorAll('.provider-mini.active').forEach(mini => {
                mini.classList.remove('active');
            });
            
            // ✨ SI MODE USER-KEYS : TOGGLE LE PANEL ENTIER
            if (mode === 'user-keys') {
                const panel = document.querySelector(`.mode-panel[data-mode="user-keys"]`);
                
                if (!panel) {
                    console.error('[MODE] Panel user-keys not found!');
                    return;
                }
                
                // ✅ Déclarer isCurrentlyActive ICI, avant utilisation
                const isCurrentlyActive = panel.classList.contains('active');
                
                if (isCurrentlyActive) {
                    // Si actif → cacher
                    panel.classList.remove('active');
                    console.log(`[MODE] Panel REPLIÉ`);
                    
                    // Décocher le radio user-keys et cocher manual
                    const radioManual = document.querySelector('input[name="mode"][value="manual"]');
                    if (radioManual) radioManual.checked = true;
                    
                    STATE.processingMode = 'manual';
                    STATE.mode = 'manual';
                } else {
                    // Si caché → afficher
                    // D'abord cacher tous les autres panels
                    document.querySelectorAll('.mode-panel').forEach(p => {
                        p.classList.remove('active');
                    });
                    // Puis afficher celui-ci
                    panel.classList.add('active');
                    console.log(`[MODE] Panel DÉPLIÉ`);
                    
                    // S'assurer que les accordéons sont visibles
                    document.querySelectorAll('.provider-mini').forEach(mini => {
                        mini.style.display = 'block';
                    });
                    
                    STATE.processingMode = 'user-keys';
                    STATE.mode = 'user-keys';
                }
                
                return;  // Sortir ici pour Mode 2
            }
            
            // ✅ POUR LES AUTRES MODES : comportement normal
            // Cacher tous les panels
            document.querySelectorAll('.mode-panel').forEach(panel => {
                panel.classList.remove('active');
            });
            
            // Afficher le panel sélectionné
            const panel = document.querySelector(`.mode-panel[data-mode="${mode}"]`);
            if (panel) {
                panel.classList.add('active');
            }
            
            // Mettre à jour STATE
            STATE.processingMode = mode;
            STATE.mode = mode;
            
            // Si mode worker, gérer le toggle
            if (mode === 'worker') {
                const toggle = document.getElementById('workerToggle');
                if (toggle && toggle.checked) {
                    document.getElementById('workerActivePanel').style.display = 'block';
                }
            }
        }
        
        /**
         * ✨ NOUVEAU: Gérer le toggle du radio Mode 2
         * Permet de cliquer à nouveau sur Mode 2 pour le replier
         */
        function handleModeToggle(event, mode) {
            const radio = event.currentTarget.querySelector('input[type="radio"]');
            
            if (radio && radio.checked && mode === 'user-keys') {
                // Le radio est déjà coché → on veut le décocher (toggle)
                console.log('[MODE-TOGGLE] Radio déjà coché, toggle vers manuel');
                event.preventDefault();
                event.stopPropagation();
                
                // Appeler switchMode qui va détecter que le panel est actif et le cacher
                switchMode('user-keys');
                
                return false;
            }
            
            // Sinon, laisser le comportement normal (le radio va se cocher et déclencher onchange)
        }
        
        /**
         * Toggle accordion mini provider
         */
        function toggleMini(providerId) {
            console.log(`[MINI] Toggling: ${providerId}`);
            
            // Fermer tous les autres
            document.querySelectorAll('.provider-mini').forEach(mini => {
                if (mini.dataset.provider !== providerId) {
                    mini.classList.remove('active');
                }
            });
            
            // Toggle le cliqué
            const mini = document.querySelector(`.provider-mini[data-provider="${providerId}"]`);
            if (mini) {
                mini.classList.toggle('active');
                
                // Si ouvert, charger la clé sauvegardée
                if (mini.classList.contains('active')) {
                    try {
                        const savedKey = multiLLM.getUserKey ? multiLLM.getUserKey(providerId) : null;
                        if (savedKey) {
                            document.getElementById(`key-${providerId}`).value = '••••••••••••••••';
                        }
                    } catch (e) {
                        console.log('[MINI] No saved key');
                    }
                    
                    // Calculer le coût
                    updateMiniCost(providerId);
                }
            }
        }
        
        /**
         * Fermer accordion mini (via croix)
         */
        function closeMini(providerId) {
            console.log(`[MINI] Closing: ${providerId}`);
            
            const mini = document.querySelector(`.provider-mini[data-provider="${providerId}"]`);
            if (mini) {
                mini.classList.remove('active');
            }
        }
        
        /**
         * Fermer tous les accordions au clic extérieur
         */
        document.addEventListener('click', function(event) {
            // Ne rien faire si on clique sur un accordion ou ses enfants
            if (event.target.closest('.provider-mini')) {
                return;
            }
            
            // Fermer tous les accordions
            document.querySelectorAll('.provider-mini.active').forEach(mini => {
                mini.classList.remove('active');
            });
        });
        
        /**
         * Sauvegarder clé API mini
         */
        function saveMiniKey(providerId) {
            console.log(`[SAVE] Saving key for: ${providerId}`);
            
            const keyInput = document.getElementById(`key-${providerId}`);
            const modelSelect = document.getElementById(`model-${providerId}`);
            const saveBtn = document.getElementById(`save-${providerId}`);
            
            if (!keyInput || !modelSelect || !saveBtn) {
                showStatus('Erreur: champs manquants', 'error');
                return;
            }
            
            const apiKey = keyInput.value.trim();
            const model = modelSelect.value;
            
            // Vérifier si déjà masqué
            if (apiKey.startsWith('••••')) {
                showStatus('Clé déjà sauvegardée', 'info');
                return;
            }
            
            if (!apiKey) {
                showStatus('Veuillez entrer une clé API', 'error');
                return;
            }
            
            // Sauvegarder via multiLLM
            try {
                const success = multiLLM.setUserKey(providerId, apiKey, model);
                
                if (success) {
                    // ✅ CONFIRMATION VISUELLE
                    // 1. Masquer la clé
                    keyInput.value = '••••••••••••••••';
                    
                    // 2. Changer le bouton (vert + coche)
                    saveBtn.classList.add('save-confirmed');
                    saveBtn.textContent = 'Sauvegardé';
                    
                    // 3. Toast success
                    showStatus(`Clé ${providerId} sauvegardée`, 'success');
                    
                    // 4. ✨ FERMER L'ACCORDION
                    setTimeout(() => {
                        closeMini(providerId);
                    }, 500);
                    
                    // 5. Afficher Quick Actions
                    const quickActions = document.getElementById('apiQuickActions');
                    if (quickActions) {
                        quickActions.style.display = 'block';
                    }
                    
                    // 6. ✨ CACHER TOUS LES ACCORDÉONS (pas Quick Actions)
                    setTimeout(() => {
                        document.querySelectorAll('.provider-mini').forEach(mini => {
                            mini.style.display = 'none';
                        });
                    }, 600);
                    
                    // 7. Remettre le bouton normal après 3s
                    setTimeout(() => {
                        saveBtn.classList.remove('save-confirmed');
                        saveBtn.textContent = 'Sauvegarder';
                    }, 3000);
                    
                } else {
                    showStatus('Erreur de sauvegarde', 'error');
                }
            } catch (error) {
                console.error('[SAVE] Error:', error);
                showStatus('Erreur: ' + error.message, 'error');
            }
        }
        
        /**
         * Mettre à jour le coût mini
         */
        function updateMiniCost(providerId) {
            const modelSelect = document.getElementById(`model-${providerId}`);
            if (!modelSelect) return;
            
            const model = modelSelect.value;
            
            // Prix par provider/model (input/output per 1M tokens)
            const pricing = {
                'deepseek': {
                    'deepseek-chat': { input: 0.27, output: 1.10 },
                    'deepseek-reasoner': { input: 0.55, output: 2.19 }
                },
                'groq': {
                    'llama-3.3-70b-versatile': { input: 0, output: 0 },
                    'llama-3.1-70b-versatile': { input: 0, output: 0 },
                    'mixtral-8x7b-32768': { input: 0, output: 0 }
                },
                'anthropic': {
                    'claude-sonnet-4-20250514': { input: 3.00, output: 15.00 },
                    'claude-opus-4-20250514': { input: 15.00, output: 75.00 },
                    'claude-haiku-4.5-20250514': { input: 1.00, output: 5.00 }
                },
                'openai': {
                    'gpt-4o': { input: 2.50, output: 10.00 },
                    'gpt-4o-mini': { input: 0.15, output: 0.60 },
                    'o1': { input: 15.00, output: 60.00 }
                },
                'google': {
                    'gemini-2.0-flash-exp': { input: 0, output: 0 },
                    'gemini-1.5-pro': { input: 1.25, output: 5.00 }
                }
            };
            
            const price = pricing[providerId]?.[model] || { input: 0, output: 0 };
            
            // Calcul pour 50K input, 4K output
            const inputCost = (50 / 1000) * price.input;
            const outputCost = (4 / 1000) * price.output;
            const totalCost = inputCost + outputCost;
            
            // Mise à jour de l'affichage
            const costElem = document.getElementById(`cost-${providerId}`);
            if (costElem) {
                costElem.textContent = `$${totalCost.toFixed(4)}`;
            }
        }
        
        // ══════════════════════════════════════════════════════════════
        // QUICK ACTIONS - DRAG & DROP
        // ══════════════════════════════════════════════════════════════
        
        let quickFile = null;
        
        /**
         * Gestion du drag over
         */
        function handleQuickDragOver(event) {
            event.preventDefault();
            event.stopPropagation();
            const dropZone = document.getElementById('quickDropZone');
            dropZone.style.borderColor = '#8FAFB1';
            dropZone.style.background = '#E6D7C3';
        }
        
        /**
         * Gestion du drag leave
         */
        function handleQuickDragLeave(event) {
            event.preventDefault();
            event.stopPropagation();
            const dropZone = document.getElementById('quickDropZone');
            dropZone.style.borderColor = '#C8D0C3';
            dropZone.style.background = 'white';
        }
        
        /**
         * Gestion du drop
         */
        function handleQuickDrop(event) {
            event.preventDefault();
            event.stopPropagation();
            
            const dropZone = document.getElementById('quickDropZone');
            dropZone.style.borderColor = '#C8D0C3';
            dropZone.style.background = 'white';
            
            const files = event.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                // ✅ Reset STATE pour le nouveau fichier
                STATE.file = null;
                STATE.fileName = '';
                STATE.extractedText = '';
                STATE.detectionResult = null;
                
                // ✅ ACCEPTER TOUS LES FORMATS
                quickFile = file;
                updateQuickFileInfo(file);
                enableQuickButtons();
            }
        }
        
        /**
         * Gestion de la sélection de fichier via input
         */
        function handleQuickFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                // ✅ Reset STATE pour le nouveau fichier
                STATE.file = null;
                STATE.fileName = '';
                STATE.extractedText = '';
                STATE.detectionResult = null;
                
                // ✅ ACCEPTER TOUS LES FORMATS
                quickFile = file;
                updateQuickFileInfo(file);
                enableQuickButtons();
            }
        }
        
        /**
         * Mettre à jour l'affichage du fichier
         */
        function updateQuickFileInfo(file) {
            const fileInfo = document.getElementById('quickFileInfo');
            const sizeKB = (file.size / 1024).toFixed(1);
            fileInfo.innerHTML = `<b style="color:#8FAFB1;">${file.name}</b> (${sizeKB} KB)`;
        }
        
        /**
         * Activer les boutons providers
         */
        function enableQuickButtons() {
            const providers = ['groq', 'deepseek', 'anthropic', 'openai', 'google'];
            providers.forEach(provider => {
                const btn = document.getElementById(`quickBtn-${provider}`);
                if (btn) {
                    btn.disabled = false;
                    btn.style.background = 'white';
                    btn.style.color = '#333';
                    btn.style.cursor = 'pointer';
                    btn.onmouseover = function() {
                        this.style.background = '#E6D7C3';
                        this.style.borderColor = '#8FAFB1';
                    };
                    btn.onmouseout = function() {
                        this.style.background = 'white';
                        this.style.borderColor = '#C8D0C3';
                    };
                }
            });
        }
        
        /**
         * Traiter le fichier avec le provider sélectionné
         */
        async function processQuickFile(providerId, model) {
            if (!quickFile) {
                showStatus('Veuillez d\'abord déposer un fichier', 'error');
                return;
            }
            
            console.log(`[QUICK] Processing ${quickFile.name} with ${providerId}/${model}`);
            
            // Vérifier que la clé API est configurée
            const apiKey = multiLLM.getUserKey(providerId);
            if (!apiKey) {
                showStatus(`Clé API ${providerId} non configurée`, 'error');
                return;
            }
            
            // Désactiver tous les boutons pendant le traitement
            const providers = ['groq', 'deepseek', 'anthropic', 'openai', 'google'];
            providers.forEach(p => {
                const btn = document.getElementById(`quickBtn-${p}`);
                if (btn) {
                    btn.disabled = true;
                    btn.style.background = '#f0f0f0';
                    btn.style.cursor = 'not-allowed';
                }
            });
            
            // Afficher progress
            showStatus(`Traitement avec ${providerId}...`, 'info');
            
            try {
                // ✅ METTRE LE FICHIER DANS STATE
                STATE.file = quickFile;
                STATE.fileName = quickFile.name;
                STATE.fileSize = quickFile.size;  // ✅ SAUVEGARDER LA TAILLE
                
                console.log(`[QUICK] ✅ STATE.file défini:`, STATE.file.name);
                console.log(`[QUICK] ✅ STATE.fileName:`, STATE.fileName);
                console.log(`[QUICK] ✅ STATE.fileSize:`, STATE.fileSize, 'bytes');
                
                // ✅ ÉTAPE 1: EXTRAIRE LE TEXTE DU FICHIER (OCR)
                showStatus(`Extraction du texte de ${quickFile.name}...`, 'info');
                console.log(`[QUICK] 📄 Début extraction texte...`);
                
                // Appeler handleFile qui fait l'extraction
                await handleFile(quickFile);
                
                console.log(`[QUICK] ✅ Texte extrait: ${STATE.extractedText?.length} caractères`);
                
                // Vérifier que l'extraction a fonctionné
                if (!STATE.extractedText || STATE.extractedText.length === 0) {
                    throw new Error('Extraction du texte échouée');
                }
                
                // ✅ ÉTAPE 2: ENVOYER À L'API
                showStatus(`Envoi à ${providerId}...`, 'info');
                console.log(`[QUICK] 🚀 Appel API ${providerId}...`);
                
                await sendSingleFileToAPI(providerId, model);
                
                console.log(`[QUICK] ✅ Traitement terminé avec succès`);
                
                // ✅ Reset UI seulement (pas STATE.file car le ZIP en a besoin)
                quickFile = null;
                document.getElementById('quickFileInfo').innerHTML = 'ou cliquez pour parcourir';
                
                // ⚠️ NE PAS reset STATE.file, STATE.extractedText, STATE.fileName
                // car ils sont nécessaires pour télécharger le ZIP plus tard
                
                showStatus('✅ Traitement terminé - Cliquez "Télécharger ZIP" ci-dessous', 'success');
                
                // Réactiver les boutons
                providers.forEach(p => {
                    const btn = document.getElementById(`quickBtn-${p}`);
                    if (btn) {
                        btn.disabled = true;
                        btn.style.background = '#f0f0f0';
                        btn.style.color = '#999';
                        btn.style.cursor = 'not-allowed';
                    }
                });
                
            } catch (error) {
                console.error('[QUICK] Error:', error);
                showStatus('Erreur de traitement', 'error');
                
                // Réactiver les boutons en cas d'erreur
                enableQuickButtons();
            }
        }
        
        // Clic sur la zone de drop pour ouvrir file picker
        document.addEventListener('DOMContentLoaded', function() {
            const dropZone = document.getElementById('quickDropZone');
            if (dropZone) {
                dropZone.addEventListener('click', function() {
                    document.getElementById('quickFileInput').click();
                });
            }
        });
        
        // ══════════════════════════════════════════════════════════════
        // GESTION DES TABS + SMOOTH SCROLLS
        // ══════════════════════════════════════════════════════════════
        
        /**
         * Switch entre les tabs de mode
         */
        function switchModeTab(mode) {
            console.log(`[TAB] Switching to: ${mode}`);
            
            // ✅ REPLIER les accordéons et sections des autres modes
            const apiQuickActions = document.getElementById('apiQuickActions');
            const workerActivePanel = document.getElementById('workerActivePanel');
            
            // Masquer et replier les accordéons si on ne va PAS vers MODE 2
            if (mode !== 'user-keys') {
                if (apiQuickActions) apiQuickActions.style.display = 'none';
                // Replier tous les accordéons
                document.querySelectorAll('.provider-accordion').forEach(acc => {
                    acc.classList.remove('active');
                    const content = acc.querySelector('.accordion-content');
                    if (content) content.style.display = 'none';
                });
            }
            
            if (mode !== 'worker') {
                if (workerActivePanel) workerActivePanel.style.display = 'none';
                const workerToggle = document.getElementById('workerToggle');
                if (workerToggle) workerToggle.checked = false;
            }
            
            // Désactiver tous les tabs
            document.querySelectorAll('.mode-tab').forEach(tab => {
                tab.classList.remove('mode-tab-active');
            });
            
            // Masquer tous les panels
            document.querySelectorAll('.mode-tab-panel').forEach(panel => {
                panel.classList.remove('mode-tab-panel-active');
            });
            
            // Activer le tab et panel sélectionnés
            const tab = document.querySelector(`.mode-tab[data-mode="${mode}"]`);
            const panelId = mode === 'user-keys' ? 'panelUserKeys' : 
                           mode === 'manual' ? 'panelManual' : 
                           'panelWorker';
            const panel = document.getElementById(panelId);
            
            if (tab) tab.classList.add('mode-tab-active');
            if (panel) panel.classList.add('mode-tab-panel-active');
            
            // Sauvegarder le mode
            STATE.processingMode = mode;
            
            // Message de confirmation
            const modeNames = {
                'manual': 'Mode Manuel',
                'user-keys': 'Mode API Multi-LLM',
                'worker': 'Mode API Worker'
            };
            showStatus(`✅ ${modeNames[mode]} activé`, 'success');
            
            // Scroll minimal automatique
            setTimeout(() => smoothScrollTo('modeTabsContainer'), 100);
            
            console.log(`[MODE] Switched to: ${mode}`);
        }
        
        /**
         * Scroll smooth vers un élément avec highlight
         */
        function smoothScrollTo(elementId, highlightDuration = 1500) {
            const element = document.getElementById(elementId);
            if (!element) {
                console.warn(`[SCROLL] Element ${elementId} not found`);
                return;
            }
            
            // Scroll minimal - juste pour rendre visible
            element.scrollIntoView({ 
                behavior: 'smooth', 
                block: 'nearest',  // ⚡ Scroll minimal
                inline: 'nearest'
            });
            
            // Highlight subtil
            element.classList.add('scroll-highlight');
            setTimeout(() => {
                element.classList.remove('scroll-highlight');
            }, highlightDuration);
            
            console.log(`[SCROLL] Scrolled to: ${elementId}`);
        }
        
        /**
         * Scroll après upload de fichier
         */
        /**
         * ✨ OPTIMISATION: Scroll intelligent après upload
         * Détecte automatiquement où l'utilisateur doit aller
         */
        function scrollAfterUpload() {
            setTimeout(() => {
                // Mode Manuel → Scroll vers section détection (plus logique)
                if (STATE.processingMode === 'manual') {
                    const detectionSection = document.getElementById('detectionSection');
                    if (detectionSection && detectionSection.style.display !== 'none') {
                        detectionSection.scrollIntoView({ 
                            behavior: 'smooth', 
                            block: 'start',
                            inline: 'nearest'
                        });
                        return;
                    }
                }
                
                // Mode API User Keys → Scroll vers Quick Actions
                if (STATE.processingMode === 'user-keys') {
                    const quickActions = document.getElementById('apiQuickActions');
                    if (quickActions && quickActions.style.display !== 'none') {
                        quickActions.scrollIntoView({ 
                            behavior: 'smooth', 
                            block: 'start',
                            inline: 'nearest'
                        });
                        return;
                    }
                }
                
                // Mode Worker → Scroll vers configuration worker
                if (STATE.processingMode === 'worker') {
                    const workerPanel = document.getElementById('workerActivePanel');
                    if (workerPanel && workerPanel.style.display !== 'none') {
                        workerPanel.scrollIntoView({ 
                            behavior: 'smooth', 
                            block: 'start',
                            inline: 'nearest'
                        });
                        return;
                    }
                }
                
                // Fallback: scroll vers composition section si visible
                const compositionSection = document.getElementById('compositionSection');
                if (compositionSection && compositionSection.style.display !== 'none') {
                    compositionSection.scrollIntoView({ 
                        behavior: 'smooth', 
                        block: 'center',
                        inline: 'nearest'
                    });
                }
            }, 300);  // Réduit à 300ms pour plus de réactivité
        }
        
        /**
         * ✨ Scroll après sélection provider - Vers config ou génération prompt
         */
        function scrollAfterProviderSelect() {
            setTimeout(() => {
                // Scroll vers configuration si elle existe et est visible
                const configSection = document.getElementById('providerConfigSection');
                if (configSection && configSection.style.display !== 'none') {
                    configSection.scrollIntoView({ 
                        behavior: 'smooth', 
                        block: 'center',
                        inline: 'nearest'
                    });
                }
            }, 200);  // Rapide pour réactivité
        }
        
        /**
         * Scroll après analyse API vers résultat
         */
        function scrollAfterAPIAnalysis() {
            // La modale s'ouvre, pas besoin de scroll
            // Mais on peut scroller vers le haut de la page
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }
        
        /**
         * Scroll dans navigation batch vers document actif
         */
        function scrollToBatchDocument(index) {
            const docElement = document.querySelector(`#batchList .batch-item[data-index="${index}"]`);
            if (docElement) {
                docElement.scrollIntoView({
                    behavior: 'smooth',
                    block: 'nearest'
                });
                
                // Highlight temporaire
                docElement.style.animation = 'highlightPulse 1s ease';
                setTimeout(() => {
                    docElement.style.animation = '';
                }, 1000);
            }
        }
        
        /**
         * Fonction de compatibilité - ancienne fonction selectProcessingMode
         */
        function selectProcessingMode(mode) {
            // Rediriger vers la nouvelle fonction tabs
            switchModeTab(mode);
        }
        
        // ══════════════════════════════════════════════════════════════
        // SYSTÈME DE TABS MODERNE AVEC SMOOTH SCROLLING
        // ══════════════════════════════════════════════════════════════
        
        /* FONCTION DUPLIQUÉE - COMMENTÉE (version à la ligne 9052 est utilisée)
        function switchModeTab(mode) {
            console.log('[MODE] Switching to:', mode);
            
            // 1. Mettre à jour l'état
            STATE.processingMode = mode;
            
            // 2. Mettre à jour les boutons tabs
            document.querySelectorAll('.mode-tab').forEach(tab => {
                const tabMode = tab.getAttribute('data-mode');
                if (tabMode === mode) {
                    tab.classList.add('mode-tab-active');
                } else {
                    tab.classList.remove('mode-tab-active');
                }
            });
            
            // 3. Afficher le bon panel
            document.querySelectorAll('.mode-tab-panel').forEach(panel => {
                const panelMode = panel.getAttribute('data-mode');
                if (panelMode === mode) {
                    panel.classList.add('mode-tab-panel-active');
                } else {
                    panel.classList.remove('mode-tab-panel-active');
                }
            });
            
            // 4. Mettre à jour les indicateurs
            multiLLM.setMode(mode);
            updateIndicators();
            
            // 5. ✅ SMOOTH SCROLL vers le contenu des tabs
            setTimeout(() => {
                const modeSection = document.querySelector('.mode-tabs-header');
                if (modeSection) {
                    smoothScrollToElement(modeSection, -20);
                }
            }, 100);
            
            // 6. ✅ HIGHLIGHT temporaire du panel actif
            setTimeout(() => {
                const activePanel = document.querySelector('.mode-tab-panel-active');
                if (activePanel) {
                    highlightElement(activePanel);
                }
            }, 400);
            
            // 7. Si mode API, scroll vers provider selection après animation
            if (mode === 'user-keys') {
                setTimeout(() => {
                    const providerGrid = document.querySelector('.provider-grid');
                    if (providerGrid) {
                        smoothScrollToElement(providerGrid, -100);
                    }
                }, 600);
            }
        }
        */
        
        // ══════════════════════════════════════════════════════════════
        // FONCTIONS UTILITAIRES DE SCROLLING
        // ══════════════════════════════════════════════════════════════
        
        /**
         * Scroll smooth vers un élément avec offset optionnel
         * @param {HTMLElement|string} element - Element ou selector
         * @param {number} offset - Offset en pixels (négatif = au-dessus)
         */
        function smoothScrollToElement(element, offset = 0) {
            const el = typeof element === 'string' 
                ? document.querySelector(element) 
                : element;
            
            if (!el) return;
            
            // Scroll minimal avec scrollIntoView
            el.scrollIntoView({
                behavior: 'smooth',
                block: 'nearest',  // ⚡ Scroll minimal
                inline: 'nearest'
            });
            
            console.log('[SCROLL] Scrolling to element:', el.id || el.className);
        }
        
        /**
         * Highlight temporaire d'un élément (bordure + animation)
         * @param {HTMLElement|string} element - Element ou selector
         * @param {number} duration - Durée en ms
         */
        function highlightElement(element, duration = 1500) {
            const el = typeof element === 'string' 
                ? document.querySelector(element) 
                : element;
            
            if (!el) return;
            
            el.classList.add('highlight-element');
            
            setTimeout(() => {
                el.classList.remove('highlight-element');
            }, duration);
            
            console.log('[HIGHLIGHT] Element highlighted:', el.id || el.className);
        }
        
        /**
         * Scroll vers section après upload PDF
         */
        function scrollToProcessingSection() {
            setTimeout(() => {
                const section = document.getElementById('strategySection') || 
                               document.querySelector('.strategies-section');
                if (section) {
                    smoothScrollToElement(section, -50);
                    highlightElement(section, 2000);
                }
            }, 300);
        }
        
        /**
         * Scroll vers batch item actif
         */
        function scrollToBatchItem(index) {
            setTimeout(() => {
                const item = document.querySelector(`[data-batch-index="${index}"]`);
                if (item) {
                    smoothScrollToElement(item, -100);
                    highlightElement(item, 1000);
                }
            }, 200);
        }
        
        /**
         * Scroll vers configuration provider après sélection
         */
        function scrollToProviderConfig() {
            setTimeout(() => {
                const config = document.getElementById('providerConfig');
                if (config && config.style.display !== 'none') {
                    smoothScrollToElement(config, -80);
                    highlightElement(config, 2000);
                }
            }, 400);
        }
        
        /**
         * Scroll vers quick actions API
         */
        function scrollToAPIQuickActions() {
            setTimeout(() => {
                const section = document.querySelector('.api-quick-section');
                if (section) {
                    smoothScrollToElement(section, -100);
                    highlightElement(section);
                }
            }, 500);
        }
        
        function toggleWorkerMode() {
            const enabled = document.getElementById('workerToggle').checked;
            
            if (enabled) {
                showStatus('✅ Worker activé - Prêt pour traitement automatique', 'success');
            } else {
                showStatus('Worker désactivé', 'info');
            }
        }

        // ══════════════════════════════════════════════════════════════
        // INITIALIZATION
        // ══════════════════════════════════════════════════════════════
        
        document.addEventListener('DOMContentLoaded', () => {
            console.log('OCR Universel V6.0 ULTIMATE - Ready!');
            console.log('21 formats supportés');
            console.log('OCR Workers parallèles activés');
            console.log('PROMPT_MODULES intégrés');
            console.log('Multi-LLM API Manager activé');
            console.log('3 MODES : Manuel (défaut), API User Keys, API Worker');
            
            // Initialiser le mode par défaut
            STATE.processingMode = 'manual';
            
            updateIndicators();
            
            // Initialiser les sélecteurs de modèles
            if (document.getElementById('userModel')) {
                updateUserModels();
            }
        });
    </script>
    
    <!-- ══════════════════════════════════════════════════════════════ -->
    <!-- MODAL GÉNÉRATION PROMPT V6.0 - 3 MODES -->
    <!-- ══════════════════════════════════════════════════════════════ -->
    <div id="promptModal">
        <div class="modal-content" style="max-width:900px;">
            <div class="modal-header">
                <h2>🎯 Génération Prompt Consolidé</h2>
                <span class="modal-close" onclick="closePromptModal()">&times;</span>
            </div>
            
            <p style="text-align:center;margin-bottom:30px;color:var(--gris-secondaire);">
                Choisissez comment vous voulez traiter le prompt consolidé
            </p>
            
            <!-- ═══ NOUVEAU : SYSTÈME DE TABS ═══ -->
            <div class="mode-tabs-container">
                <!-- TABS HEADERS -->
                <div class="mode-tabs">
                    <button class="mode-tab active" data-mode="manual" onclick="switchModeTab('manual')">
                        <span class="mode-tab-icon">📝</span>
                        <span>Manuel</span>
                        <span class="mode-tab-badge">DÉFAUT</span>
                    </button>
                    <button class="mode-tab" data-mode="user-keys" onclick="switchModeTab('user-keys')">
                        <span class="mode-tab-icon">🔑</span>
                        <span>API Multi-LLM</span>
                        <span class="mode-tab-badge mode-tab-badge-premium">AVANCÉ</span>
                    </button>
                    <button class="mode-tab" data-mode="worker" onclick="switchModeTab('worker')">
                        <span class="mode-tab-icon">⚙️</span>
                        <span>API Worker</span>
                        <span class="mode-tab-badge mode-tab-badge-free">GRATUIT</span>
                    </button>
                </div>
                
                <!-- TAB CONTENT : MODE 1 - MANUEL -->
                <div class="mode-tab-content active" id="tab-manual">
                    <h4 style="margin-bottom:15px;color:var(--accent);">📝 Mode Manuel (Recommandé)</h4>
                    <p style="margin-bottom:20px;">Copiez ou téléchargez le prompt pour l'utiliser dans Claude.ai, ChatGPT ou autre plateforme.</p>
                    <div class="mode-actions">
                        <button class="btn btn-secondary" onclick="copyAllPrompts()">
                            📋 Copier dans presse-papiers
                        </button>
                        <button class="btn btn-secondary" onclick="downloadPromptTXT()">
                            📝 Télécharger .txt
                        </button>
                        <button class="btn btn-secondary" onclick="downloadPromptJSON()">
                            📦 Télécharger .json
                        </button>
                    </div>
                </div>
                
                <!-- TAB CONTENT : MODE 2 - API MULTI-LLM -->
                <div class="mode-tab-content" id="tab-user-keys">
                    <h4 style="margin-bottom:15px;color:var(--accent);">🔑 API Multi-LLM avec vos clés</h4>
                    <p style="margin-bottom:20px;">Utilisez vos propres clés API pour envoyer le prompt directement à l'IA de votre choix.</p>
                    
                    <div class="api-config-box">
                        <div class="key-input-row">
                            <div>
                                <label for="userProvider">Provider:</label>
                                <select id="userProvider" onchange="updateUserModels()">
                                    <option value="anthropic">Anthropic Claude</option>
                                    <option value="openai">OpenAI GPT</option>
                                    <option value="google">Google Gemini</option>
                                </select>
                            </div>
                            <div>
                                <label for="userModel">Modèle:</label>
                                <select id="userModel" onchange="updateUserCost()">
                                    <option value="claude-sonnet-4-20250514">Claude Sonnet 4</option>
                                </select>
                            </div>
                        </div>
                        
                        <!-- V6.3.0 - PANNEAU SÉCURITÉ & LIMITES -->
                        <div id="securityWarning" class="security-warning">
                            <h4>
                                <span style="font-size:24px;">⚠️</span>
                                <span>SÉCURITÉ & LIMITES - IMPORTANT</span>
                            </h4>
                            <div class="security-warning-content">
                                <p><strong>MODE USER KEYS (clés personnelles) :</strong></p>
                                <ul>
                                    <li>Vos clés sont stockées <strong>LOCALEMENT</strong> dans votre navigateur</li>
                                    <li>Obfuscation XOR (⚠️ PAS une vraie encryption)</li>
                                    <li>Les clés sont exposées au JavaScript de cette page</li>
                                </ul>
                                
                                <div class="security-warning-highlight">
                                    ⚠️ N'utilisez PAS ce mode pour des données ultra-sensibles ou en production
                                </div>
                                
                                <p><strong>POUR PLUS DE SÉCURITÉ :</strong></p>
                                <ul>
                                    <li>✅ Utilisez le <strong>Mode Worker</strong> (serveur Cloudflare sécurisé)</li>
                                    <li>✅ Ou hébergez votre propre backend avec proxy</li>
                                    <li>✅ Limitez l'usage aux tests et développement</li>
                                </ul>
                            </div>
                            <div class="security-warning-actions">
                                <button class="security-btn security-btn-primary" onclick="acceptSecurityWarning()">
                                    ✓ J'ai compris, continuer
                                </button>
                                <button class="security-btn security-btn-secondary" onclick="learnMoreSecurity()">
                                    ℹ️ En savoir plus
                                </button>
                            </div>
                        </div>
                        
                        <div class="key-input-row">
                            <label id="userKeyLabel">Clé API Anthropic:</label>
                            <input type="password" id="userApiKey" placeholder="sk-ant-api03-...">
                            <button class="btn btn-small" onclick="saveUserKey()">💾 Sauvegarder</button>
                        </div>
                        
                        <div class="api-params-row">
                            <div>
                                <label>Max Tokens:</label>
                                <input type="number" id="userMaxTokens" value="4096" min="1000" max="8000">
                            </div>
                            <div>
                                <label>Temperature:</label>
                                <input type="number" id="userTemperature" value="0.3" min="0" max="1" step="0.1">
                            </div>
                        </div>
                        
                        <div class="cost-display" id="userCost">
                            💰 Coût estimé : <strong>$0.0150 USD</strong>
                        </div>
                    </div>
                    
                    <button class="btn" onclick="sendWithUserKeys()" style="width:100%;margin-top:15px;">
                        🚀 Analyser avec mes clés
                    </button>
                </div>
                
                <!-- TAB CONTENT : MODE 3 - WORKER -->
                <div class="mode-tab-content" id="tab-worker">
                    <h4 style="margin-bottom:15px;color:var(--accent);">⚙️ API Automatique (Worker)</h4>
                    <div class="worker-info">
                        <p>🔒 <strong>Utilise les clés de Christophe (gratuitement pour vous)</strong></p>
                        <p style="font-size:0.9em;color:var(--gris-secondaire);margin:10px 0;">
                            • Pas besoin de créer de compte<br>
                            • Pas de configuration<br>
                            • Cloudflare Worker sécurisé
                        </p>
                    </div>
                    
                    <div class="worker-toggle">
                        <label class="toggle-switch">
                            <input type="checkbox" id="workerEnabled" onchange="toggleWorker()">
                            <span class="toggle-slider"></span>
                        </label>
                        <span id="workerStatus">Mode Worker désactivé</span>
                    </div>
                    
                    <div id="workerActivePanel" style="display:none;">
                        <div class="api-config-box" style="margin-top:15px;">
                            <div class="key-input-row">
                                <div>
                                    <label>Modèle:</label>
                                    <select id="workerModel">
                                        <option value="claude-sonnet-4-20250514">Claude Sonnet 4 (Recommandé)</option>
                                        <option value="claude-opus-4-20250514">Claude Opus 4 (Premium)</option>
                                        <option value="claude-haiku-4.5-20250514">Claude Haiku 4.5 (Rapide)</option>
                                    </select>
                                </div>
                            </div>
                            
                            <div class="cost-display">
                                ✅ <strong>Gratuit pour vous</strong> (coût pris en charge)
                            </div>
                        </div>
                        
                        <button class="btn" onclick="sendWithWorker()" style="width:100%;margin-top:15px;">
                            🚀 Analyser avec Worker
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Progress Bar (commune à tous les modes API) -->
            <div class="api-progress" id="apiProgress">
                <div class="progress-bar">
                    <div class="progress-fill" id="apiProgressFill" style="width:0%">
                        <span id="apiProgressText">0%</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- ══════════════════════════════════════════════════════════════ -->
    <!-- MODAL RÉSULTAT API -->
    <!-- ══════════════════════════════════════════════════════════════ -->
    <div id="apiResultModal">
        <div class="api-result-content">
            <div class="modal-header">
                <h2>✅ Résultat API</h2>
                <span class="modal-close" onclick="closeAPIResult()">&times;</span>
            </div>
            
            <div class="result-metadata">
                <div class="metadata-item">
                    <div class="metadata-value" id="resultProvider">ANTHROPIC</div>
                    <div class="metadata-label">Provider</div>
                </div>
                <div class="metadata-item">
                    <div class="metadata-value" id="resultModel">Sonnet 4</div>
                    <div class="metadata-label">Modèle</div>
                </div>
                <div class="metadata-item">
                    <div class="metadata-value" id="resultDuration">32.5s</div>
                    <div class="metadata-label">Durée</div>
                </div>
                <div class="metadata-item">
                    <div class="metadata-value" id="resultCost">$0.0150</div>
                    <div class="metadata-label">Coût</div>
                </div>
            </div>
            
            <h3>Résultat JSON :</h3>
            <pre class="json-display" id="jsonDisplay">{ }</pre>
            
            <div class="result-actions">
                <button class="btn" onclick="downloadAPIResult()">📥 Télécharger JSON</button>
                <button class="btn btn-secondary" onclick="copyAPIResult()">📋 Copier</button>
                <button class="btn btn-secondary" onclick="closeAPIResult()">Fermer</button>
            </div>
        </div>
    </div>

</body>
</html>
