<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OCR Universel V5.2 ULTIMATE - Labo R&D Anthropic</title>
    
    <!-- Police Montserrat -->
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- BibliothÃ¨ques CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/idb@7/build/umd.js"></script>
    
    <style>
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        /* CHARTE GRAPHIQUE MARIE-CHRISTINE ABATTE */
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        
        :root {
            --vert-sauge: #C8D0C3;
            --beige-sable: #D8CDBB;
            --sable: #E6D7C3;
            --mer: #8FAFB1;
            --blanc: #FFFFFF;
            --noir: #000000;
            --gris-texte: #333333;
            --gris-secondaire: #666666;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Montserrat', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, var(--sable) 0%, var(--beige-sable) 100%);
            color: var(--gris-texte);
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: var(--blanc);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.15);
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        /* TYPOGRAPHIE */
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        
        h1 {
            color: var(--mer);
            font-size: 2.5em;
            font-weight: 700;
            margin-bottom: 10px;
            text-align: center;
        }
        
        h2 {
            color: var(--mer);
            font-size: 2em;
            font-weight: 600;
            margin-top: 40px;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 3px solid var(--vert-sauge);
        }
        
        h3 {
            color: var(--gris-texte);
            font-size: 1.5em;
            font-weight: 600;
            margin-top: 30px;
            margin-bottom: 15px;
        }
        
        h4 {
            color: var(--mer);
            font-size: 1.2em;
            font-weight: 600;
            margin-bottom: 10px;
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        /* HEADER */
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        
        .header {
            text-align: center;
            padding: 30px;
            background: linear-gradient(135deg, var(--sable) 0%, var(--beige-sable) 100%);
            border-radius: 12px;
            margin-bottom: 40px;
            border-left: 5px solid var(--mer);
        }
        
        .version-badge {
            display: inline-block;
            background: linear-gradient(135deg, var(--mer) 0%, var(--vert-sauge) 100%);
            color: var(--blanc);
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 600;
            margin-top: 10px;
        }
        
        .subtitle {
            font-size: 1.1em;
            color: var(--gris-secondaire);
            margin-top: 10px;
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        /* CARDS & SECTIONS */
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        
        .section {
            background: var(--blanc);
            padding: 30px;
            border-radius: 12px;
            margin-bottom: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
        }
        
        .card {
            background: linear-gradient(135deg, var(--sable) 0%, var(--beige-sable) 100%);
            padding: 25px;
            border-radius: 12px;
            border-left: 4px solid var(--mer);
            margin-bottom: 20px;
            transition: transform 0.3s;
        }
        
        .card:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(143, 175, 177, 0.3);
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .info-item {
            background: var(--sable);
            padding: 20px;
            border-radius: 10px;
        }
        
        .info-label {
            font-size: 0.85em;
            color: var(--gris-secondaire);
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        .info-value {
            font-size: 1.2em;
            font-weight: 600;
            color: var(--mer);
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        /* UPLOAD ZONE */
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        
        .drop-zone {
            border: 3px dashed var(--mer);
            border-radius: 12px;
            padding: 60px 30px;
            text-align: center;
            cursor: pointer;
            background: var(--sable);
            transition: all 0.3s;
        }
        
        .drop-zone:hover, .drop-zone.drag-over {
            background: linear-gradient(135deg, var(--mer) 0%, var(--vert-sauge) 100%);
            color: var(--blanc);
            transform: scale(1.02);
        }
        
        .drop-zone input[type="file"] {
            display: none;
        }
        
        .drop-zone-icon {
            font-size: 4em;
            margin-bottom: 20px;
        }
        
        .supported-formats {
            margin-top: 20px;
            padding: 20px;
            background: var(--beige-sable);
            border-radius: 10px;
        }
        
        .format-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        
        .format-badge {
            background: var(--mer);
            color: var(--blanc);
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 0.85em;
            text-align: center;
            font-weight: 500;
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        /* PROGRESS */
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        
        .progress-container {
            background: var(--sable);
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 25px;
            border-left: 4px solid var(--mer);
            display: none;
        }
        
        .progress-bar-container {
            width: 100%;
            height: 30px;
            background: var(--beige-sable);
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 15px;
        }
        
        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--mer), var(--vert-sauge));
            border-radius: 15px;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--blanc);
            font-weight: 600;
        }
        
        .progress-detail {
            display: flex;
            justify-content: space-between;
            padding: 12px;
            background: var(--blanc);
            border-radius: 8px;
            margin-top: 10px;
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        /* STATUS MESSAGES */
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        
        .status-message {
            padding: 15px 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: none;
            border-left: 4px solid;
        }
        
        .status-success {
            background: #E8F5E9;
            border-color: #4CAF50;
            color: #2E7D32;
        }
        
        .status-info {
            background: var(--sable);
            border-color: var(--mer);
            color: var(--gris-texte);
        }
        
        .status-warning {
            background: #FFF3E0;
            border-color: #FF9800;
            color: #E65100;
        }
        
        .status-error {
            background: #FFEBEE;
            border-color: #F44336;
            color: #C62828;
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        /* BUTTONS */
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        
        .btn {
            background: linear-gradient(135deg, var(--mer) 0%, var(--vert-sauge) 100%);
            color: var(--blanc);
            border: none;
            padding: 15px 40px;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(143, 175, 177, 0.3);
            font-family: 'Montserrat', sans-serif;
        }
        
        .btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(143, 175, 177, 0.5);
        }
        
        .btn-secondary {
            background: var(--beige-sable);
            color: var(--gris-texte);
        }
        
        .btn-small {
            padding: 10px 25px;
            font-size: 14px;
        }
        
        .btn-group {
            display: flex;
            gap: 15px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        /* TEMPLATES */
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        
        .templates-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .template-card {
            background: var(--sable);
            padding: 25px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            border-left: 4px solid var(--mer);
        }
        
        .template-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 20px rgba(143, 175, 177, 0.3);
        }
        
        .template-badge {
            display: inline-block;
            background: var(--mer);
            color: var(--blanc);
            padding: 5px 12px;
            border-radius: 12px;
            font-size: 0.8em;
            margin-top: 10px;
            margin-right: 5px;
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        /* CONFIGURATION */
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        
        .config-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin: 30px 0;
        }
        
        .config-section {
            background: var(--sable);
            padding: 25px;
            border-radius: 12px;
            border-left: 4px solid var(--mer);
        }
        
        .platform-selector {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 20px 0;
        }
        
        .platform-option {
            background: var(--blanc);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid var(--beige-sable);
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        
        .platform-option:hover {
            border-color: var(--mer);
        }
        
        .platform-option.selected {
            background: linear-gradient(135deg, var(--mer) 0%, var(--vert-sauge) 100%);
            color: var(--blanc);
            border-color: var(--mer);
        }
        
        .model-selector {
            display: none;
            margin-top: 15px;
        }
        
        .model-selector select {
            width: 100%;
            padding: 12px;
            border-radius: 8px;
            border: 2px solid var(--beige-sable);
            font-family: 'Montserrat', sans-serif;
            font-size: 15px;
            background: var(--blanc);
        }
        
        .indicator-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 20px;
        }
        
        .indicator {
            text-align: center;
            padding: 15px;
            background: var(--blanc);
            border-radius: 8px;
        }
        
        .indicator-label {
            font-size: 0.85em;
            color: var(--gris-secondaire);
            margin-bottom: 8px;
        }
        
        .indicator-value {
            font-size: 1.1em;
            font-weight: 600;
            color: var(--mer);
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        /* COMPOSITION OVERRIDE */
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        
        .composition-section {
            background: var(--sable);
            padding: 30px;
            border-radius: 12px;
            border-left: 4px solid var(--mer);
            margin-top: 30px;
            display: none;
        }
        
        .content-checkboxes {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .checkbox-label {
            background: var(--blanc);
            padding: 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .checkbox-label:hover {
            background: var(--beige-sable);
        }
        
        .checkbox-label input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        
        .weights-section {
            margin-top: 25px;
            padding: 25px;
            background: var(--blanc);
            border-radius: 10px;
        }
        
        .slider-item {
            display: grid;
            grid-template-columns: 200px 1fr 80px;
            gap: 15px;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .slider-item input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: var(--beige-sable);
            outline: none;
            -webkit-appearance: none;
        }
        
        .slider-item input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: var(--mer);
            cursor: pointer;
        }
        
        .slider-item input[type="range"]::-moz-range-thumb {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: var(--mer);
            cursor: pointer;
            border: none;
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        /* PARTS CONTAINER */
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        
        .part-card {
            background: var(--sable);
            padding: 30px;
            border-radius: 12px;
            margin-bottom: 30px;
            border-left: 4px solid var(--mer);
        }
        
        .part-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .part-title {
            font-size: 1.3em;
            font-weight: 600;
            color: var(--mer);
        }
        
        .status-badge {
            padding: 8px 16px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 600;
        }
        
        .status-pending {
            background: var(--beige-sable);
            color: var(--gris-texte);
        }
        
        .status-completed {
            background: #4CAF50;
            color: var(--blanc);
        }
        
        .prompt-output {
            background: var(--blanc);
            padding: 25px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            max-height: 500px;
            overflow-y: auto;
            white-space: pre-wrap;
            margin-bottom: 20px;
        }
        
        textarea {
            width: 100%;
            min-height: 200px;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid var(--beige-sable);
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            resize: vertical;
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        /* STATISTICS */
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 25px 0;
        }
        
        .stat-card {
            background: linear-gradient(135deg, var(--mer), var(--vert-sauge));
            color: var(--blanc);
            padding: 25px;
            border-radius: 12px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 2.5em;
            font-weight: 700;
            margin-bottom: 10px;
        }
        
        .stat-label {
            font-size: 0.9em;
            opacity: 0.95;
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        /* FOOTER */
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        
        .footer {
            text-align: center;
            margin-top: 50px;
            padding-top: 30px;
            border-top: 2px solid var(--beige-sable);
            font-size: 11px;
            color: var(--noir);
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        /* BATCH PROCESSING */
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        
        .batch-section {
            margin-top: 30px;
        }
        
        .batch-upload {
            background: var(--sable);
            padding: 25px;
            border-radius: 12px;
            border: 2px dashed var(--mer);
            text-align: center;
            margin-bottom: 25px;
        }
        
        .batch-upload input[type="file"] {
            display: none;
        }
        
        .batch-upload-label {
            display: inline-block;
            background: linear-gradient(135deg, var(--mer), var(--vert-sauge));
            color: var(--blanc);
            padding: 15px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.3s;
        }
        
        .batch-upload-label:hover {
            transform: scale(1.05);
        }
        
        .batch-queue {
            margin: 25px 0;
        }
        
        .batch-item {
            background: var(--blanc);
            border: 2px solid var(--beige-sable);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 15px;
            transition: all 0.3s;
        }
        
        .batch-item:hover {
            border-color: var(--mer);
            box-shadow: 0 4px 12px rgba(143, 175, 177, 0.2);
        }
        
        .batch-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .batch-file-name {
            font-weight: 600;
            color: var(--gris-texte);
            font-size: 1.05em;
            flex: 1;
        }
        
        .batch-file-status {
            display: inline-block;
            padding: 6px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 600;
            margin: 0 10px;
        }
        
        .status-queued {
            background: var(--sable);
            color: var(--gris-secondaire);
        }
        
        .status-extracting {
            background: #FFE5B4;
            color: #8B4513;
        }
        
        .status-analyzing {
            background: #B4D7FF;
            color: #003366;
        }
        
        .status-generating {
            background: #D4EDDA;
            color: #155724;
        }
        
        .status-completed {
            background: var(--vert-sauge);
            color: #2C5F2D;
        }
        
        .status-error {
            background: #F8D7DA;
            color: #721C24;
        }
        
        .batch-remove-btn {
            background: transparent;
            border: none;
            color: var(--gris-secondaire);
            font-size: 1.5em;
            cursor: pointer;
            padding: 5px 10px;
            transition: color 0.3s;
        }
        
        .batch-remove-btn:hover {
            color: #DC3545;
        }
        
        .batch-progress-bar {
            width: 100%;
            height: 8px;
            background: var(--sable);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        
        .batch-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--mer), var(--vert-sauge));
            border-radius: 4px;
            transition: width 0.5s ease;
        }
        
        .batch-progress-message {
            font-size: 0.9em;
            color: var(--gris-secondaire);
            font-style: italic;
        }
        
        .batch-error-message {
            background: #F8D7DA;
            color: #721C24;
            padding: 12px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 0.9em;
            border-left: 4px solid #DC3545;
        }
        
        .batch-controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 30px 0;
            flex-wrap: wrap;
        }
        
        .batch-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 25px 0;
        }
        
        .batch-stat {
            background: linear-gradient(135deg, var(--sable), var(--beige-sable));
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            border-left: 4px solid var(--mer);
        }
        
        .batch-stat-value {
            font-size: 2em;
            font-weight: 700;
            color: var(--mer);
            margin-bottom: 5px;
        }
        
        .batch-stat-label {
            font-size: 0.9em;
            color: var(--gris-secondaire);
            font-weight: 500;
        }
        
        .batch-templates {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .batch-template-card {
            background: var(--blanc);
            border: 2px solid var(--beige-sable);
            border-radius: 10px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        
        .batch-template-card:hover {
            border-color: var(--mer);
            transform: translateY(-5px);
            box-shadow: 0 6px 20px rgba(143, 175, 177, 0.3);
        }
        
        .batch-template-card h5 {
            color: var(--mer);
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        
        .batch-template-card p {
            font-size: 0.9em;
            color: var(--gris-secondaire);
            margin-bottom: 10px;
        }
        
        .batch-config-section {
            background: var(--sable);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }
        
        .batch-config-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 15px;
        }
        
        .batch-config-item {
            display: flex;
            flex-direction: column;
        }
        
        .batch-config-item label {
            font-weight: 600;
            color: var(--gris-texte);
            margin-bottom: 8px;
            font-size: 0.95em;
        }
        
        .batch-config-item select,
        .batch-config-item input[type="number"] {
            padding: 10px;
            border: 2px solid var(--beige-sable);
            border-radius: 8px;
            font-family: Montserrat;
            font-size: 0.95em;
        }
        
        .batch-config-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        
        .batch-empty {
            text-align: center;
            padding: 60px 20px;
            color: var(--gris-secondaire);
        }
        
        .batch-empty-icon {
            font-size: 4em;
            margin-bottom: 20px;
            opacity: 0.3;
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        /* EXPORT FORMATS */
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        
        .export-section {
            margin-top: 30px;
        }
        
        .export-formats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 25px 0;
        }
        
        .export-format-card {
            background: var(--blanc);
            border: 2px solid var(--beige-sable);
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            position: relative;
        }
        
        .export-format-card:hover {
            border-color: var(--mer);
            transform: translateY(-5px);
            box-shadow: 0 6px 20px rgba(143, 175, 177, 0.3);
        }
        
        .export-format-card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none;
        }
        
        .export-format-icon {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .export-format-name {
            font-weight: 600;
            color: var(--mer);
            margin-bottom: 8px;
            font-size: 1.1em;
        }
        
        .export-format-desc {
            font-size: 0.85em;
            color: var(--gris-secondaire);
            line-height: 1.4;
        }
        
        .export-format-badge {
            display: inline-block;
            background: var(--vert-sauge);
            color: var(--gris-texte);
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.75em;
            font-weight: 600;
            margin-top: 8px;
        }
        
        .export-options {
            background: var(--sable);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }
        
        .export-option-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--beige-sable);
        }
        
        .export-option-row:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        
        .export-option-label {
            font-weight: 500;
            color: var(--gris-texte);
            flex: 1;
        }
        
        .export-option-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .export-option-control input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        
        .export-option-control select {
            padding: 8px 12px;
            border: 2px solid var(--beige-sable);
            border-radius: 8px;
            font-family: Montserrat;
            font-size: 0.9em;
        }
        
        .export-preview {
            background: var(--blanc);
            border: 2px solid var(--beige-sable);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .export-preview-header {
            font-weight: 600;
            color: var(--mer);
            margin-bottom: 15px;
            font-family: Montserrat;
        }
        
        .export-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 25px 0;
            flex-wrap: wrap;
        }
        
        .export-all-btn {
            background: linear-gradient(135deg, var(--mer), var(--vert-sauge));
            color: var(--blanc);
            padding: 15px 40px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 1.1em;
            cursor: pointer;
            transition: transform 0.3s;
        }
        
        .export-all-btn:hover {
            transform: scale(1.05);
        }
        
        .export-all-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        /* RESPONSIVE */
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 1.8em;
            }
            
            h2 {
                font-size: 1.5em;
            }
            
            .config-grid {
                grid-template-columns: 1fr;
            }
            
            .platform-selector {
                grid-template-columns: 1fr;
            }
            
            .slider-item {
                grid-template-columns: 1fr;
            }
            
            .format-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        /* MODAL PROMPT CONSOLIDÃ‰ */
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        
        .prompt-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }
        
        .prompt-modal.active {
            display: flex;
        }
        
        .prompt-modal-content {
            background: var(--blanc);
            border-radius: 20px;
            padding: 40px;
            max-width: 700px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }
        
        .prompt-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 3px solid var(--vert-sauge);
        }
        
        .prompt-modal-header h2 {
            margin: 0;
            padding: 0;
            border: none;
            color: var(--mer);
        }
        
        .prompt-modal-close {
            background: none;
            border: none;
            font-size: 2em;
            color: var(--gris-secondaire);
            cursor: pointer;
            padding: 0;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s ease;
        }
        
        .prompt-modal-close:hover {
            background: var(--sable);
            color: var(--noir);
        }
        
        .prompt-strategy {
            background: var(--sable);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s ease;
        }
        
        .prompt-strategy:hover {
            border-color: var(--vert-sauge);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        .prompt-strategy.selected {
            border-color: var(--mer);
            background: linear-gradient(135deg, var(--vert-sauge) 0%, var(--sable) 100%);
        }
        
        .prompt-strategy-header {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .prompt-strategy-radio {
            width: 24px;
            height: 24px;
            margin-right: 15px;
        }
        
        .prompt-strategy-title {
            font-size: 1.3em;
            font-weight: 600;
            color: var(--mer);
        }
        
        .prompt-strategy-badge {
            display: inline-block;
            background: var(--mer);
            color: var(--blanc);
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.8em;
            margin-left: 10px;
            font-weight: 500;
        }
        
        .prompt-strategy-description {
            color: var(--gris-texte);
            margin: 10px 0 10px 39px;
            line-height: 1.6;
        }
        
        .prompt-strategy-specs {
            display: flex;
            gap: 20px;
            margin: 10px 0 0 39px;
            flex-wrap: wrap;
        }
        
        .prompt-strategy-spec {
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--gris-secondaire);
            font-size: 0.9em;
        }
        
        .prompt-strategy-spec-icon {
            font-size: 1.2em;
        }
        
        .prompt-modal-actions {
            display: flex;
            gap: 15px;
            margin-top: 30px;
            justify-content: flex-end;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <!-- HEADER -->
        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <div class="header">
            <h1>OCR Universel V5.2 ULTIMATE</h1>
            <span class="version-badge">Labo R&D Anthropic</span>
            <p class="subtitle">
                21 formats supportÃ©s â€¢ OCR parallÃ¨le intelligent â€¢ DÃ©tection multi-dimensionnelle â€¢ Production Ready
            </p>
        </div>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <!-- TEMPLATES -->
        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <div class="section">
            <h2>Templates PrÃ©-configurÃ©s</h2>
            <div class="templates-grid">
                <div class="template-card" onclick="loadTemplate('realbook_jazz')">
                    <h4>Real Book Jazz</h4>
                    <p>Partition (70%) + PÃ©dagogie (30%)</p>
                    <span class="template-badge">Scanned</span>
                    <span class="template-badge">GPT-4o</span>
                </div>
                
                <div class="template-card" onclick="loadTemplate('sade_songbook')">
                    <h4>Sade Songbook</h4>
                    <p>Partition (100%) - Chant + Piano</p>
                    <span class="template-badge">Digital</span>
                    <span class="template-badge">32 modules</span>
                </div>
                
                <div class="template-card" onclick="loadTemplate('therapy_doc')">
                    <h4>Document ThÃ©rapie</h4>
                    <p>ThÃ©rapie (80%) + Questionnaire (20%)</p>
                    <span class="template-badge">Digital</span>
                    <span class="template-badge">Claude Sonnet 4</span>
                </div>
                
                <div class="template-card" onclick="loadTemplate('scientific_paper')">
                    <h4>Paper Scientifique</h4>
                    <p>Scientifique (100%)</p>
                    <span class="template-badge">Digital</span>
                    <span class="template-badge">32 modules</span>
                </div>
            </div>
        </div>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <!-- BATCH PROCESSING -->
        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <div class="section batch-section" id="batchSection">
            <h2>Batch Processing</h2>
            
            <!-- Batch Templates -->
            <div class="card">
                <h4>Templates Batch</h4>
                <p style="margin-bottom:15px;color:var(--gris-secondaire);">Configurations prÃ©-dÃ©finies pour traitement de dossiers</p>
                <div class="batch-templates">
                    <div class="batch-template-card" onclick="applyBatchTemplate('realbook_collection')">
                        <h5>Realbook Collection</h5>
                        <p>Jazz fake books</p>
                        <span class="template-badge">Scanned</span>
                    </div>
                    <div class="batch-template-card" onclick="applyBatchTemplate('therapy_docs_batch')">
                        <h5>Therapy Docs</h5>
                        <p>Documents cliniques</p>
                        <span class="template-badge">Digital</span>
                    </div>
                    <div class="batch-template-card" onclick="applyBatchTemplate('scientific_papers')">
                        <h5>Scientific Papers</h5>
                        <p>Articles recherche</p>
                        <span class="template-badge">Digital</span>
                    </div>
                    <div class="batch-template-card" onclick="applyBatchTemplate('custom')">
                        <h5>Custom</h5>
                        <p>Configuration manuelle</p>
                        <span class="template-badge">Config</span>
                    </div>
                </div>
            </div>
            
            <!-- Batch Configuration -->
            <div class="batch-config-section">
                <h4>Configuration Batch</h4>
                <div class="batch-config-row">
                    <div class="batch-config-item">
                        <label>Fichiers simultanÃ©s:</label>
                        <input type="number" id="batchMaxConcurrent" value="3" min="1" max="5" onchange="updateBatchConfig()">
                    </div>
                    <div class="batch-config-item">
                        <label>Tentatives retry:</label>
                        <input type="number" id="batchRetryAttempts" value="2" min="0" max="5" onchange="updateBatchConfig()">
                    </div>
                </div>
                <div class="batch-config-row">
                    <div class="batch-config-item">
                        <label>
                            <input type="checkbox" id="batchContinueOnError" checked onchange="updateBatchConfig()">
                            Continuer si erreur
                        </label>
                    </div>
                    <div class="batch-config-item">
                        <label>StratÃ©gie de fusion:</label>
                        <select id="batchMergeStrategy" onchange="updateBatchConfig()">
                            <option value="chronological">Chronologique</option>
                            <option value="by_type">Par type</option>
                            <option value="alphabetical">AlphabÃ©tique</option>
                            <option value="flat">Plat (pas de fusion)</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <!-- Upload Multiple Files -->
            <div class="batch-upload">
                <input type="file" id="batchFileInput" multiple accept=".pdf,.docx,.doc,.xlsx,.xls,.pptx,.ppt,.epub,.html,.htm,.md,.markdown,.txt,.png,.jpg,.jpeg,.gif,.webp,.tiff,.tif,.svg,.rtf,.odt,.ods,.odp,.csv,.tsv,.json,.xml,.yaml,.yml,.mobi,.azw,.azw3,.cbz,.cbr,.eml,.msg,.ics,.vcf,.gpx,.kml,.tex,.bib,.zip">
                <label for="batchFileInput" class="batch-upload-label">
                    SÃ©lectionner plusieurs fichiers
                </label>
                <p style="margin-top:15px;color:var(--gris-secondaire);">Glissez-dÃ©posez plusieurs fichiers ou cliquez pour sÃ©lectionner</p>
            </div>
            
            <!-- Batch Queue -->
            <div id="batchQueue" class="batch-queue"></div>
            
            <!-- Batch Controls -->
            <div class="batch-controls">
                <button class="btn" onclick="startBatch()" id="batchStartBtn">
                    DÃ©marrer le Batch
                </button>
                <button class="btn btn-secondary" onclick="pauseBatch()" id="batchPauseBtn" disabled>
                    Pause
                </button>
                <button class="btn btn-secondary" onclick="resumeBatch()" id="batchResumeBtn" disabled>
                    Reprendre
                </button>
                <button class="btn btn-secondary" onclick="exportPartialBatch()" id="batchExportBtn" disabled>
                    Exporter rÃ©sultats partiels
                </button>
                <button class="btn" onclick="openConsolidatedPromptModal()" id="batchPromptBtn" disabled style="background: linear-gradient(135deg, var(--mer) 0%, var(--vert-sauge) 100%);">
                    ğŸ¯ GÃ©nÃ©rer Prompt ConsolidÃ©
                </button>
                <button class="btn btn-danger" onclick="clearBatch()">
                    Tout effacer
                </button>
            </div>
            
            <!-- Batch Statistics -->
            <div class="batch-stats" id="batchStats" style="display:none;">
                <div class="batch-stat">
                    <div class="batch-stat-value" id="batchStatTotal">0</div>
                    <div class="batch-stat-label">Total</div>
                </div>
                <div class="batch-stat">
                    <div class="batch-stat-value" id="batchStatCompleted">0</div>
                    <div class="batch-stat-label">ComplÃ©tÃ©s</div>
                </div>
                <div class="batch-stat">
                    <div class="batch-stat-value" id="batchStatErrors">0</div>
                    <div class="batch-stat-label">Erreurs</div>
                </div>
                <div class="batch-stat">
                    <div class="batch-stat-value" id="batchStatTime">0s</div>
                    <div class="batch-stat-label">Temps Ã©coulÃ©</div>
                </div>
            </div>
        </div>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <!-- UPLOAD ZONE -->
        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <div class="section">
            <h2>Upload Document</h2>
            
            <div class="drop-zone" id="dropZone">
                <input type="file" id="fileInput" accept=".pdf,.docx,.doc,.xlsx,.xls,.pptx,.ppt,.epub,.html,.htm,.md,.markdown,.txt,.png,.jpg,.jpeg,.gif,.webp,.tiff,.tif,.svg,.rtf,.odt,.ods,.odp,.csv,.tsv,.json,.xml,.yaml,.yml,.mobi,.azw,.azw3,.cbz,.cbr,.eml,.msg,.ics,.vcf,.gpx,.kml,.tex,.bib,.zip">
                
                <div class="drop-zone-content">
                    <div class="drop-zone-icon">ğŸ“„</div>
                    <h3>Glissez-dÃ©posez ou cliquez pour sÃ©lectionner</h3>
                    <p>21 formats supportÃ©s â€¢ Analyse multi-dimensionnelle â€¢ OCR intelligent</p>
                </div>
            </div>
            
            <div class="supported-formats">
                <strong>Formats supportÃ©s (21):</strong>
                <div class="format-grid">
                    <div class="format-badge">PDF</div>
                    <div class="format-badge">Excel</div>
                    <div class="format-badge">Word</div>
                    <div class="format-badge">PowerPoint</div>
                    <div class="format-badge">EPUB</div>
                    <div class="format-badge">HTML</div>
                    <div class="format-badge">Markdown</div>
                    <div class="format-badge">TXT</div>
                    <div class="format-badge">Images</div>
                    <div class="format-badge">TIFF</div>
                    <div class="format-badge">SVG</div>
                    <div class="format-badge">RTF</div>
                    <div class="format-badge">ODT/ODS/ODP</div>
                    <div class="format-badge">CSV/TSV</div>
                    <div class="format-badge">JSON/XML</div>
                    <div class="format-badge">YAML</div>
                    <div class="format-badge">MOBI/AZW</div>
                    <div class="format-badge">Comics</div>
                    <div class="format-badge">Email</div>
                    <div class="format-badge">iCal/vCard</div>
                    <div class="format-badge">Geo</div>
                    <div class="format-badge">ZIP</div>
                </div>
            </div>
        </div>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <!-- PROGRESS -->
        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <div class="progress-container" id="progressContainer">
            <h3>Traitement en cours...</h3>
            <div class="progress-bar-container">
                <div class="progress-bar-fill" id="progressBar">0%</div>
            </div>
            <div class="progress-detail" id="progressDetail">
                <span id="progressStage">Initialisation...</span>
                <span id="progressText">Chargement...</span>
            </div>
        </div>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <!-- STATUS MESSAGE -->
        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <div class="status-message" id="statusMessage"></div>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <!-- DETECTION RESULT -->
        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <div class="section" id="detectionSection" style="display:none;">
            <!-- Rempli dynamiquement -->
        </div>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <!-- COMPOSITION OVERRIDE -->
        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <div id="compositionSection" class="composition-section">
            <h3>Ajustement Composition (Optionnel)</h3>
            
            <div class="card">
                <h4>Format Technique</h4>
                <select id="technicalOverride" onchange="updateTechnicalFormat()" style="width:100%;padding:12px;border-radius:8px;border:2px solid var(--beige-sable);font-family:Montserrat;font-size:15px;">
                    <option value="auto">DÃ©tection auto</option>
                    <option value="scanned">Document scannÃ© (OCR requis)</option>
                    <option value="digital">Texte digital (natif)</option>
                    <option value="manuscrit">Manuscrit / Ã‰criture manuelle</option>
                    <option value="photo">Photo / Capture</option>
                    <option value="image">Image vectorielle</option>
                    <option value="hybrid">Hybride (scannÃ© + digital)</option>
                </select>
            </div>
            
            <div class="card">
                <h4>Types de Contenu (Multi-sÃ©lection)</h4>
                <p style="margin-bottom:15px;color:var(--gris-secondaire);">Cochez tous les types prÃ©sents dans le document:</p>
                
                <div id="contentCheckboxes" class="content-checkboxes">
                    <label class="checkbox-label">
                        <input type="checkbox" value="partition_musicale" onchange="updateComposition()">
                        Partition musicale
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" value="tablature" onchange="updateComposition()">
                        Tablature
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" value="texte_pedagogique" onchange="updateComposition()">
                        Texte pÃ©dagogique
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" value="regles_jeu" onchange="updateComposition()">
                        RÃ¨gles de jeu
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" value="document_therapie" onchange="updateComposition()">
                        Document thÃ©rapie
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" value="questionnaire_psy" onchange="updateComposition()">
                        Questionnaire psychologique
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" value="paper_scientifique" onchange="updateComposition()">
                        Paper scientifique
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" value="manuel_technique" onchange="updateComposition()">
                        Manuel technique
                    </label>
                </div>
                
                <div id="weightsSection" class="weights-section" style="display:none;">
                    <h5>PondÃ©ration (auto-normalisÃ©e)</h5>
                    <div id="slidersList"></div>
                    <button class="btn btn-secondary btn-small" onclick="resetWeights()" style="margin-top:15px;">
                        RÃ©initialiser poids automatiques
                    </button>
                </div>
            </div>
        </div>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <!-- CONFIGURATION -->
        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <div class="section" id="configSection" style="display:none;">
            <h2>Configuration</h2>
            
            <div class="config-grid">
                <div class="config-section">
                    <h4>Plateforme IA</h4>
                    <div class="platform-selector">
                        <div class="platform-option selected" id="platformChatGPT" onclick="selectPlatform('chatgpt')">
                            <strong>ChatGPT</strong>
                            <p>GPT-4o / o1</p>
                        </div>
                        <div class="platform-option" id="platformClaude" onclick="selectPlatform('claude')">
                            <strong>Claude</strong>
                            <p>Sonnet 4 / Opus 4</p>
                        </div>
                    </div>
                    
                    <div id="gptSelectorGroup" class="model-selector" style="display:block;">
                        <label>ModÃ¨le ChatGPT:</label>
                        <select id="gptSelector" onchange="updateIndicators()">
                            <option value="gpt-4o" selected>GPT-4o (Rapide, Ã©quilibrÃ©)</option>
                            <option value="o1">o1 (Raisonnement profond)</option>
                            <option value="o1-mini">o1-mini (Rapide, efficace)</option>
                        </select>
                    </div>
                    
                    <div id="claudeSelectorGroup" class="model-selector">
                        <label>ModÃ¨le Claude:</label>
                        <select id="claudeSelector" onchange="updateIndicators()">
                            <option value="claude-sonnet-4-20250514" selected>Claude Sonnet 4 (Optimal)</option>
                            <option value="claude-opus-4-20250514">Claude Opus 4 (Maximum qualitÃ©)</option>
                        </select>
                    </div>
                    
                    <div class="indicator-grid">
                        <div class="indicator">
                            <div class="indicator-label">QualitÃ©</div>
                            <div class="indicator-value" id="qualityIndicator">Ã‰levÃ©e</div>
                        </div>
                        <div class="indicator">
                            <div class="indicator-label">Vitesse</div>
                            <div class="indicator-value" id="speedIndicator">Rapide</div>
                        </div>
                        <div class="indicator">
                            <div class="indicator-label">DÃ©tails</div>
                            <div class="indicator-value" id="detailsIndicator">Complets</div>
                        </div>
                    </div>
                </div>
                
                <div class="config-section">
                    <h4>Format Extraction</h4>
                    <select id="formatSelector" onchange="updateIndicators()" style="width:100%;padding:12px;border-radius:8px;border:2px solid var(--beige-sable);font-family:Montserrat;font-size:15px;margin-bottom:15px;">
                        <option value="7">Standard (7 modules)</option>
                        <option value="32" selected>R&D Complet (32 modules)</option>
                    </select>
                    
                    <div id="formatDesc" style="padding:15px;background:var(--blanc);border-radius:8px;"></div>
                </div>
            </div>
            
            <div style="text-align:center;margin-top:30px;">
                <button class="btn" onclick="processFile()">
                    Lancer le Traitement
                </button>
            </div>
        </div>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <!-- PARTS CONTAINER -->
        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <div class="section" id="phase2" style="display:none;">
            <h2>Traitement par Parties</h2>
            <div id="partsContainer"></div>
        </div>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <!-- EXPORT FORMATS -->
        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <div class="section export-section" id="exportSection" style="display:none;">
            <h2>Export Multi-Format</h2>
            <p style="color:var(--gris-secondaire);margin-bottom:25px;">
                Exportez vos donnÃ©es extraites dans 8 formats diffÃ©rents pour une intÃ©gration optimale avec vos outils
            </p>
            
            <!-- Export Options -->
            <div class="export-options">
                <h4>Options d'Export</h4>
                <div class="export-option-row">
                    <span class="export-option-label">Inclure mÃ©tadonnÃ©es</span>
                    <div class="export-option-control">
                        <input type="checkbox" id="exportIncludeMetadata" checked>
                    </div>
                </div>
                <div class="export-option-row">
                    <span class="export-option-label">Format d'analyse</span>
                    <div class="export-option-control">
                        <select id="exportAnalysisFormat">
                            <option value="complete">ComplÃ¨te</option>
                            <option value="summary">RÃ©sumÃ©</option>
                            <option value="none">Sans analyse</option>
                        </select>
                    </div>
                </div>
                <div class="export-option-row">
                    <span class="export-option-label">Inclure texte brut</span>
                    <div class="export-option-control">
                        <input type="checkbox" id="exportIncludeRawText" checked>
                    </div>
                </div>
            </div>
            
            <!-- Export Formats Grid -->
            <h3 style="margin-top:30px;">Formats Disponibles</h3>
            <div class="export-formats-grid">
                <div class="export-format-card" onclick="exportFormat('markdown')">
                    <div class="export-format-icon">ğŸ“</div>
                    <div class="export-format-name">Markdown</div>
                    <div class="export-format-desc">Documentation structurÃ©e avec formatage</div>
                    <span class="export-format-badge">.md</span>
                </div>
                
                <div class="export-format-card" onclick="exportFormat('pdf')">
                    <div class="export-format-icon">ğŸ“„</div>
                    <div class="export-format-name">PDF Report</div>
                    <div class="export-format-desc">Rapport professionnel imprimable</div>
                    <span class="export-format-badge">.pdf</span>
                </div>
                
                <div class="export-format-card" onclick="exportFormat('excel')">
                    <div class="export-format-icon">ğŸ“Š</div>
                    <div class="export-format-name">Excel</div>
                    <div class="export-format-desc">Feuilles de calcul avec donnÃ©es tabulaires</div>
                    <span class="export-format-badge">.xlsx</span>
                </div>
                
                <div class="export-format-card" onclick="exportFormat('jsonld')">
                    <div class="export-format-icon">ğŸ”—</div>
                    <div class="export-format-name">JSON-LD</div>
                    <div class="export-format-desc">Knowledge graph (Schema.org)</div>
                    <span class="export-format-badge">.jsonld</span>
                </div>
                
                <div class="export-format-card" onclick="exportFormat('yaml')">
                    <div class="export-format-icon">âš™ï¸</div>
                    <div class="export-format-name">YAML</div>
                    <div class="export-format-desc">Configuration lisible</div>
                    <span class="export-format-badge">.yaml</span>
                </div>
                
                <div class="export-format-card" onclick="exportFormat('obsidian')">
                    <div class="export-format-icon">ğŸ’</div>
                    <div class="export-format-name">Obsidian</div>
                    <div class="export-format-desc">Vault avec backlinks</div>
                    <span class="export-format-badge">.md + links</span>
                </div>
                
                <div class="export-format-card" onclick="exportFormat('notion')">
                    <div class="export-format-icon">ğŸ“š</div>
                    <div class="export-format-name">Notion</div>
                    <div class="export-format-desc">Import CSV pour database</div>
                    <span class="export-format-badge">.csv</span>
                </div>
                
                <div class="export-format-card" onclick="exportFormat('anki')">
                    <div class="export-format-icon">ğŸ´</div>
                    <div class="export-format-name">Anki</div>
                    <div class="export-format-desc">Flashcards pour mÃ©morisation</div>
                    <span class="export-format-badge">.txt</span>
                </div>
            </div>
            
            <!-- Export All Button -->
            <div class="export-buttons">
                <button class="export-all-btn" onclick="exportAllFormats()">
                    Exporter Tous les Formats
                </button>
            </div>
            
            <!-- Export Preview -->
            <div id="exportPreview" style="display:none;">
                <h4>AperÃ§u Export</h4>
                <div class="export-preview" id="exportPreviewContent"></div>
            </div>
        </div>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <!-- STATISTICS -->
        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <div class="section" id="statsSection" style="display:none;">
            <h2>Statistiques</h2>
            <div class="stats-grid" id="statsGrid"></div>
        </div>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <!-- FOOTER -->
        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <div class="footer">
            OCR Universel V5.1 ULTIMATE - Labo R&D Anthropic - Marie-Christine Abatte Psychologue
        </div>
    </div>

    <script>
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // GLOBAL STATE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        const STATE = {
            file: null,
            fileName: '',
            fileType: '',
            totalPages: 1,
            extractedText: '',
            analysis: null,
            documentType: '',
            detectionResult: null,
            format: 32,
            platform: 'chatgpt',
            
            // Batch processing state
            batch: {
                queue: [],              // Array of BatchItem
                status: 'idle',         // idle | running | paused | completed
                currentIndex: 0,
                startTime: null,
                pausedAt: null,
                stats: {
                    total: 0,
                    completed: 0,
                    errors: 0,
                    skipped: 0
                },
                config: {
                    maxConcurrent: 3,   // 3 files in parallel
                    retryAttempts: 2,
                    continueOnError: true,
                    autoMerge: false,
                    mergeStrategy: 'chronological' // chronological | by_type | alphabetical | flat
                }
            },
            gptModel: 'gpt-4o',
            claudeModel: 'claude-sonnet-4-20250514',
            parts: [],
            currentPartIndex: 0,
            startTime: null,
            batchSize: 30,
            ocrCache: null,
            ocrWorkerPool: null
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CONFIGURATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        const CONFIG = {
            gpt: {
                'gpt-4o': {
                    quality: 'Ã‰levÃ©e',
                    speed: 'Rapide',
                    details: 'Complets'
                },
                'o1': {
                    quality: 'Maximale',
                    speed: 'Lent',
                    details: 'Exhaustifs'
                },
                'o1-mini': {
                    quality: 'Bonne',
                    speed: 'TrÃ¨s rapide',
                    details: 'Essentiels'
                }
            },
            claude: {
                'claude-sonnet-4-20250514': {
                    quality: 'Ã‰levÃ©e',
                    speed: 'Optimal',
                    details: 'Complets'
                },
                'claude-opus-4-20250514': {
                    quality: 'Maximale',
                    speed: 'ModÃ©rÃ©',
                    details: 'Exhaustifs'
                }
            },
            format: {
                7: 'Structure hiÃ©rarchique, index conceptuel, contenu enrichi, graphe de connaissances, taxonomie, analytics (7 modules essentiels)',
                32: 'Tous les modules Standard PLUS : sÃ©mantique avancÃ©e, pÃ©dagogie, multimodal, Ã©valuation, rÃ©fÃ©rences, citations, contexte historique, applications, controverses, glossaire, stats, comparaisons, implÃ©mentation, public cible, ressources, validation, mÃ©ta-analyse, liens, temporalitÃ©, patterns, insights, analytics (32 modules R&D)'
            },
            BATCH_FACTORS: {
                base_batch_size: 30,
                technical: {
                    'scanned': 0.7,
                    'photo': 0.6,
                    'manuscrit': 0.5,
                    'digital': 1.2,
                    'image': 1.0,
                    'hybrid': 0.8
                },
                content: {
                    'partition_musicale': 0.8,
                    'tablature': 0.7,
                    'texte_pedagogique': 1.0,
                    'regles_jeu': 0.9,
                    'document_therapie': 1.1,
                    'questionnaire_psy': 1.2,
                    'paper_scientifique': 0.9,
                    'manuel_technique': 1.0,
                    'text_standard': 1.0
                }
            },
            PATTERNS: {
                technical: {
                    density_thresholds: {
                        digital_low: 0.15,
                        scanned_high: 0.5,
                        hybrid_variance: 0.1
                    }
                },
                content: {
                    partition_musicale: {
                        filename: ['partition', 'score', 'sheet', 'realbook', 'fake book', 'songbook', 'lead sheet', 'transcription', 'music', 'sade', 'aebersold'],
                        metadata: ['music', 'musical', 'score', 'composition', 'composer'],
                        text: [
                            /\b[A-G][#bâ™¯â™­]?(m|maj|min|M|dim|aug|sus)?[0-9]?\b/g,
                            /\b[A-G][#bâ™¯â™­]?7(b9|#9|b5|#5|#11)?\b/g,
                            'â™¯', 'â™­', 'â™®', 'verse', 'chorus', 'bridge', 'intro', 'outro', 'solo',
                            'refrain', 'couplet', 'walking bass', 'chord changes', 'turnaround',
                            'ii-v-i', 'cadence', 'swing', 'bossa', 'groove', 'tempo', 'bpm'
                        ]
                    },
                    tablature: {
                        filename: ['tab', 'tablature', 'guitar tab', 'bass tab'],
                        text: ['tab', 'tablature', 'fret', 'string', /[EADGBE][-|0-9]+/]
                    },
                    texte_pedagogique: {
                        filename: ['cours', 'lesson', 'tutorial', 'guide', 'method'],
                        text: ['learn', 'practice', 'exercise', 'lesson', 'apprendre', 'exercice']
                    },
                    regles_jeu: {
                        filename: ['rules', 'game', 'jeu', 'rÃ¨gles'],
                        text: ['player', 'turn', 'round', 'winner', 'joueur', 'tour', 'gagnant']
                    },
                    document_therapie: {
                        filename: ['therapy', 'couple', 'thÃ©rapie', 'therapist'],
                        text: ['therapist', 'patient', 'session', 'thÃ©rapeute', 'sÃ©ance']
                    },
                    questionnaire_psy: {
                        filename: ['questionnaire', 'test', 'evaluation', 'assessment'],
                        text: ['question', 'answer', 'score', 'Ã©chelle', 'agree', 'disagree']
                    },
                    paper_scientifique: {
                        filename: ['paper', 'article', 'research', 'Ã©tude'],
                        text: ['abstract', 'introduction', 'methodology', 'results', 'conclusion']
                    },
                    manuel_technique: {
                        filename: ['manual', 'guide', 'documentation', 'specs'],
                        text: ['installation', 'configuration', 'troubleshooting', 'specification']
                    }
                }
            }
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PROMPT MODULES (FROM V4)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        const PROMPT_MODULES = {
            technical: {
                scanned: `âš ï¸ DOCUMENT SCANNÃ‰ - OCR REQUIS
- QualitÃ© variable, possibles erreurs OCR
- VÃ©rifier cohÃ©rence texte extrait
- Signaler ambiguÃ¯tÃ©s dans notes`,
                
                digital: `âœ“ DOCUMENT DIGITAL NATIF
- Texte propre, extraction fiable
- Structure prÃ©servÃ©e`,
                
                manuscrit: `âš ï¸ Ã‰CRITURE MANUSCRITE - OCR DIFFICILE
- InterprÃ©ter au mieux
- Signaler parties illisibles`,
                
                photo: `âš ï¸ PHOTO/CAPTURE - OCR REQUIS
- QualitÃ© image variable
- Possible distorsion perspective`,
                
                image: `ğŸ–¼ï¸ IMAGE/VECTORIEL
- Possible contenu graphique dominant
- Texte peut Ãªtre secondaire`,
                
                hybrid: `âš ï¸ DOCUMENT HYBRIDE (MIXTE)
- Pages scannÃ©es + pages digitales
- Adapter traitement par section`
            },
            
            content: {
                partition_musicale: `ğŸ¸ EXTRACTION PARTITION MUSICALE

CRITICAL: Extract ALL musical content with COMPLETE accuracy.

Structure JSON:
{
  "morceaux": [
    {
      "titre": "exact title",
      "tonalite": "key (e.g. Bb, F#m)",
      "tempo": "tempo/feel (e.g. Medium Swing, 120 bpm)",
      "grille_accords": {
        "nombre_mesures": NUMBER,
        "structure": "form (AABA, Blues, etc)",
        "mesures": ["Gm7", "C7", "Fm7", "Bb7", ...]
      },
      "techniques_requises": ["Walking bass", "Chord tones", ...],
      "analyse_harmonique": {
        "cadences": ["ii-V-I bars 5-8", ...],
        "substitutions": ["tritone sub bar 12", ...],
        "modulations": [...]
      }
    }
  ]
}

INSTRUCTIONS:
1. EXTRACT ALL chord charts measure by measure
2. IDENTIFY ii-V-I cadences, turnarounds
3. NOTE bass techniques (walking, chord tones, chromatic approaches)
4. ANALYZE harmony (substitutions, modulations)
5. TRANSCRIBE tablature if present`,
                
                tablature: `ğŸ¼ EXTRACTION TABLATURE

Structure JSON:
{
  "tablatures": [
    {
      "titre": "title",
      "instrument": "4-string bass",
      "accordage": "standard (E-A-D-G)",
      "notation_complete": "E|------|\\nA|------|\\n...",
      "techniques": ["hammer-on", "pull-off", "slide", ...],
      "fingering": "1-3-4-3-1"
    }
  ]
}

INSTRUCTIONS:
1. TRANSCRIBE complete notation line by line
2. IDENTIFY techniques (H=hammer, P=pull-off, /=slide)
3. NOTE fingering if indicated`,
                
                texte_pedagogique: `ğŸ“š EXTRACTION PÃ‰DAGOGIQUE

Structure JSON:
{
  "objectifs_apprentissage": ["clear learning objectives"],
  "prerequis": ["required prior knowledge"],
  "progression": {
    "etapes": [
      {
        "numero": 1,
        "titre": "step title",
        "objectif": "step objective",
        "duree_estimee": "estimated time",
        "exercices": [...]
      }
    ]
  }
}

INSTRUCTIONS:
1. IDENTIFY explicit learning objectives
2. LIST prerequisites
3. STRUCTURE pedagogical progression
4. EXTRACT all exercises with instructions`,
                
                regles_jeu: `ğŸ² EXTRACTION RÃˆGLES JEU

Structure JSON:
{
  "nom_jeu": "game name",
  "nombre_joueurs": "player count",
  "composants": [{"nom": "component", "quantite": "quantity"}],
  "mise_en_place": {"etapes": ["setup steps"]},
  "deroulement": {"phases_tour": ["turn phases"]},
  "conditions_victoire": "win conditions"
}

INSTRUCTIONS:
1. LIST all components
2. DESCRIBE setup step by step
3. STRUCTURE turn sequence`,
                
                document_therapie: `ğŸ’‘ EXTRACTION DOCUMENT THÃ‰RAPIE

Structure JSON:
{
  "type_document": "protocole | cas_clinique | evaluation",
  "domaine": "couple | individuel | famille",
  "cas_cliniques": [
    {
      "presentation": "case presentation",
      "problematique": "issue",
      "intervention": "therapeutic intervention",
      "evolution": "outcome"
    }
  ],
  "outils_therapeutiques": [...]
}

INSTRUCTIONS:
1. IDENTIFY document type
2. EXTRACT complete clinical cases
3. LIST tools used`,
                
                questionnaire_psy: `ğŸ“‹ EXTRACTION QUESTIONNAIRE PSY

Structure JSON:
{
  "nom_questionnaire": "Big Five | NEO-PI | Gottman",
  "echelles": [
    {
      "nom": "scale name",
      "description": "what it measures",
      "items": [1, 6, 11, ...]
    }
  ],
  "items": [
    {
      "numero": 1,
      "texte": "item text",
      "echelle_inversee": true/false
    }
  ]
}

INSTRUCTIONS:
1. IDENTIFY questionnaire
2. LIST all scales/dimensions
3. EXTRACT ALL items in order`,
                
                paper_scientifique: `ğŸ”¬ EXTRACTION PAPER SCIENTIFIQUE

Structure JSON:
{
  "titre": "paper title",
  "auteurs": ["author list"],
  "abstract": "complete abstract",
  "methodologie": {
    "participants": "sample description",
    "procedure": "research procedure"
  },
  "resultats": {
    "principaux": ["key findings"]
  },
  "bibliographie": [...]
}

INSTRUCTIONS:
1. EXTRACT complete abstract
2. STRUCTURE methodology
3. LIST key results`,
                
                manuel_technique: `ğŸ”§ EXTRACTION MANUEL TECHNIQUE

Structure JSON:
{
  "produit": "product name",
  "specifications": ["technical specs"],
  "installation": {
    "prerequis": ["requirements"],
    "etapes": ["steps"]
  },
  "procedures": [...],
  "troubleshooting": [...]
}

INSTRUCTIONS:
1. LIST technical specifications
2. STRUCTURE installation procedure
3. COMPILE troubleshooting guide`
            }
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // OCR CACHE (IndexedDB)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        async function initOCRCache() {
            if (!window.idb) {
                console.warn('IndexedDB not available');
                return null;
            }
            
            try {
                const db = await idb.openDB('ocr-cache-v5', 1, {
                    upgrade(db) {
                        if (!db.objectStoreNames.contains('texts')) {
                            db.createObjectStore('texts', { keyPath: 'hash' });
                        }
                    }
                });
                
                return {
                    async get(fileHash) {
                        return await db.get('texts', fileHash);
                    },
                    
                    async set(fileHash, result) {
                        await db.put('texts', {
                            hash: fileHash,
                            result,
                            timestamp: Date.now(),
                            filename: STATE.fileName
                        });
                    },
                    
                    async hashFile(file) {
                        const buffer = await file.arrayBuffer();
                        const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
                        return Array.from(new Uint8Array(hashBuffer))
                            .map(b => b.toString(16).padStart(2, '0'))
                            .join('');
                    }
                };
            } catch (error) {
                console.error('Failed to init OCR cache:', error);
                return null;
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // OCR WORKER POOL (PARALLEL)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        class OCRWorkerPool {
            constructor() {
                const memory = navigator.deviceMemory || 4;
                const cores = navigator.hardwareConcurrency || 2;
                
                this.maxWorkers = Math.min(
                    Math.floor(memory / 0.2),
                    cores,
                    4
                );
                
                this.workers = [];
                this.queue = [];
                
                console.log(`OCR Worker Pool: ${this.maxWorkers} workers max`);
            }
            
            async recognize(file) {
                if (STATE.ocrCache) {
                    const fileHash = await STATE.ocrCache.hashFile(file);
                    const cached = await STATE.ocrCache.get(fileHash);
                    
                    if (cached && Date.now() - cached.timestamp < 7 * 24 * 3600 * 1000) {
                        console.log('Cache hit:', file.name);
                        showStatus('Texte trouvÃ© en cache !', 'success');
                        return cached.result;
                    }
                }
                
                return new Promise((resolve, reject) => {
                    this.queue.push({ file, resolve, reject });
                    this.processQueue();
                });
            }
            
            async processQueue() {
                while (this.workers.length < this.maxWorkers && this.queue.length > 0) {
                    const job = this.queue.shift();
                    
                    this.executeOCR(job);
                }
            }
            
            async executeOCR(job) {
                const workerIndex = this.workers.length;
                this.workers.push(job);
                
                try {
                    showStatus(`OCR en cours (worker ${workerIndex + 1})...`, 'info');
                    
                    const { data: { text, confidence } } = await Tesseract.recognize(
                        job.file,
                        'fra+eng',
                        {
                            logger: m => {
                                if (m.status === 'recognizing text') {
                                    const pct = Math.round(m.progress * 100);
                                    updateProgress(30 + pct * 0.5, `OCR Worker ${workerIndex + 1}`, `${pct}%`);
                                }
                            }
                        }
                    );
                    
                    const result = {
                        text: text.trim(),
                        confidence: confidence / 100,
                        wordCount: text.split(/\s+/).length,
                        method: 'tesseract_ocr_parallel'
                    };
                    
                    if (STATE.ocrCache) {
                        const fileHash = await STATE.ocrCache.hashFile(job.file);
                        await STATE.ocrCache.set(fileHash, result);
                    }
                    
                    job.resolve(result);
                    
                } catch (error) {
                    console.error('OCR error:', error);
                    job.reject(error);
                    
                } finally {
                    this.workers = this.workers.filter(w => w !== job);
                    this.processQueue();
                }
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BATCH PROGRESS TRACKER
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        class BatchProgressTracker {
            constructor() {
                this.items = new Map(); // fileId -> progress data
            }
            
            initFile(fileId, fileName, totalPages) {
                this.items.set(fileId, {
                    fileId,
                    fileName,
                    totalPages,
                    currentPage: 0,
                    phase: 'queued', // queued | extracting | analyzing | generating | completed | error
                    progress: 0,     // 0-100%
                    startTime: null,
                    endTime: null,
                    error: null,
                    lastMessage: ''
                });
            }
            
            updateProgress(fileId, phase, progress, message = '') {
                const item = this.items.get(fileId);
                if (!item) return;
                
                item.phase = phase;
                item.progress = Math.min(100, Math.max(0, progress));
                item.lastMessage = message;
                
                if (phase === 'extracting' && !item.startTime) {
                    item.startTime = Date.now();
                }
                
                if (phase === 'completed' || phase === 'error') {
                    item.endTime = Date.now();
                }
                
                // Update UI
                this.renderFileProgress(fileId);
            }
            
            setError(fileId, error) {
                const item = this.items.get(fileId);
                if (!item) return;
                
                item.phase = 'error';
                item.error = error;
                item.endTime = Date.now();
                
                this.renderFileProgress(fileId);
            }
            
            renderFileProgress(fileId) {
                const item = this.items.get(fileId);
                if (!item) return;
                
                const card = document.querySelector(`[data-file-id="${fileId}"]`);
                if (!card) return;
                
                // Update progress bar
                const progressBar = card.querySelector('.batch-progress-fill');
                if (progressBar) {
                    progressBar.style.width = `${item.progress}%`;
                }
                
                // Update status badge
                const statusBadge = card.querySelector('.batch-file-status');
                if (statusBadge) {
                    statusBadge.textContent = this.getPhaseLabel(item.phase);
                    statusBadge.className = `batch-file-status status-${item.phase}`;
                }
                
                // Update message
                const messageDiv = card.querySelector('.batch-progress-message');
                if (messageDiv) {
                    messageDiv.textContent = item.lastMessage || '';
                }
                
                // Show/hide error message
                let errorDiv = card.querySelector('.batch-error-message');
                if (item.error) {
                    if (!errorDiv) {
                        errorDiv = document.createElement('div');
                        errorDiv.className = 'batch-error-message';
                        card.appendChild(errorDiv);
                    }
                    errorDiv.textContent = item.error;
                } else if (errorDiv) {
                    errorDiv.remove();
                }
            }
            
            getPhaseLabel(phase) {
                const labels = {
                    queued: 'En attente',
                    extracting: 'Extraction...',
                    analyzing: 'Analyse...',
                    generating: 'GÃ©nÃ©ration prompts...',
                    completed: 'TerminÃ©',
                    error: 'Erreur'
                };
                return labels[phase] || phase;
            }
            
            getFileData(fileId) {
                return this.items.get(fileId);
            }
            
            getAllCompleted() {
                return Array.from(this.items.values()).filter(item => item.phase === 'completed');
            }
            
            getAllErrors() {
                return Array.from(this.items.values()).filter(item => item.phase === 'error');
            }
            
            clear() {
                this.items.clear();
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BATCH ERROR HANDLER
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        class BatchErrorHandler {
            constructor(config) {
                this.maxRetries = config.retryAttempts || 2;
                this.continueOnError = config.continueOnError !== false;
                this.errors = new Map(); // fileId -> error details
            }
            
            async processWithRetry(fileId, processFunc) {
                let attempt = 0;
                let lastError = null;
                
                while (attempt <= this.maxRetries) {
                    try {
                        const result = await processFunc();
                        return { success: true, result };
                        
                    } catch (error) {
                        lastError = error;
                        attempt++;
                        
                        console.error(`Attempt ${attempt}/${this.maxRetries + 1} failed for ${fileId}:`, error);
                        
                        if (attempt <= this.maxRetries) {
                            // Exponential backoff: 2^attempt seconds
                            const backoffMs = Math.pow(2, attempt) * 1000;
                            console.log(`Waiting ${backoffMs}ms before retry...`);
                            await this.sleep(backoffMs);
                        }
                    }
                }
                
                // All retries exhausted
                this.logError(fileId, lastError, attempt);
                
                if (this.continueOnError) {
                    return { success: false, error: lastError };
                } else {
                    throw lastError;
                }
            }
            
            logError(fileId, error, attempts) {
                this.errors.set(fileId, {
                    error: error.message || String(error),
                    stack: error.stack,
                    attempts,
                    timestamp: Date.now()
                });
            }
            
            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
            
            getErrorReport() {
                const report = [];
                this.errors.forEach((details, fileId) => {
                    report.push({
                        fileId,
                        error: details.error,
                        attempts: details.attempts,
                        timestamp: new Date(details.timestamp).toISOString()
                    });
                });
                return report;
            }
            
            clearErrors() {
                this.errors.clear();
            }
            
            hasErrors() {
                return this.errors.size > 0;
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BATCH CONTROLLER
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        class BatchController {
            constructor() {
                this.status = 'idle';
                this.pauseRequested = false;
                this.progressTracker = new BatchProgressTracker();
                this.errorHandler = new BatchErrorHandler(STATE.batch.config);
            }
            
            async startBatch() {
                if (this.status === 'running') {
                    console.warn('Batch already running');
                    return;
                }
                
                if (STATE.batch.queue.length === 0) {
                    showStatus('Aucun fichier dans la file batch', 'warning');
                    return;
                }
                
                this.status = 'running';
                this.pauseRequested = false;
                STATE.batch.status = 'running';
                STATE.batch.startTime = Date.now();
                
                // Update UI
                updateBatchButtons();
                document.getElementById('batchStats').style.display = 'grid';
                
                showStatus('DÃ©marrage du batch...', 'info');
                
                await this.processBatchQueue();
            }
            
            pauseBatch() {
                if (this.status !== 'running') return;
                
                this.pauseRequested = true;
                STATE.batch.status = 'paused';
                STATE.batch.pausedAt = Date.now();
                
                updateBatchButtons();
                showStatus('Pause demandÃ©e... Fin du fichier en cours', 'info');
            }
            
            async resumeBatch() {
                if (this.status !== 'paused') return;
                
                this.pauseRequested = false;
                this.status = 'running';
                STATE.batch.status = 'running';
                
                updateBatchButtons();
                showStatus('Reprise du batch...', 'success');
                
                await this.processBatchQueue();
            }
            
            async processBatchQueue() {
                const queue = STATE.batch.queue;
                const config = STATE.batch.config;
                
                while (STATE.batch.currentIndex < queue.length && !this.pauseRequested) {
                    const concurrentPromises = [];
                    
                    // Process maxConcurrent files in parallel
                    for (let i = 0; i < config.maxConcurrent && STATE.batch.currentIndex < queue.length; i++) {
                        const index = STATE.batch.currentIndex++;
                        const item = queue[index];
                        
                        // Skip already completed or errored
                        if (item.status === 'completed' || item.status === 'error') continue;
                        
                        const promise = this.processFileInBatch(item, index);
                        concurrentPromises.push(promise);
                    }
                    
                    await Promise.all(concurrentPromises);
                    
                    // Update stats
                    updateBatchStats();
                }
                
                // Check if paused or completed
                if (this.pauseRequested) {
                    this.status = 'paused';
                    showStatus('Batch en pause', 'info');
                } else {
                    this.status = 'completed';
                    STATE.batch.status = 'completed';
                    showStatus(`Batch terminÃ© ! ${STATE.batch.stats.completed} fichiers traitÃ©s`, 'success');
                    updateBatchButtons();
                }
            }
            
            async processFileInBatch(item, index) {
                try {
                    item.status = 'processing';
                    this.progressTracker.initFile(item.id, item.file.name, 1);
                    
                    // Update UI
                    renderBatchItem(item, index);
                    
                    // Process with retry logic
                    const result = await this.errorHandler.processWithRetry(
                        item.id,
                        async () => await this.processFile(item)
                    );
                    
                    if (result.success) {
                        item.status = 'completed';
                        item.result = result.result;
                        STATE.batch.stats.completed++;
                        this.progressTracker.updateProgress(item.id, 'completed', 100, 'Fichier traitÃ© avec succÃ¨s');
                    } else {
                        item.status = 'error';
                        item.error = result.error.message || String(result.error);
                        STATE.batch.stats.errors++;
                        this.progressTracker.setError(item.id, item.error);
                    }
                    
                } catch (error) {
                    item.status = 'error';
                    item.error = error.message || String(error);
                    STATE.batch.stats.errors++;
                    this.progressTracker.setError(item.id, item.error);
                }
                
                renderBatchItem(item, index);
            }
            
            async processFile(item) {
                // Phase 1: Extraction
                this.progressTracker.updateProgress(item.id, 'extracting', 10, 'Extraction du texte...');
                
                const fileType = item.file.name.split('.').pop().toLowerCase();
                let extractedText = '';
                
                // Extract text based on file type
                try {
                    if (fileType === 'pdf') {
                        extractedText = await this.extractPDFText(item.file);
                    } else if (['txt', 'md', 'markdown'].includes(fileType)) {
                        extractedText = await item.file.text();
                    } else if (['docx', 'doc'].includes(fileType)) {
                        extractedText = await this.extractDOCXText(item.file);
                    } else if (['xlsx', 'xls'].includes(fileType)) {
                        extractedText = await this.extractExcelText(item.file);
                    } else if (['epub'].includes(fileType)) {
                        extractedText = await this.extractEPUBText(item.file);
                    } else if (['html', 'htm'].includes(fileType)) {
                        extractedText = await this.extractHTMLText(item.file);
                    } else if (['csv', 'tsv'].includes(fileType)) {
                        extractedText = await this.extractCSVText(item.file);
                    } else if (['json'].includes(fileType)) {
                        extractedText = await this.extractJSONText(item.file);
                    } else if (['xml'].includes(fileType)) {
                        extractedText = await this.extractXMLText(item.file);
                    } else if (['yaml', 'yml'].includes(fileType)) {
                        extractedText = await this.extractYAMLText(item.file);
                    } else if (['png', 'jpg', 'jpeg', 'gif', 'webp', 'tiff', 'tif'].includes(fileType)) {
                        // Images need OCR
                        extractedText = await this.extractImageTextOCR(item.file);
                    } else {
                        // Generic text extraction attempt
                        extractedText = await item.file.text();
                    }
                } catch (error) {
                    console.error(`Error extracting ${fileType}:`, error);
                    throw new Error(`Impossible d'extraire le texte de ${fileType}: ${error.message}`);
                }
                
                this.progressTracker.updateProgress(item.id, 'extracting', 40, 'Texte extrait');
                
                // Phase 2: Analysis
                this.progressTracker.updateProgress(item.id, 'analyzing', 50, 'Analyse du contenu...');
                
                // Create extractedData object with required properties
                const extractedData = {
                    text: extractedText,
                    method: `batch_${fileType}`,
                    confidence: 0.9,
                    wordCount: extractedText.split(/\s+/).length
                };
                
                const analysis = await detectDocumentMultiDimensionalFromText(
                    item.file, 
                    extractedText, 
                    extractedData
                );
                
                this.progressTracker.updateProgress(item.id, 'analyzing', 70, 'Analyse terminÃ©e');
                
                // Phase 3: Generate prompt
                this.progressTracker.updateProgress(item.id, 'generating', 80, 'GÃ©nÃ©ration du prompt...');
                
                const prompt = generatePrompt({
                    file: item.file,
                    fileName: item.file.name,
                    extractedText,
                    analysis,
                    totalPages: 1
                });
                
                this.progressTracker.updateProgress(item.id, 'generating', 100, 'Prompt gÃ©nÃ©rÃ©');
                
                return {
                    fileName: item.file.name,
                    extractedText,
                    analysis,
                    prompt
                };
            }
            
            async extractPDFText(file) {
                const arrayBuffer = await file.arrayBuffer();
                const pdfDoc = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                let fullText = '';
                
                for (let i = 1; i <= pdfDoc.numPages; i++) {
                    const page = await pdfDoc.getPage(i);
                    const textContent = await page.getTextContent();
                    const pageText = textContent.items.map(item => item.str).join(' ');
                    fullText += pageText + '\n';
                }
                
                return fullText;
            }
            
            async extractDOCXText(file) {
                const arrayBuffer = await file.arrayBuffer();
                const result = await mammoth.extractRawText({ arrayBuffer });
                return result.value;
            }
            
            async extractExcelText(file) {
                const arrayBuffer = await file.arrayBuffer();
                const data = new Uint8Array(arrayBuffer);
                const workbook = XLSX.read(data, { type: 'array' });
                let text = '';
                
                workbook.SheetNames.forEach(sheetName => {
                    const sheet = workbook.Sheets[sheetName];
                    const csv = XLSX.utils.sheet_to_csv(sheet);
                    text += `Sheet: ${sheetName}\n${csv}\n\n`;
                });
                
                return text;
            }
            
            async extractEPUBText(file) {
                // EPUB is a ZIP containing HTML/XHTML
                const arrayBuffer = await file.arrayBuffer();
                const zip = await JSZip.loadAsync(arrayBuffer);
                let text = '';
                
                // Find content files (usually in OEBPS or content folder)
                for (const [path, zipEntry] of Object.entries(zip.files)) {
                    if (path.match(/\.(html|xhtml|xml)$/i) && !zipEntry.dir) {
                        const content = await zipEntry.async('text');
                        // Strip HTML tags
                        const stripped = content.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ');
                        text += stripped + '\n';
                    }
                }
                
                return text || 'Unable to extract EPUB text';
            }
            
            async extractHTMLText(file) {
                const content = await file.text();
                // Create temporary div to parse HTML
                const div = document.createElement('div');
                div.innerHTML = content;
                return div.textContent || div.innerText || '';
            }
            
            async extractCSVText(file) {
                const content = await file.text();
                const parsed = Papa.parse(content);
                return parsed.data.map(row => row.join(' | ')).join('\n');
            }
            
            async extractJSONText(file) {
                const content = await file.text();
                const json = JSON.parse(content);
                return JSON.stringify(json, null, 2);
            }
            
            async extractXMLText(file) {
                const content = await file.text();
                // Strip XML tags for simple text extraction
                return content.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ');
            }
            
            async extractYAMLText(file) {
                const content = await file.text();
                try {
                    const data = jsyaml.load(content);
                    return JSON.stringify(data, null, 2);
                } catch (error) {
                    return content; // Return raw if parsing fails
                }
            }
            
            async extractImageTextOCR(file) {
                // Check cache first
                if (STATE.ocrCache) {
                    const fileHash = await STATE.ocrCache.hashFile(file);
                    const cached = await STATE.ocrCache.get(fileHash);
                    if (cached) {
                        return cached.result.text;
                    }
                }
                
                // Perform OCR
                const { data: { text } } = await Tesseract.recognize(
                    file,
                    'fra+eng',
                    {
                        logger: () => {} // Silent for batch
                    }
                );
                
                // Cache result
                if (STATE.ocrCache) {
                    const fileHash = await STATE.ocrCache.hashFile(file);
                    await STATE.ocrCache.set(fileHash, { text, confidence: 0.9, method: 'batch_ocr' });
                }
                
                return text;
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // EXPORT MANAGER
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        class ExportManager {
            constructor() {
                this.formats = ['markdown', 'pdf', 'excel', 'jsonld', 'yaml', 'obsidian', 'notion', 'anki'];
                this.options = {
                    includeMetadata: true,
                    analysisFormat: 'complete',
                    includeRawText: true
                };
            }
            
            updateOptions() {
                this.options.includeMetadata = document.getElementById('exportIncludeMetadata')?.checked || true;
                this.options.analysisFormat = document.getElementById('exportAnalysisFormat')?.value || 'complete';
                this.options.includeRawText = document.getElementById('exportIncludeRawText')?.checked || true;
            }
            
            // â•â•â• MARKDOWN EXPORT â•â•â•
            async exportMarkdown() {
                this.updateOptions();
                
                let markdown = `# ${STATE.fileName}\n\n`;
                
                // Metadata
                if (this.options.includeMetadata) {
                    markdown += `## MÃ©tadonnÃ©es\n\n`;
                    markdown += `- **Fichier**: ${STATE.fileName}\n`;
                    markdown += `- **Pages**: ${STATE.totalPages}\n`;
                    markdown += `- **Format**: ${STATE.fileType.toUpperCase()}\n`;
                    markdown += `- **Date**: ${new Date().toLocaleDateString('fr-FR')}\n`;
                    markdown += `- **Taille**: ${(STATE.file.size / 1024 / 1024).toFixed(2)} MB\n\n`;
                }
                
                // Analysis
                if (this.options.analysisFormat !== 'none' && STATE.analysis) {
                    markdown += `## Analyse\n\n`;
                    
                    if (STATE.analysis.technical) {
                        markdown += `### Technique\n\n`;
                        markdown += `- **Format**: ${STATE.analysis.technical.format}\n`;
                        markdown += `- **QualitÃ©**: ${STATE.analysis.technical.quality || 'N/A'}\n`;
                        markdown += `- **OCR requis**: ${STATE.analysis.technical.ocr_required ? 'Oui' : 'Non'}\n\n`;
                    }
                    
                    if (STATE.analysis.composition) {
                        markdown += `### Composition\n\n`;
                        markdown += `- **Type primaire**: ${STATE.analysis.composition.primary}\n`;
                        if (STATE.analysis.composition.secondary?.length > 0) {
                            markdown += `- **Types secondaires**: ${STATE.analysis.composition.secondary.join(', ')}\n`;
                        }
                        markdown += `\n`;
                    }
                }
                
                // Content
                if (this.options.includeRawText && STATE.extractedText) {
                    markdown += `## Contenu Extrait\n\n`;
                    markdown += `\`\`\`\n${STATE.extractedText.substring(0, 5000)}\n\`\`\`\n\n`;
                    if (STATE.extractedText.length > 5000) {
                        markdown += `*... (${STATE.extractedText.length - 5000} caractÃ¨res supplÃ©mentaires)*\n\n`;
                    }
                }
                
                // Parts/Sections
                if (STATE.parts && STATE.parts.length > 0) {
                    markdown += `## Parties\n\n`;
                    STATE.parts.forEach((part, index) => {
                        markdown += `### Partie ${index + 1} (Pages ${part.startPage}-${part.endPage})\n\n`;
                        if (part.json) {
                            markdown += `- **Statut**: ${part.status}\n`;
                            markdown += `- **Modules**: ${Object.keys(part.json).length}\n\n`;
                        }
                    });
                }
                
                markdown += `---\n\n*GÃ©nÃ©rÃ© avec OCR Universel V5.1 ULTIMATE*\n`;
                
                return markdown;
            }
            
            // â•â•â• YAML EXPORT â•â•â•
            async exportYAML() {
                this.updateOptions();
                
                const data = {
                    metadata: {
                        fileName: STATE.fileName,
                        totalPages: STATE.totalPages,
                        fileType: STATE.fileType,
                        fileSize: STATE.file.size,
                        exportDate: new Date().toISOString(),
                        generator: 'OCR Universel V5.1 ULTIMATE'
                    }
                };
                
                if (this.options.analysisFormat !== 'none' && STATE.analysis) {
                    data.analysis = {
                        technical: STATE.analysis.technical || {},
                        composition: STATE.analysis.composition || {},
                        content: STATE.analysis.content || {}
                    };
                }
                
                if (this.options.includeRawText && STATE.extractedText) {
                    data.content = {
                        text: STATE.extractedText,
                        wordCount: STATE.extractedText.split(/\s+/).length,
                        characterCount: STATE.extractedText.length
                    };
                }
                
                if (STATE.parts && STATE.parts.length > 0) {
                    data.parts = STATE.parts.map((part, index) => ({
                        partNumber: index + 1,
                        startPage: part.startPage,
                        endPage: part.endPage,
                        status: part.status,
                        hasJSON: !!part.json
                    }));
                }
                
                return jsyaml.dump(data, { indent: 2, lineWidth: 120 });
            }
            
            // â•â•â• JSON-LD EXPORT (Knowledge Graph) â•â•â•
            async exportJSONLD() {
                this.updateOptions();
                
                const jsonld = {
                    "@context": "https://schema.org",
                    "@type": "DigitalDocument",
                    "name": STATE.fileName,
                    "encodingFormat": STATE.fileType,
                    "contentSize": `${(STATE.file.size / 1024 / 1024).toFixed(2)} MB`,
                    "dateCreated": new Date().toISOString(),
                    "creator": {
                        "@type": "SoftwareApplication",
                        "name": "OCR Universel V5.1 ULTIMATE",
                        "applicationCategory": "OCR Software",
                        "operatingSystem": "Web Browser"
                    }
                };
                
                if (STATE.analysis) {
                    jsonld.about = {
                        "@type": "Thing",
                        "name": STATE.analysis.composition?.primary || "Document",
                        "description": `Type: ${STATE.analysis.technical?.format || 'unknown'}`
                    };
                }
                
                if (STATE.extractedText && this.options.includeRawText) {
                    jsonld.text = STATE.extractedText.substring(0, 1000);
                    jsonld.wordCount = STATE.extractedText.split(/\s+/).length;
                }
                
                if (STATE.parts && STATE.parts.length > 0) {
                    jsonld.hasPart = STATE.parts.map((part, index) => ({
                        "@type": "Chapter",
                        "position": index + 1,
                        "pageStart": part.startPage,
                        "pageEnd": part.endPage
                    }));
                }
                
                return JSON.stringify(jsonld, null, 2);
            }
            
            // â•â•â• EXCEL EXPORT â•â•â•
            async exportExcel() {
                this.updateOptions();
                
                const workbook = XLSX.utils.book_new();
                
                // Sheet 1: Metadata
                const metadataData = [
                    ['PropriÃ©tÃ©', 'Valeur'],
                    ['Nom du fichier', STATE.fileName],
                    ['Pages totales', STATE.totalPages],
                    ['Type de fichier', STATE.fileType],
                    ['Taille', `${(STATE.file.size / 1024 / 1024).toFixed(2)} MB`],
                    ['Date export', new Date().toLocaleDateString('fr-FR')]
                ];
                
                if (STATE.analysis) {
                    metadataData.push(['Format technique', STATE.analysis.technical?.format || 'N/A']);
                    metadataData.push(['Type primaire', STATE.analysis.composition?.primary || 'N/A']);
                }
                
                const ws1 = XLSX.utils.aoa_to_sheet(metadataData);
                XLSX.utils.book_append_sheet(workbook, ws1, 'MÃ©tadonnÃ©es');
                
                // Sheet 2: Analysis
                if (STATE.analysis && this.options.analysisFormat !== 'none') {
                    const analysisData = [['CatÃ©gorie', 'PropriÃ©tÃ©', 'Valeur']];
                    
                    if (STATE.analysis.technical) {
                        Object.entries(STATE.analysis.technical).forEach(([key, value]) => {
                            analysisData.push(['Technique', key, String(value)]);
                        });
                    }
                    
                    if (STATE.analysis.composition) {
                        Object.entries(STATE.analysis.composition).forEach(([key, value]) => {
                            analysisData.push(['Composition', key, JSON.stringify(value)]);
                        });
                    }
                    
                    const ws2 = XLSX.utils.aoa_to_sheet(analysisData);
                    XLSX.utils.book_append_sheet(workbook, ws2, 'Analyse');
                }
                
                // Sheet 3: Parts
                if (STATE.parts && STATE.parts.length > 0) {
                    const partsData = [['Partie', 'Page dÃ©but', 'Page fin', 'Statut']];
                    STATE.parts.forEach((part, index) => {
                        partsData.push([index + 1, part.startPage, part.endPage, part.status]);
                    });
                    
                    const ws3 = XLSX.utils.aoa_to_sheet(partsData);
                    XLSX.utils.book_append_sheet(workbook, ws3, 'Parties');
                }
                
                return XLSX.write(workbook, { type: 'binary', bookType: 'xlsx' });
            }
            
            // â•â•â• OBSIDIAN VAULT EXPORT â•â•â•
            async exportObsidian() {
                this.updateOptions();
                
                const vaultName = STATE.fileName.replace(/\.[^/.]+$/, '');
                const zip = new JSZip();
                const folder = zip.folder(vaultName);
                
                // Main note
                let mainNote = `# ${STATE.fileName}\n\n`;
                mainNote += `[[Metadata]] | [[Analysis]] | [[Content]]\n\n`;
                mainNote += `## Vue d'ensemble\n\n`;
                mainNote += `Ce document a Ã©tÃ© traitÃ© avec OCR Universel V5.1.\n\n`;
                
                if (STATE.analysis) {
                    mainNote += `**Type**: #${STATE.analysis.composition?.primary || 'document'}\n`;
                    mainNote += `**Format**: ${STATE.analysis.technical?.format || 'unknown'}\n\n`;
                }
                
                folder.file(`${vaultName}.md`, mainNote);
                
                // Metadata note
                let metadataNote = `# Metadata\n\n`;
                metadataNote += `[[${vaultName}|â† Retour]]\n\n`;
                metadataNote += `- Fichier: ${STATE.fileName}\n`;
                metadataNote += `- Pages: ${STATE.totalPages}\n`;
                metadataNote += `- Taille: ${(STATE.file.size / 1024 / 1024).toFixed(2)} MB\n`;
                folder.file('Metadata.md', metadataNote);
                
                // Analysis note
                if (STATE.analysis) {
                    let analysisNote = `# Analysis\n\n`;
                    analysisNote += `[[${vaultName}|â† Retour]]\n\n`;
                    analysisNote += `## Technique\n\n`;
                    analysisNote += `\`\`\`json\n${JSON.stringify(STATE.analysis.technical, null, 2)}\n\`\`\`\n\n`;
                    folder.file('Analysis.md', analysisNote);
                }
                
                // Content note
                if (STATE.extractedText && this.options.includeRawText) {
                    let contentNote = `# Content\n\n`;
                    contentNote += `[[${vaultName}|â† Retour]]\n\n`;
                    contentNote += STATE.extractedText;
                    folder.file('Content.md', contentNote);
                }
                
                return await zip.generateAsync({ type: 'blob' });
            }
            
            // â•â•â• NOTION CSV EXPORT â•â•â•
            async exportNotion() {
                this.updateOptions();
                
                const rows = [
                    ['Nom', 'Type', 'Pages', 'Taille', 'Format technique', 'Type primaire', 'Date']
                ];
                
                rows.push([
                    STATE.fileName,
                    STATE.fileType,
                    STATE.totalPages,
                    `${(STATE.file.size / 1024 / 1024).toFixed(2)} MB`,
                    STATE.analysis?.technical?.format || 'N/A',
                    STATE.analysis?.composition?.primary || 'N/A',
                    new Date().toLocaleDateString('fr-FR')
                ]);
                
                return Papa.unparse(rows);
            }
            
            // â•â•â• ANKI FLASHCARDS EXPORT â•â•â•
            async exportAnki() {
                this.updateOptions();
                
                let ankiText = '';
                
                // Main card
                ankiText += `Document: ${STATE.fileName}\t`;
                ankiText += `Type: ${STATE.analysis?.composition?.primary || 'Document'}, `;
                ankiText += `${STATE.totalPages} pages, `;
                ankiText += `Format: ${STATE.analysis?.technical?.format || 'unknown'}\n`;
                
                // Analysis cards
                if (STATE.analysis && this.options.analysisFormat !== 'none') {
                    if (STATE.analysis.technical) {
                        ankiText += `Format technique de ${STATE.fileName}\t${STATE.analysis.technical.format}\n`;
                        ankiText += `QualitÃ© OCR de ${STATE.fileName}\t${STATE.analysis.technical.quality || 'N/A'}\n`;
                    }
                    
                    if (STATE.analysis.composition) {
                        ankiText += `Type primaire de ${STATE.fileName}\t${STATE.analysis.composition.primary}\n`;
                        if (STATE.analysis.composition.weights) {
                            Object.entries(STATE.analysis.composition.weights).forEach(([type, weight]) => {
                                ankiText += `Poids ${type} dans ${STATE.fileName}\t${Math.round(weight * 100)}%\n`;
                            });
                        }
                    }
                }
                
                // Parts cards
                if (STATE.parts && STATE.parts.length > 1) {
                    STATE.parts.forEach((part, index) => {
                        ankiText += `Partie ${index + 1} de ${STATE.fileName}\tPages ${part.startPage}-${part.endPage}\n`;
                    });
                }
                
                return ankiText;
            }
            
            // â•â•â• PDF REPORT EXPORT (using jsPDF via HTML) â•â•â•
            async exportPDF() {
                // Note: This is a simplified version
                // In production, you'd use jsPDF library
                showStatus('Export PDF: Utilisez le bouton "Imprimer" du navigateur et "Enregistrer en PDF"', 'info');
                
                const printWindow = window.open('', '_blank');
                let html = `
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <title>${STATE.fileName} - Report</title>
                        <style>
                            body { font-family: Arial, sans-serif; padding: 40px; line-height: 1.6; }
                            h1 { color: #8FAFB1; border-bottom: 3px solid #C8D0C3; padding-bottom: 10px; }
                            h2 { color: #8FAFB1; margin-top: 30px; }
                            .metadata { background: #E6D7C3; padding: 20px; border-radius: 8px; margin: 20px 0; }
                            .metadata p { margin: 5px 0; }
                            table { width: 100%; border-collapse: collapse; margin: 20px 0; }
                            th, td { border: 1px solid #ddd; padding: 12px; text-align: left; }
                            th { background: #8FAFB1; color: white; }
                            .footer { text-align: center; margin-top: 50px; color: #666; font-size: 12px; }
                        </style>
                    </head>
                    <body>
                        <h1>${STATE.fileName}</h1>
                        
                        <div class="metadata">
                            <h2>MÃ©tadonnÃ©es</h2>
                            <p><strong>Fichier:</strong> ${STATE.fileName}</p>
                            <p><strong>Pages:</strong> ${STATE.totalPages}</p>
                            <p><strong>Type:</strong> ${STATE.fileType.toUpperCase()}</p>
                            <p><strong>Taille:</strong> ${(STATE.file.size / 1024 / 1024).toFixed(2)} MB</p>
                            <p><strong>Date:</strong> ${new Date().toLocaleDateString('fr-FR')}</p>
                        </div>
                `;
                
                if (STATE.analysis) {
                    html += `
                        <h2>Analyse</h2>
                        <table>
                            <tr><th>PropriÃ©tÃ©</th><th>Valeur</th></tr>
                            <tr><td>Format technique</td><td>${STATE.analysis.technical?.format || 'N/A'}</td></tr>
                            <tr><td>QualitÃ©</td><td>${STATE.analysis.technical?.quality || 'N/A'}</td></tr>
                            <tr><td>Type primaire</td><td>${STATE.analysis.composition?.primary || 'N/A'}</td></tr>
                        </table>
                    `;
                }
                
                html += `
                        <div class="footer">
                            GÃ©nÃ©rÃ© avec OCR Universel V5.1 ULTIMATE - ${new Date().toLocaleDateString('fr-FR')}
                        </div>
                    </body>
                    </html>
                `;
                
                printWindow.document.write(html);
                printWindow.document.close();
                
                return null; // User handles print/save
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // INITIALIZATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        (async () => {
            STATE.ocrCache = await initOCRCache();
            STATE.ocrWorkerPool = new OCRWorkerPool();
            STATE.batchController = new BatchController();
            STATE.exportManager = new ExportManager();
        })();

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TEMPLATES
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        const TEMPLATES = {
            realbook_jazz: {
                name: 'Real Book Jazz',
                analysis: {
                    technical: { format: 'scanned', quality: 'medium', ocr_required: true },
                    content: {
                        detected: [
                            { type: 'partition_musicale', score: 85, confidence: 0.85 },
                            { type: 'texte_pedagogique', score: 35, confidence: 0.35 }
                        ],
                        selected: ['partition_musicale', 'texte_pedagogique']
                    },
                    composition: {
                        primary: 'partition_musicale',
                        secondary: ['texte_pedagogique'],
                        weights: { partition_musicale: 0.70, texte_pedagogique: 0.30 },
                        auto_weights: { partition_musicale: 0.70, texte_pedagogique: 0.30 }
                    }
                },
                format: 32,
                platform: 'chatgpt',
                model: 'gpt-4o'
            },
            
            sade_songbook: {
                name: 'Sade Songbook',
                analysis: {
                    technical: { format: 'digital', quality: 'high', ocr_required: false },
                    content: {
                        detected: [{ type: 'partition_musicale', score: 100, confidence: 1.0 }],
                        selected: ['partition_musicale']
                    },
                    composition: {
                        primary: 'partition_musicale',
                        secondary: [],
                        weights: { partition_musicale: 1.0 },
                        auto_weights: { partition_musicale: 1.0 }
                    }
                },
                format: 32,
                platform: 'chatgpt',
                model: 'gpt-4o'
            },
            
            therapy_doc: {
                name: 'Document ThÃ©rapie',
                analysis: {
                    technical: { format: 'digital', quality: 'high', ocr_required: false },
                    content: {
                        detected: [
                            { type: 'document_therapie', score: 80, confidence: 0.80 },
                            { type: 'questionnaire_psy', score: 20, confidence: 0.20 }
                        ],
                        selected: ['document_therapie', 'questionnaire_psy']
                    },
                    composition: {
                        primary: 'document_therapie',
                        secondary: ['questionnaire_psy'],
                        weights: { document_therapie: 0.80, questionnaire_psy: 0.20 },
                        auto_weights: { document_therapie: 0.80, questionnaire_psy: 0.20 }
                    }
                },
                format: 32,
                platform: 'claude',
                model: 'claude-sonnet-4-20250514'
            },
            
            scientific_paper: {
                name: 'Paper Scientifique',
                analysis: {
                    technical: { format: 'digital', quality: 'high', ocr_required: false },
                    content: {
                        detected: [{ type: 'paper_scientifique', score: 100, confidence: 1.0 }],
                        selected: ['paper_scientifique']
                    },
                    composition: {
                        primary: 'paper_scientifique',
                        secondary: [],
                        weights: { paper_scientifique: 1.0 },
                        auto_weights: { paper_scientifique: 1.0 }
                    }
                },
                format: 32,
                platform: 'chatgpt',
                model: 'gpt-4o'
            }
        };
        
        function loadTemplate(templateId) {
            const template = TEMPLATES[templateId];
            if (!template) return;
            
            showStatus(`Template "${template.name}" chargÃ© !`, 'success');
            
            STATE.format = template.format;
            STATE.platform = template.platform;
            STATE.gptModel = template.model;
            STATE.analysis = template.analysis;
            
            document.getElementById('dropZone').scrollIntoView({ behavior: 'smooth' });
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // DRAG & DROP
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        
        dropZone.addEventListener('click', () => fileInput.click());
        
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        });
        
        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('drag-over');
        });
        
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });
        
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) handleFile(file);
        });

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // STATUS & PROGRESS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function showStatus(message, type = 'info') {
            const statusEl = document.getElementById('statusMessage');
            statusEl.textContent = message;
            statusEl.className = 'status-message status-' + type;
            statusEl.style.display = 'block';
            
            setTimeout(() => {
                statusEl.style.display = 'none';
            }, 5000);
        }
        
        function updateProgress(percent, stage, text) {
            const progressBar = document.getElementById('progressBar');
            const progressStage = document.getElementById('progressStage');
            const progressText = document.getElementById('progressText');
            const progressContainer = document.getElementById('progressContainer');
            
            progressContainer.style.display = 'block';
            progressBar.style.width = percent + '%';
            progressBar.textContent = Math.round(percent) + '%';
            progressStage.textContent = stage;
            progressText.textContent = text;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BATCH FUNCTIONS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // Setup batch file input and drag & drop listeners
        document.addEventListener('DOMContentLoaded', () => {
            const batchInput = document.getElementById('batchFileInput');
            const batchUploadZone = document.querySelector('.batch-upload');
            
            // File input change listener
            if (batchInput) {
                batchInput.addEventListener('change', (e) => {
                    const files = Array.from(e.target.files);
                    addFilesToBatch(files);
                    e.target.value = ''; // Reset input
                });
            }
            
            // Drag & Drop listeners
            if (batchUploadZone) {
                batchUploadZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    batchUploadZone.style.borderColor = 'var(--mer)';
                    batchUploadZone.style.backgroundColor = 'var(--vert-sauge)';
                });
                
                batchUploadZone.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    batchUploadZone.style.borderColor = '';
                    batchUploadZone.style.backgroundColor = '';
                });
                
                batchUploadZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    batchUploadZone.style.borderColor = '';
                    batchUploadZone.style.backgroundColor = '';
                    
                    const files = Array.from(e.dataTransfer.files);
                    if (files.length > 0) {
                        addFilesToBatch(files);
                    }
                });
            }
        });
        
        function addFilesToBatch(files) {
            if (!files || files.length === 0) return;
            
            files.forEach(file => {
                const fileId = crypto.randomUUID();
                const batchItem = {
                    id: fileId,
                    file: file,
                    status: 'queued',
                    progress: 0,
                    error: null,
                    result: null
                };
                
                STATE.batch.queue.push(batchItem);
                STATE.batch.stats.total++;
            });
            
            renderBatchQueue();
            updateBatchStats();
            updateBatchButtons();
            
            showStatus(`${files.length} fichier(s) ajoutÃ©(s) Ã  la file batch`, 'success');
        }
        
        function renderBatchQueue() {
            const queueContainer = document.getElementById('batchQueue');
            
            if (STATE.batch.queue.length === 0) {
                queueContainer.innerHTML = `
                    <div class="batch-empty">
                        <div class="batch-empty-icon">ğŸ“„</div>
                        <p>Aucun fichier dans la file batch</p>
                        <p style="font-size:0.9em;">SÃ©lectionnez plusieurs fichiers pour commencer</p>
                    </div>
                `;
                return;
            }
            
            queueContainer.innerHTML = '';
            STATE.batch.queue.forEach((item, index) => {
                renderBatchItem(item, index);
            });
        }
        
        function renderBatchItem(item, index) {
            const queueContainer = document.getElementById('batchQueue');
            let card = document.querySelector(`[data-file-id="${item.id}"]`);
            
            if (!card) {
                card = document.createElement('div');
                card.className = 'batch-item';
                card.setAttribute('data-file-id', item.id);
                queueContainer.appendChild(card);
            }
            
            const fileSize = (item.file.size / 1024 / 1024).toFixed(2);
            
            card.innerHTML = `
                <div class="batch-item-header">
                    <span class="batch-file-name">${item.file.name} (${fileSize} MB)</span>
                    <span class="batch-file-status status-${item.status}">${getStatusLabel(item.status)}</span>
                    <button class="batch-remove-btn" onclick="removeBatchItem(${index})" ${item.status === 'processing' ? 'disabled' : ''}>Ã—</button>
                </div>
                <div class="batch-progress-bar">
                    <div class="batch-progress-fill" style="width: ${item.progress}%"></div>
                </div>
                <div class="batch-progress-message">${item.status === 'processing' ? 'Traitement en cours...' : ''}</div>
                ${item.error ? `<div class="batch-error-message">${item.error}</div>` : ''}
            `;
        }
        
        function getStatusLabel(status) {
            const labels = {
                queued: 'En attente',
                processing: 'En cours',
                completed: 'TerminÃ©',
                error: 'Erreur'
            };
            return labels[status] || status;
        }
        
        function removeBatchItem(index) {
            const item = STATE.batch.queue[index];
            if (!item) return;
            
            if (item.status === 'processing') {
                showStatus('Impossible de supprimer un fichier en cours de traitement', 'warning');
                return;
            }
            
            STATE.batch.queue.splice(index, 1);
            STATE.batch.stats.total--;
            
            if (item.status === 'completed') STATE.batch.stats.completed--;
            if (item.status === 'error') STATE.batch.stats.errors--;
            
            renderBatchQueue();
            updateBatchStats();
            updateBatchButtons();
        }
        
        function clearBatch() {
            if (STATE.batch.status === 'running') {
                showStatus('Impossible d\'effacer pendant le traitement. Mettez en pause d\'abord.', 'warning');
                return;
            }
            
            if (!confirm(`Effacer tous les ${STATE.batch.queue.length} fichiers ?`)) return;
            
            STATE.batch.queue = [];
            STATE.batch.currentIndex = 0;
            STATE.batch.stats = {
                total: 0,
                completed: 0,
                errors: 0,
                skipped: 0
            };
            
            if (STATE.batchController) {
                STATE.batchController.progressTracker.clear();
                STATE.batchController.errorHandler.clearErrors();
            }
            
            renderBatchQueue();
            updateBatchStats();
            updateBatchButtons();
            
            showStatus('File batch effacÃ©e', 'info');
        }
        
        async function startBatch() {
            if (!STATE.batchController) {
                showStatus('Batch controller non initialisÃ©', 'error');
                return;
            }
            
            await STATE.batchController.startBatch();
        }
        
        function pauseBatch() {
            if (!STATE.batchController) return;
            STATE.batchController.pauseBatch();
        }
        
        async function resumeBatch() {
            if (!STATE.batchController) return;
            await STATE.batchController.resumeBatch();
        }
        
        function updateBatchStats() {
            document.getElementById('batchStatTotal').textContent = STATE.batch.stats.total;
            document.getElementById('batchStatCompleted').textContent = STATE.batch.stats.completed;
            document.getElementById('batchStatErrors').textContent = STATE.batch.stats.errors;
            
            if (STATE.batch.startTime) {
                const elapsed = Math.floor((Date.now() - STATE.batch.startTime) / 1000);
                document.getElementById('batchStatTime').textContent = `${elapsed}s`;
            }
        }
        
        function updateBatchButtons() {
            const startBtn = document.getElementById('batchStartBtn');
            const pauseBtn = document.getElementById('batchPauseBtn');
            const resumeBtn = document.getElementById('batchResumeBtn');
            const exportBtn = document.getElementById('batchExportBtn');
            const promptBtn = document.getElementById('batchPromptBtn');
            
            const hasFiles = STATE.batch.queue.length > 0;
            const isRunning = STATE.batch.status === 'running';
            const isPaused = STATE.batch.status === 'paused';
            const hasCompleted = STATE.batch.stats.completed > 0;
            
            startBtn.disabled = !hasFiles || isRunning || isPaused;
            pauseBtn.disabled = !isRunning;
            resumeBtn.disabled = !isPaused;
            exportBtn.disabled = !hasCompleted;
            promptBtn.disabled = !hasCompleted;
        }
        
        function updateBatchConfig() {
            STATE.batch.config.maxConcurrent = parseInt(document.getElementById('batchMaxConcurrent').value) || 3;
            STATE.batch.config.retryAttempts = parseInt(document.getElementById('batchRetryAttempts').value) || 2;
            STATE.batch.config.continueOnError = document.getElementById('batchContinueOnError').checked;
            STATE.batch.config.mergeStrategy = document.getElementById('batchMergeStrategy').value;
            
            if (STATE.batchController) {
                STATE.batchController.errorHandler = new BatchErrorHandler(STATE.batch.config);
            }
        }
        
        function applyBatchTemplate(templateName) {
            const templates = {
                realbook_collection: {
                    name: 'Realbook Collection',
                    config: {
                        maxConcurrent: 2,
                        retryAttempts: 2,
                        continueOnError: true,
                        mergeStrategy: 'by_type'
                    },
                    settings: {
                        platform: 'chatgpt',
                        model: 'gpt-4o',
                        format: 32
                    }
                },
                therapy_docs_batch: {
                    name: 'Therapy Documents',
                    config: {
                        maxConcurrent: 3,
                        retryAttempts: 1,
                        continueOnError: true,
                        mergeStrategy: 'chronological'
                    },
                    settings: {
                        platform: 'claude',
                        model: 'claude-sonnet-4-20250514',
                        format: 32
                    }
                },
                scientific_papers: {
                    name: 'Scientific Papers',
                    config: {
                        maxConcurrent: 3,
                        retryAttempts: 2,
                        continueOnError: true,
                        mergeStrategy: 'alphabetical'
                    },
                    settings: {
                        platform: 'claude',
                        model: 'claude-opus-4-20250514',
                        format: 32
                    }
                },
                custom: {
                    name: 'Custom Configuration',
                    config: {
                        maxConcurrent: 3,
                        retryAttempts: 2,
                        continueOnError: true,
                        mergeStrategy: 'flat'
                    },
                    settings: {
                        platform: STATE.platform,
                        model: STATE.platform === 'chatgpt' ? STATE.gptModel : STATE.claudeModel,
                        format: STATE.format
                    }
                }
            };
            
            const template = templates[templateName];
            if (!template) return;
            
            // Apply config
            Object.assign(STATE.batch.config, template.config);
            
            // Update UI
            document.getElementById('batchMaxConcurrent').value = template.config.maxConcurrent;
            document.getElementById('batchRetryAttempts').value = template.config.retryAttempts;
            document.getElementById('batchContinueOnError').checked = template.config.continueOnError;
            document.getElementById('batchMergeStrategy').value = template.config.mergeStrategy;
            
            // Apply settings to global STATE
            STATE.platform = template.settings.platform;
            STATE.format = template.settings.format;
            
            if (STATE.platform === 'chatgpt') {
                STATE.gptModel = template.settings.model;
            } else {
                STATE.claudeModel = template.settings.model;
            }
            
            updateBatchConfig();
            showStatus(`Template "${template.name}" appliquÃ©`, 'success');
        }
        
        async function exportPartialBatch() {
            const completedItems = STATE.batch.queue.filter(item => item.status === 'completed');
            
            if (completedItems.length === 0) {
                showStatus('Aucun fichier complÃ©tÃ© Ã  exporter', 'warning');
                return;
            }
            
            showStatus(`Export de ${completedItems.length} fichier(s) complÃ©tÃ©(s)...`, 'info');
            
            try {
                const zip = new JSZip();
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                const batchFolder = zip.folder(`batch_partial_${timestamp}`);
                
                // Add completed results
                completedItems.forEach((item, index) => {
                    if (item.result) {
                        const fileName = item.file.name.replace(/\.[^/.]+$/, '');
                        batchFolder.file(`${index + 1}_${fileName}.json`, JSON.stringify(item.result, null, 2));
                    }
                });
                
                // Add batch report
                const report = {
                    export_date: new Date().toISOString(),
                    total_files: STATE.batch.stats.total,
                    completed: STATE.batch.stats.completed,
                    errors: STATE.batch.stats.errors,
                    merge_strategy: STATE.batch.config.mergeStrategy,
                    files: completedItems.map(item => ({
                        name: item.file.name,
                        size: item.file.size,
                        status: item.status
                    }))
                };
                
                batchFolder.file('batch_report.json', JSON.stringify(report, null, 2));
                
                // Generate and download
                const blob = await zip.generateAsync({ type: 'blob' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `batch_partial_${timestamp}.zip`;
                a.click();
                URL.revokeObjectURL(url);
                
                showStatus('Export partiel tÃ©lÃ©chargÃ© avec succÃ¨s !', 'success');
                
            } catch (error) {
                console.error('Export error:', error);
                showStatus('Erreur lors de l\'export : ' + error.message, 'error');
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // EXPORT FUNCTIONS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        async function exportFormat(format) {
            if (!STATE.exportManager) {
                showStatus('Export Manager non initialisÃ©', 'error');
                return;
            }
            
            if (!STATE.file) {
                showStatus('Aucun fichier chargÃ© pour l\'export', 'warning');
                return;
            }
            
            showStatus(`Export ${format} en cours...`, 'info');
            
            try {
                let content, filename, mimeType, extension;
                
                switch (format) {
                    case 'markdown':
                        content = await STATE.exportManager.exportMarkdown();
                        filename = STATE.fileName.replace(/\.[^/.]+$/, '.md');
                        mimeType = 'text/markdown';
                        extension = 'md';
                        break;
                        
                    case 'yaml':
                        content = await STATE.exportManager.exportYAML();
                        filename = STATE.fileName.replace(/\.[^/.]+$/, '.yaml');
                        mimeType = 'text/yaml';
                        extension = 'yaml';
                        break;
                        
                    case 'jsonld':
                        content = await STATE.exportManager.exportJSONLD();
                        filename = STATE.fileName.replace(/\.[^/.]+$/, '.jsonld');
                        mimeType = 'application/ld+json';
                        extension = 'jsonld';
                        break;
                        
                    case 'excel':
                        const xlsxData = await STATE.exportManager.exportExcel();
                        const xlsxBlob = new Blob([s2ab(xlsxData)], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
                        downloadBlob(xlsxBlob, STATE.fileName.replace(/\.[^/.]+$/, '.xlsx'));
                        showStatus('Excel exportÃ© avec succÃ¨s !', 'success');
                        return;
                        
                    case 'obsidian':
                        const obsidianBlob = await STATE.exportManager.exportObsidian();
                        downloadBlob(obsidianBlob, STATE.fileName.replace(/\.[^/.]+$/, '_vault.zip'));
                        showStatus('Vault Obsidian exportÃ© avec succÃ¨s !', 'success');
                        return;
                        
                    case 'notion':
                        content = await STATE.exportManager.exportNotion();
                        filename = STATE.fileName.replace(/\.[^/.]+$/, '_notion.csv');
                        mimeType = 'text/csv';
                        extension = 'csv';
                        break;
                        
                    case 'anki':
                        content = await STATE.exportManager.exportAnki();
                        filename = STATE.fileName.replace(/\.[^/.]+$/, '_anki.txt');
                        mimeType = 'text/plain';
                        extension = 'txt';
                        break;
                        
                    case 'pdf':
                        await STATE.exportManager.exportPDF();
                        return; // PDF handled separately
                        
                    default:
                        showStatus(`Format ${format} non supportÃ©`, 'error');
                        return;
                }
                
                // Download text-based formats
                const blob = new Blob([content], { type: mimeType });
                downloadBlob(blob, filename);
                
                // Show preview
                showExportPreview(content, format);
                
                showStatus(`${format.toUpperCase()} exportÃ© avec succÃ¨s !`, 'success');
                
            } catch (error) {
                console.error(`Export ${format} error:`, error);
                showStatus(`Erreur export ${format}: ${error.message}`, 'error');
            }
        }
        
        async function exportAllFormats() {
            if (!STATE.file) {
                showStatus('Aucun fichier chargÃ© pour l\'export', 'warning');
                return;
            }
            
            showStatus('Export de tous les formats en cours...', 'info');
            
            try {
                const zip = new JSZip();
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                const baseName = STATE.fileName.replace(/\.[^/.]+$/, '');
                const exportFolder = zip.folder(`${baseName}_exports_${timestamp}`);
                
                // Markdown
                const markdown = await STATE.exportManager.exportMarkdown();
                exportFolder.file(`${baseName}.md`, markdown);
                
                // YAML
                const yaml = await STATE.exportManager.exportYAML();
                exportFolder.file(`${baseName}.yaml`, yaml);
                
                // JSON-LD
                const jsonld = await STATE.exportManager.exportJSONLD();
                exportFolder.file(`${baseName}.jsonld`, jsonld);
                
                // Excel
                const xlsxData = await STATE.exportManager.exportExcel();
                exportFolder.file(`${baseName}.xlsx`, s2ab(xlsxData), { binary: true });
                
                // Notion CSV
                const notionCsv = await STATE.exportManager.exportNotion();
                exportFolder.file(`${baseName}_notion.csv`, notionCsv);
                
                // Anki
                const ankiTxt = await STATE.exportManager.exportAnki();
                exportFolder.file(`${baseName}_anki.txt`, ankiTxt);
                
                // Obsidian vault
                const obsidianBlob = await STATE.exportManager.exportObsidian();
                const obsidianArrayBuffer = await obsidianBlob.arrayBuffer();
                exportFolder.file(`${baseName}_obsidian_vault.zip`, obsidianArrayBuffer);
                
                // Add README
                const readme = `# ${baseName} - Exports Multiples
                
Ce dossier contient ${baseName} exportÃ© dans 7 formats diffÃ©rents :

1. **${baseName}.md** - Markdown formatÃ©
2. **${baseName}.yaml** - Configuration YAML
3. **${baseName}.jsonld** - Knowledge graph (Schema.org)
4. **${baseName}.xlsx** - Feuille de calcul Excel
5. **${baseName}_notion.csv** - Import Notion
6. **${baseName}_anki.txt** - Flashcards Anki
7. **${baseName}_obsidian_vault.zip** - Vault Obsidian

GÃ©nÃ©rÃ© le ${new Date().toLocaleString('fr-FR')} avec OCR Universel V5.1 ULTIMATE
`;
                exportFolder.file('README.txt', readme);
                
                // Generate and download ZIP
                const blob = await zip.generateAsync({ type: 'blob' });
                downloadBlob(blob, `${baseName}_all_exports_${timestamp}.zip`);
                
                showStatus('Tous les formats exportÃ©s avec succÃ¨s !', 'success');
                
            } catch (error) {
                console.error('Export all error:', error);
                showStatus('Erreur lors de l\'export multiple: ' + error.message, 'error');
            }
        }
        
        function downloadBlob(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function s2ab(s) {
            const buf = new ArrayBuffer(s.length);
            const view = new Uint8Array(buf);
            for (let i = 0; i < s.length; i++) {
                view[i] = s.charCodeAt(i) & 0xFF;
            }
            return buf;
        }
        
        function showExportPreview(content, format) {
            const preview = document.getElementById('exportPreview');
            const previewContent = document.getElementById('exportPreviewContent');
            
            if (!preview || !previewContent) return;
            
            preview.style.display = 'block';
            
            // Truncate if too long
            const maxLength = 2000;
            let displayContent = content;
            if (content.length > maxLength) {
                displayContent = content.substring(0, maxLength) + '\n\n... (contenu tronquÃ©)';
            }
            
            previewContent.textContent = displayContent;
            
            // Scroll to preview
            preview.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
        
        // Show export section after processing
        function showExportSection() {
            const exportSection = document.getElementById('exportSection');
            if (exportSection) {
                exportSection.style.display = 'block';
                exportSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // FILE HANDLING
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        async function handleFile(file) {
            STATE.file = file;
            STATE.fileName = file.name;
            STATE.fileType = file.name.split('.').pop().toLowerCase();
            STATE.startTime = Date.now();
            
            showStatus(`Fichier chargÃ©: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`, 'success');
            
            updateProgress(10, 'Analyse du fichier', 'DÃ©tection du format...');
            
            try {
                STATE.detectionResult = await detectDocumentType(file);
                STATE.documentType = STATE.detectionResult.type;
                
                displayDetectionResult(STATE.detectionResult);
                
                updateProgress(100, 'Analyse terminÃ©e', 'PrÃªt Ã  traiter');
                
                document.getElementById('detectionSection').style.display = 'block';
                document.getElementById('compositionSection').style.display = 'block';
                document.getElementById('configSection').style.display = 'block';
                
            } catch (error) {
                console.error('Error handling file:', error);
                showStatus('Erreur lors de l\'analyse: ' + error.message, 'error');
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // FORMAT DETECTION & EXTRACTION (21 FORMATS)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        async function detectDocumentType(file) {
            const fileExt = file.name.split('.').pop().toLowerCase();
            
            updateProgress(20, 'Extraction du contenu', 'Format: ' + fileExt.toUpperCase());
            
            if (fileExt === 'pdf') {
                return await detectDocumentMultiDimensional(file);
            }
            
            if (['png', 'jpg', 'jpeg', 'gif', 'webp', 'tiff', 'tif'].includes(fileExt)) {
                const extracted = await extractTextFromImage(file);
                return await detectDocumentMultiDimensionalFromText(file, extracted.text, extracted);
            }
            
            if (['xlsx', 'xls', 'ods'].includes(fileExt)) {
                const extracted = await extractTextFromExcel(file);
                return await detectDocumentMultiDimensionalFromText(file, extracted.text, extracted);
            }
            
            if (['pptx', 'ppt', 'odp'].includes(fileExt)) {
                const extracted = await extractTextFromPPT(file);
                return await detectDocumentMultiDimensionalFromText(file, extracted.text, extracted);
            }
            
            if (['docx', 'doc', 'odt'].includes(fileExt)) {
                const extracted = await extractTextFromDOCX(file);
                return await detectDocumentMultiDimensionalFromText(file, extracted.text, extracted);
            }
            
            if (fileExt === 'epub') {
                const extracted = await extractTextFromEPUB(file);
                return await detectDocumentMultiDimensionalFromText(file, extracted.text, extracted);
            }
            
            if (fileExt === 'zip') {
                return await handleZipFile(file);
            }
            
            if (['cbz', 'cbr'].includes(fileExt)) {
                const extracted = await extractTextFromComics(file);
                return await detectDocumentMultiDimensionalFromText(file, extracted.text, extracted);
            }
            
            if (['csv', 'tsv'].includes(fileExt)) {
                const extracted = await extractTextFromCSV(file);
                return await detectDocumentMultiDimensionalFromText(file, extracted.text, extracted);
            }
            
            if (['json', 'xml'].includes(fileExt)) {
                const extracted = await extractTextFromStructured(file, fileExt);
                return await detectDocumentMultiDimensionalFromText(file, extracted.text, extracted);
            }
            
            if (['yaml', 'yml'].includes(fileExt)) {
                const extracted = await extractTextFromYAML(file);
                return await detectDocumentMultiDimensionalFromText(file, extracted.text, extracted);
            }
            
            if (fileExt === 'svg') {
                const extracted = await extractTextFromSVG(file);
                return await detectDocumentMultiDimensionalFromText(file, extracted.text, extracted);
            }
            
            if (fileExt === 'rtf') {
                const extracted = await extractTextFromRTF(file);
                return await detectDocumentMultiDimensionalFromText(file, extracted.text, extracted);
            }
            
            if (['mobi', 'azw', 'azw3'].includes(fileExt)) {
                const extracted = await extractTextFromMobi(file);
                return await detectDocumentMultiDimensionalFromText(file, extracted.text, extracted);
            }
            
            if (['html', 'htm', 'md', 'markdown', 'txt'].includes(fileExt)) {
                const extracted = await extractTextFromPlainFile(file);
                return await detectDocumentMultiDimensionalFromText(file, extracted.text, extracted);
            }
            
            throw new Error('Format non supportÃ©: ' + fileExt);
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PDF EXTRACTION (FIX ENCRYPTION)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        async function detectDocumentMultiDimensional(file) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                const pdfDoc = await PDFLib.PDFDocument.load(arrayBuffer, {
                    ignoreEncryption: true
                });
                
                const numPages = pdfDoc.getPageCount();
                STATE.totalPages = numPages;
                STATE.pdfDocument = pdfDoc;
                
                const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
                const page1 = await pdf.getPage(1);
                const textContent = await page1.getTextContent();
                const text = textContent.items.map(item => item.str).join(' ').toLowerCase();
                const textLength = text.length;
                
                let metadata = {};
                try {
                    const title = pdfDoc.getTitle();
                    if (title) metadata.title = title;
                } catch (e) {}
                
                const technical = await detectTechnicalFormat(file, pdfDoc, numPages, textLength);
                const content = detectContentTypes(file.name, metadata, text);
                const composition = calculateComposition(content.detected);
                
                const analysis = {
                    technical,
                    content,
                    composition
                };
                
                STATE.analysis = analysis;
                STATE.documentType = composition.primary || 'text_standard';
                STATE.detectionResult = {
                    type: composition.primary,
                    confidence: content.detected[0]?.confidence || 0.7
                };
                
                return analysis;
                
            } catch (error) {
                console.error('Erreur dÃ©tection PDF:', error);
                return {
                    technical: { format: 'digital', quality: 'unknown', ocr_required: false, density: 0 },
                    content: { detected: [{ type: 'text_standard', score: 50, confidence: 0.5 }], selected: [], domains: [] },
                    composition: { primary: 'text_standard', secondary: [], weights: { text_standard: 1.0 }, auto_weights: { text_standard: 1.0 } }
                };
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TECHNICAL FORMAT DETECTION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        async function detectTechnicalFormat(file, pdfDoc, numPages, textLength) {
            const densityMB = file.size / numPages / (1024 * 1024);
            const hasText = textLength > 100;
            
            let format = 'digital';
            let quality = 'high';
            let ocr_required = false;
            
            if (!hasText || densityMB > 0.5) {
                format = densityMB > 0.5 ? 'photo' : 'scanned';
                quality = 'medium';
                ocr_required = true;
            } else if (densityMB < 0.15 && hasText) {
                format = 'digital';
                quality = 'high';
                ocr_required = false;
            }
            
            return {
                format,
                quality,
                layout: hasText ? 'mixed' : 'image',
                density: densityMB,
                ocr_required,
                hybrid_details: null
            };
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CONTENT TYPE DETECTION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function detectContentTypes(fileName, metadata, text) {
            const scores = {};
            const detected = [];
            
            Object.keys(CONFIG.PATTERNS.content).forEach(type => {
                scores[type] = 0;
            });
            
            Object.entries(CONFIG.PATTERNS.content).forEach(([type, patterns]) => {
                const fnLower = fileName.toLowerCase();
                patterns.filename.forEach(keyword => {
                    if (fnLower.includes(keyword.toLowerCase())) {
                        scores[type] += 15 / patterns.filename.length;
                    }
                });
            });
            
            if (metadata && metadata.title) {
                const titleLower = metadata.title.toLowerCase();
                Object.entries(CONFIG.PATTERNS.content).forEach(([type, patterns]) => {
                    if (patterns.metadata) {
                        patterns.metadata.forEach(keyword => {
                            if (titleLower.includes(keyword.toLowerCase())) {
                                scores[type] += 10 / patterns.metadata.length;
                            }
                        });
                    }
                });
            }
            
            Object.entries(CONFIG.PATTERNS.content).forEach(([type, patterns]) => {
                let matches = 0;
                
                patterns.text.forEach(keyword => {
                    if (keyword instanceof RegExp) {
                        const found = text.match(keyword);
                        if (found && found.length > 0) {
                            matches += found.length;
                        }
                    } else {
                        const regex = new RegExp(keyword.toLowerCase(), 'g');
                        const found = text.match(regex);
                        if (found) {
                            matches += found.length;
                        }
                    }
                });
                
                if (type === 'partition_musicale') {
                    const chordMatches = text.match(/\b[A-G][#bâ™¯â™­]?(m|maj|min|M)?[0-9]?\b/g);
                    if (chordMatches && chordMatches.length >= 10) {
                        scores[type] += 50;
                    } else {
                        scores[type] += Math.min(50, matches * 2);
                    }
                } else {
                    scores[type] += Math.min(50, matches * 5);
                }
            });
            
            Object.entries(scores).forEach(([type, score]) => {
                if (score >= 15) {
                    detected.push({
                        type,
                        score: Math.round(score),
                        confidence: Math.min(1.0, score / 100)
                    });
                }
            });
            
            detected.sort((a, b) => b.score - a.score);
            
            if (detected.length === 0) {
                detected.push({ type: 'text_standard', score: 50, confidence: 0.5 });
            }
            
            return {
                detected,
                selected: [],
                domains: []
            };
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // COMPOSITION CALCULATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function calculateComposition(detected) {
            if (!detected || detected.length === 0) {
                return {
                    primary: 'text_standard',
                    secondary: [],
                    weights: { text_standard: 1.0 },
                    auto_weights: { text_standard: 1.0 }
                };
            }
            
            const primary = detected[0].type;
            const secondary = detected.slice(1, 3).map(d => d.type);
            
            const totalScore = detected.reduce((sum, d) => sum + d.score, 0);
            const weights = {};
            const auto_weights = {};
            
            detected.forEach(d => {
                const weight = d.score / totalScore;
                weights[d.type] = weight;
                auto_weights[d.type] = weight;
            });
            
            return {
                primary,
                secondary,
                weights,
                auto_weights,
                manual_override: false
            };
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // DETECTION FROM TEXT (NON-PDF)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        async function detectDocumentMultiDimensionalFromText(file, text, extractedData) {
            try {
                STATE.extractedText = text;
                STATE.totalPages = 1;
                
                // Ensure extractedData has required properties with defaults
                const safeExtractedData = {
                    method: extractedData?.method || 'unknown',
                    confidence: extractedData?.confidence || 0.9,
                    text: extractedData?.text || text,
                    ...extractedData
                };
                
                const technical = {
                    format: safeExtractedData.method.includes('ocr') ? 'photo' : 'digital',
                    quality: safeExtractedData.confidence >= 0.9 ? 'high' : safeExtractedData.confidence >= 0.7 ? 'medium' : 'low',
                    ocr_required: safeExtractedData.method.includes('ocr'),
                    ocr_confidence: safeExtractedData.confidence || 1.0,
                    density: (file.size / 1024 / 1024) / STATE.totalPages || 0
                };
                
                const content = detectContentTypes(file.name, {}, text.toLowerCase());
                const composition = calculateComposition(content.detected);
                
                const analysis = {
                    technical,
                    content,
                    composition,
                    extractedData: safeExtractedData
                };
                
                STATE.analysis = analysis;
                STATE.documentType = composition.primary || 'text_standard';
                STATE.detectionResult = {
                    type: composition.primary,
                    confidence: content.detected[0]?.confidence || 0.7
                };
                
                return analysis;
                
            } catch (error) {
                console.error('Erreur dÃ©tection depuis texte:', error);
                return {
                    technical: { format: 'digital', quality: 'unknown', ocr_required: false, density: 0 },
                    content: { detected: [{ type: 'text_standard', score: 50, confidence: 0.5 }], selected: [], domains: [] },
                    composition: { primary: 'text_standard', secondary: [], weights: { text_standard: 1.0 }, auto_weights: { text_standard: 1.0 } }
                };
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // IMAGE EXTRACTION (OCR WITH CACHE & PARALLEL)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        async function extractTextFromImage(file) {
            try {
                if (STATE.ocrWorkerPool) {
                    return await STATE.ocrWorkerPool.recognize(file);
                }
                
                if (STATE.ocrCache) {
                    const fileHash = await STATE.ocrCache.hashFile(file);
                    const cached = await STATE.ocrCache.get(fileHash);
                    
                    if (cached && Date.now() - cached.timestamp < 7 * 24 * 3600 * 1000) {
                        console.log('Cache hit:', file.name);
                        showStatus('Texte trouvÃ© en cache !', 'success');
                        return cached.result;
                    }
                }
                
                updateProgress(30, 'OCR en cours', 'Extraction texte...');
                showStatus('OCR en cours... (30-60s)', 'info');
                
                const { data: { text, confidence } } = await Tesseract.recognize(
                    file,
                    'fra+eng',
                    {
                        logger: m => {
                            if (m.status === 'recognizing text') {
                                const pct = Math.round(m.progress * 100);
                                updateProgress(30 + pct * 0.5, 'OCR en cours', `${pct}% - Extraction texte...`);
                            }
                        }
                    }
                );
                
                const result = {
                    text: text.trim(),
                    confidence: confidence / 100,
                    wordCount: text.split(/\s+/).length,
                    method: 'tesseract_ocr'
                };
                
                if (STATE.ocrCache) {
                    const fileHash = await STATE.ocrCache.hashFile(file);
                    await STATE.ocrCache.set(fileHash, result);
                }
                
                showStatus('OCR terminÃ© !', 'success');
                updateProgress(80, 'OCR terminÃ©', 'Analyse du contenu...');
                
                return result;
                
            } catch (error) {
                console.error('Erreur OCR:', error);
                showStatus('Erreur OCR: ' + error.message, 'error');
                return {
                    text: '',
                    confidence: 0,
                    wordCount: 0,
                    method: 'ocr_failed',
                    error: error.message
                };
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // EXCEL EXTRACTION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        async function extractTextFromExcel(file) {
            try {
                updateProgress(30, 'Extraction Excel', 'Lecture des feuilles...');
                
                const arrayBuffer = await file.arrayBuffer();
                const workbook = XLSX.read(arrayBuffer);
                
                let allText = '';
                const sheets = [];
                
                workbook.SheetNames.forEach(sheetName => {
                    const sheet = workbook.Sheets[sheetName];
                    const text = XLSX.utils.sheet_to_txt(sheet);
                    
                    sheets.push({ name: sheetName, text });
                    allText += `\n--- ${sheetName} ---\n${text}`;
                });
                
                updateProgress(80, 'Excel traitÃ©', 'Analyse...');
                
                return {
                    text: allText,
                    confidence: 1.0,
                    wordCount: allText.split(/\s+/).length,
                    method: 'sheetjs_excel',
                    sheets
                };
                
            } catch (error) {
                console.error('Erreur Excel:', error);
                return {
                    text: '',
                    confidence: 0,
                    wordCount: 0,
                    method: 'excel_failed',
                    error: error.message
                };
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // POWERPOINT EXTRACTION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        async function extractTextFromPPT(file) {
            try {
                updateProgress(30, 'Extraction PowerPoint', 'Lecture slides...');
                
                const zip = await JSZip.loadAsync(file);
                const slides = [];
                let allText = '';
                
                for (let i = 1; i <= 200; i++) {
                    const slideFile = zip.file(`ppt/slides/slide${i}.xml`);
                    if (!slideFile) break;
                    
                    const xml = await slideFile.async('string');
                    const text = extractTextFromXML(xml);
                    
                    slides.push({ num: i, text });
                    allText += `\n--- SLIDE ${i} ---\n${text}`;
                }
                
                updateProgress(80, 'PowerPoint traitÃ©', 'Analyse...');
                
                return {
                    text: allText,
                    confidence: 1.0,
                    wordCount: allText.split(/\s+/).length,
                    method: 'jszip_pptx',
                    slides
                };
                
            } catch (error) {
                console.error('Erreur PowerPoint:', error);
                return {
                    text: '',
                    confidence: 0,
                    wordCount: 0,
                    method: 'pptx_failed',
                    error: error.message
                };
            }
        }
        
        function extractTextFromXML(xml) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(xml, 'text/xml');
            const textElements = doc.querySelectorAll('a\\:t, t');
            return Array.from(textElements).map(el => el.textContent).join(' ');
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // WORD EXTRACTION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        async function extractTextFromDOCX(file) {
            try {
                updateProgress(30, 'Extraction Word', 'Lecture...');
                
                const arrayBuffer = await file.arrayBuffer();
                const result = await mammoth.extractRawText({ arrayBuffer });
                
                updateProgress(80, 'Word traitÃ©', 'Analyse...');
                
                return {
                    text: result.value.trim(),
                    confidence: result.messages.length === 0 ? 1.0 : 0.9,
                    wordCount: result.value.split(/\s+/).length,
                    method: 'mammoth_docx'
                };
                
            } catch (error) {
                console.error('Erreur Word:', error);
                return {
                    text: '',
                    confidence: 0,
                    wordCount: 0,
                    method: 'docx_failed',
                    error: error.message
                };
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // EPUB EXTRACTION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        async function extractTextFromEPUB(file) {
            try {
                updateProgress(30, 'Extraction EPUB', 'DÃ©compression...');
                
                const zip = await JSZip.loadAsync(file);
                let allText = '';
                
                const contentFiles = Object.keys(zip.files).filter(name => 
                    name.endsWith('.html') || name.endsWith('.xhtml')
                );
                
                for (const filename of contentFiles) {
                    const content = await zip.file(filename).async('string');
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(content, 'text/html');
                    const text = doc.body ? doc.body.textContent : '';
                    allText += text + '\n\n';
                }
                
                updateProgress(80, 'EPUB traitÃ©', 'Analyse...');
                
                return {
                    text: allText.trim(),
                    confidence: 1.0,
                    wordCount: allText.split(/\s+/).length,
                    method: 'jszip_epub'
                };
                
            } catch (error) {
                console.error('Erreur EPUB:', error);
                return {
                    text: '',
                    confidence: 0,
                    wordCount: 0,
                    method: 'epub_failed',
                    error: error.message
                };
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CSV EXTRACTION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        async function extractTextFromCSV(file) {
            try {
                const text = await file.text();
                const delimiter = file.name.endsWith('.tsv') ? '\t' : ',';
                
                const result = Papa.parse(text, {
                    delimiter,
                    header: true,
                    skipEmptyLines: true
                });
                
                let allText = '';
                result.data.forEach((row, idx) => {
                    allText += `Ligne ${idx + 1}: ${JSON.stringify(row)}\n`;
                });
                
                return {
                    text: allText,
                    confidence: 1.0,
                    wordCount: allText.split(/\s+/).length,
                    method: 'papaparse_csv'
                };
                
            } catch (error) {
                console.error('Erreur CSV:', error);
                return {
                    text: '',
                    confidence: 0,
                    wordCount: 0,
                    method: 'csv_failed',
                    error: error.message
                };
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // STRUCTURED (JSON/XML)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        async function extractTextFromStructured(file, type) {
            try {
                const text = await file.text();
                
                let parsed;
                if (type === 'json') {
                    parsed = JSON.parse(text);
                } else {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(text, 'text/xml');
                    parsed = doc.documentElement.textContent;
                }
                
                const prettyText = type === 'json' ? JSON.stringify(parsed, null, 2) : parsed;
                
                return {
                    text: prettyText,
                    confidence: 1.0,
                    wordCount: prettyText.split(/\s+/).length,
                    method: type + '_parse'
                };
                
            } catch (error) {
                console.error('Erreur ' + type.toUpperCase() + ':', error);
                return {
                    text: '',
                    confidence: 0,
                    wordCount: 0,
                    method: type + '_failed',
                    error: error.message
                };
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // YAML EXTRACTION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        async function extractTextFromYAML(file) {
            try {
                const text = await file.text();
                const parsed = jsyaml.load(text);
                const prettyText = JSON.stringify(parsed, null, 2);
                
                return {
                    text: prettyText,
                    confidence: 1.0,
                    wordCount: prettyText.split(/\s+/).length,
                    method: 'jsyaml_parse'
                };
                
            } catch (error) {
                console.error('Erreur YAML:', error);
                return {
                    text: '',
                    confidence: 0,
                    wordCount: 0,
                    method: 'yaml_failed',
                    error: error.message
                };
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SVG EXTRACTION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        async function extractTextFromSVG(file) {
            try {
                const text = await file.text();
                const parser = new DOMParser();
                const svg = parser.parseFromString(text, 'image/svg+xml');
                
                const textElements = svg.querySelectorAll('text, tspan');
                const extractedText = Array.from(textElements)
                    .map(el => el.textContent)
                    .filter(t => t.trim())
                    .join('\n');
                
                return {
                    text: extractedText,
                    confidence: 1.0,
                    wordCount: extractedText.split(/\s+/).length,
                    method: 'svg_parse'
                };
                
            } catch (error) {
                console.error('Erreur SVG:', error);
                return {
                    text: '',
                    confidence: 0,
                    wordCount: 0,
                    method: 'svg_failed',
                    error: error.message
                };
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // RTF EXTRACTION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        async function extractTextFromRTF(file) {
            try {
                const text = await file.text();
                const cleanText = text
                    .replace(/\\[a-z]+[0-9]*\s?/g, ' ')
                    .replace(/[{}]/g, '')
                    .trim();
                
                return {
                    text: cleanText,
                    confidence: 0.8,
                    wordCount: cleanText.split(/\s+/).length,
                    method: 'rtf_basic_parse'
                };
                
            } catch (error) {
                console.error('Erreur RTF:', error);
                return {
                    text: '',
                    confidence: 0,
                    wordCount: 0,
                    method: 'rtf_failed',
                    error: error.message
                };
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // MOBI EXTRACTION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        async function extractTextFromMobi(file) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                const text = new TextDecoder('utf-8').decode(arrayBuffer);
                const cleanText = text.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
                
                return {
                    text: cleanText,
                    confidence: 0.7,
                    wordCount: cleanText.split(/\s+/).length,
                    method: 'mobi_basic_parse'
                };
                
            } catch (error) {
                console.error('Erreur MOBI:', error);
                return {
                    text: '',
                    confidence: 0,
                    wordCount: 0,
                    method: 'mobi_failed',
                    error: error.message
                };
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // COMICS EXTRACTION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        async function extractTextFromComics(file) {
            try {
                const zip = await JSZip.loadAsync(file);
                const images = [];
                
                Object.keys(zip.files).forEach(filename => {
                    if (/\.(jpg|jpeg|png|gif|webp)$/i.test(filename)) {
                        images.push(filename);
                    }
                });
                
                let text = `Comic avec ${images.length} pages`;
                
                return {
                    text,
                    confidence: 0.5,
                    wordCount: text.split(/\s+/).length,
                    method: 'cbz_parse',
                    pages: images.length
                };
                
            } catch (error) {
                console.error('Erreur Comics:', error);
                return {
                    text: '',
                    confidence: 0,
                    wordCount: 0,
                    method: 'cbz_failed',
                    error: error.message
                };
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PLAIN TEXT EXTRACTION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        async function extractTextFromPlainFile(file) {
            try {
                const text = await file.text();
                
                let cleanText = text;
                if (file.name.endsWith('.html') || file.name.endsWith('.htm')) {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(text, 'text/html');
                    cleanText = doc.body ? doc.body.textContent : text;
                }
                
                return {
                    text: cleanText.trim(),
                    confidence: 1.0,
                    wordCount: cleanText.split(/\s+/).length,
                    method: 'direct_read'
                };
                
            } catch (error) {
                console.error('Erreur lecture texte:', error);
                return {
                    text: '',
                    confidence: 0,
                    wordCount: 0,
                    method: 'read_failed',
                    error: error.message
                };
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ZIP RECURSIVE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        async function handleZipFile(file) {
            try {
                const zip = await JSZip.loadAsync(file);
                const files = [];
                
                zip.forEach((relativePath, zipEntry) => {
                    if (zipEntry.dir) return;
                    
                    const ext = relativePath.split('.').pop().toLowerCase();
                    const supported = ['pdf', 'png', 'jpg', 'jpeg', 'docx', 'pptx', 'xlsx', 'txt'];
                    
                    if (supported.includes(ext)) {
                        files.push({ path: relativePath, entry: zipEntry, ext });
                    }
                });
                
                const results = [];
                for (let i = 0; i < files.length; i++) {
                    const f = files[i];
                    updateProgress(20 + (i / files.length) * 60, 'ZIP', `${i + 1}/${files.length}: ${f.path}`);
                    
                    const blob = await f.entry.async('blob');
                    const extractedFile = new File([blob], f.path);
                    
                    try {
                        const result = await detectDocumentType(extractedFile);
                        results.push({ path: f.path, result });
                    } catch (err) {
                        console.error('Error processing', f.path, err);
                    }
                }
                
                const merged = {
                    technical: { format: 'digital', quality: 'high', ocr_required: false, density: 0.5 },
                    content: {
                        detected: [{ type: 'text_standard', score: 80, confidence: 0.8 }],
                        selected: ['text_standard'],
                        domains: []
                    },
                    composition: {
                        primary: 'text_standard',
                        secondary: [],
                        weights: { text_standard: 1.0 },
                        auto_weights: { text_standard: 1.0 }
                    },
                    zipFiles: results
                };
                
                return merged;
                
            } catch (error) {
                console.error('Erreur ZIP:', error);
                return {
                    technical: { format: 'digital', quality: 'unknown', ocr_required: false, density: 0 },
                    content: { detected: [{ type: 'text_standard', score: 50, confidence: 0.5 }], selected: [], domains: [] },
                    composition: { primary: 'text_standard', secondary: [], weights: { text_standard: 1.0 }, auto_weights: { text_standard: 1.0 } }
                };
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // DISPLAY DETECTION RESULT
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function displayDetectionResult(analysis) {
            const detectionSection = document.getElementById('detectionSection');
            
            if (!analysis || !analysis.technical || !analysis.content) {
                detectionSection.innerHTML = '<p>Erreur analyse</p>';
                return;
            }
            
            const tech = analysis.technical;
            const content = analysis.content;
            const comp = analysis.composition;
            
            const contentNames = {
                'partition_musicale': 'Partition Musicale',
                'tablature': 'Tablature',
                'texte_pedagogique': 'Texte PÃ©dagogique',
                'regles_jeu': 'RÃ¨gles de Jeu',
                'document_therapie': 'Document ThÃ©rapie',
                'questionnaire_psy': 'Questionnaire Psychologique',
                'paper_scientifique': 'Paper Scientifique',
                'manuel_technique': 'Manuel Technique',
                'text_standard': 'Texte Standard'
            };
            
            let detectedHTML = '';
            content.detected.slice(0, 5).forEach((item, idx) => {
                const name = contentNames[item.type] || item.type;
                const isPrimary = idx === 0;
                const badge = isPrimary ? '<span style="background:#4CAF50;color:white;padding:3px 10px;border-radius:6px;font-size:0.8em;margin-left:10px;">PRINCIPAL</span>' : '';
                
                detectedHTML += `
                    <div style="padding:12px;background:${isPrimary ? '#E8F5E9' : 'var(--sable)'};border-radius:8px;margin-bottom:8px;">
                        <div style="display:flex;justify-content:space-between;align-items:center;">
                            <div>
                                <strong>${name}</strong> ${badge}
                                <div style="font-size:0.85em;color:var(--gris-secondaire);margin-top:4px;">
                                    Score: ${item.score} | Confiance: ${Math.round(item.confidence * 100)}%
                                </div>
                            </div>
                            <div style="background:var(--mer);color:white;padding:6px 14px;border-radius:12px;font-weight:600;">
                                ${Math.round((comp.weights[item.type] || 0) * 100)}%
                            </div>
                        </div>
                    </div>
                `;
            });
            
            const densityText = tech.density?.toFixed(3) || 'N/A';
            
            detectionSection.innerHTML = `
                <h2>Analyse Multi-Dimensionnelle</h2>
                
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-top:20px;">
                    <div class="card">
                        <h4>Dimension Technique</h4>
                        <div class="info-grid">
                            <div class="info-item">
                                <div class="info-label">Format:</div>
                                <div class="info-value">${tech.format.toUpperCase()}</div>
                            </div>
                            <div class="info-item">
                                <div class="info-label">QualitÃ©:</div>
                                <div class="info-value">${tech.quality}</div>
                            </div>
                            <div class="info-item">
                                <div class="info-label">DensitÃ©:</div>
                                <div class="info-value">${densityText} MB/p</div>
                            </div>
                            <div class="info-item">
                                <div class="info-label">OCR requis:</div>
                                <div class="info-value">${tech.ocr_required ? 'Oui' : 'Non'}</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h4>Dimension SÃ©mantique</h4>
                        ${detectedHTML}
                    </div>
                </div>
                
                <div class="card" style="margin-top:20px;">
                    <h4>Composition Adaptative</h4>
                    <p>
                        <strong>Principal:</strong> ${contentNames[comp.primary]} (${Math.round(comp.weights[comp.primary] * 100)}%)
                        ${comp.secondary.length > 0 ? '<br><strong>Secondaire:</strong> ' + comp.secondary.map(s => `${contentNames[s]} (${Math.round(comp.weights[s] * 100)}%)`).join(', ') : ''}
                    </p>
                </div>
            `;
            
            showCompositionOverride();
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // COMPOSITION OVERRIDE UI
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function showCompositionOverride() {
            if (!STATE.analysis) return;
            
            const detected = STATE.analysis.content.detected || [];
            
            const checkboxes = document.querySelectorAll('#contentCheckboxes input[type="checkbox"]');
            checkboxes.forEach(cb => {
                const isDetected = detected.some(d => d.type === cb.value);
                cb.checked = isDetected;
            });
            
            if (detected.length > 0) {
                displayWeightSliders(detected.map(d => d.type));
            }
        }
        
        function updateTechnicalFormat() {
            if (!STATE.analysis) return;
            
            const value = document.getElementById('technicalOverride').value;
            if (value !== 'auto') {
                STATE.analysis.technical.format = value;
                STATE.analysis.technical.manual_override = true;
            }
        }
        
        function updateComposition() {
            if (!STATE.analysis) return;
            
            const checkboxes = document.querySelectorAll('#contentCheckboxes input[type="checkbox"]:checked');
            const selectedTypes = Array.from(checkboxes).map(cb => cb.value);
            
            if (selectedTypes.length === 0) {
                document.getElementById('weightsSection').style.display = 'none';
                return;
            }
            
            STATE.analysis.content.selected = selectedTypes;
            STATE.analysis.composition.manual_override = true;
            
            displayWeightSliders(selectedTypes);
            recalculateWeights(selectedTypes);
        }
        
        function displayWeightSliders(types) {
            const slidersList = document.getElementById('slidersList');
            const weightsSection = document.getElementById('weightsSection');
            
            if (types.length === 0) {
                weightsSection.style.display = 'none';
                return;
            }
            
            weightsSection.style.display = 'block';
            
            const weights = STATE.analysis.composition.weights;
            
            const names = {
                'partition_musicale': 'Partition',
                'tablature': 'Tablature',
                'texte_pedagogique': 'PÃ©dagogie',
                'regles_jeu': 'Jeu',
                'document_therapie': 'ThÃ©rapie',
                'questionnaire_psy': 'Questionnaire',
                'paper_scientifique': 'Scientifique',
                'manuel_technique': 'Technique'
            };
            
            let html = '';
            types.forEach(type => {
                const weight = (weights[type] || 0) * 100;
                const name = names[type] || type;
                
                html += `
                    <div class="slider-item">
                        <label>${name}</label>
                        <input type="range" min="0" max="100" value="${weight}" 
                               id="slider_${type}" oninput="updateWeightsManual()">
                        <span id="value_${type}">${Math.round(weight)}%</span>
                    </div>
                `;
            });
            
            slidersList.innerHTML = html;
        }
        
        function recalculateWeights(selectedTypes) {
            const detected = STATE.analysis.content.detected;
            const totalScore = detected
                .filter(d => selectedTypes.includes(d.type))
                .reduce((sum, d) => sum + d.score, 0);
            
            const newWeights = {};
            selectedTypes.forEach(type => {
                const item = detected.find(d => d.type === type);
                newWeights[type] = item ? item.score / totalScore : 1 / selectedTypes.length;
            });
            
            STATE.analysis.composition.weights = newWeights;
            STATE.analysis.composition.primary = selectedTypes[0];
            STATE.analysis.composition.secondary = selectedTypes.slice(1);
            
            displayWeightSliders(selectedTypes);
        }
        
        function updateWeightsManual() {
            const checkboxes = document.querySelectorAll('#contentCheckboxes input[type="checkbox"]:checked');
            const selectedTypes = Array.from(checkboxes).map(cb => cb.value);
            
            let total = 0;
            const rawWeights = {};
            
            selectedTypes.forEach(type => {
                const slider = document.getElementById('slider_' + type);
                const value = parseInt(slider.value);
                rawWeights[type] = value;
                total += value;
            });
            
            const normalized = {};
            selectedTypes.forEach(type => {
                normalized[type] = total > 0 ? rawWeights[type] / total : 1 / selectedTypes.length;
                document.getElementById('value_' + type).textContent = Math.round(normalized[type] * 100) + '%';
            });
            
            STATE.analysis.composition.weights = normalized;
        }
        
        function resetWeights() {
            if (!STATE.analysis) return;
            
            STATE.analysis.composition.weights = { ...STATE.analysis.composition.auto_weights };
            STATE.analysis.composition.manual_override = false;
            
            const checkboxes = document.querySelectorAll('#contentCheckboxes input[type="checkbox"]:checked');
            const selectedTypes = Array.from(checkboxes).map(cb => cb.value);
            
            displayWeightSliders(selectedTypes);
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CONFIGURATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function selectPlatform(platform) {
            STATE.platform = platform;
            
            document.getElementById('platformChatGPT').classList.remove('selected');
            document.getElementById('platformClaude').classList.remove('selected');
            
            if (platform === 'chatgpt') {
                document.getElementById('platformChatGPT').classList.add('selected');
                document.getElementById('gptSelectorGroup').style.display = 'block';
                document.getElementById('claudeSelectorGroup').style.display = 'none';
            } else {
                document.getElementById('platformClaude').classList.add('selected');
                document.getElementById('gptSelectorGroup').style.display = 'none';
                document.getElementById('claudeSelectorGroup').style.display = 'block';
            }
            
            updateIndicators();
        }
        
        function updateIndicators() {
            STATE.format = parseInt(document.getElementById('formatSelector').value);
            STATE.gptModel = document.getElementById('gptSelector').value;
            STATE.claudeModel = document.getElementById('claudeSelector').value;
            
            let config;
            if (STATE.platform === 'chatgpt') {
                config = CONFIG.gpt[STATE.gptModel];
            } else {
                config = CONFIG.claude[STATE.claudeModel];
            }
            
            document.getElementById('qualityIndicator').textContent = config.quality;
            document.getElementById('speedIndicator').textContent = config.speed;
            document.getElementById('detailsIndicator').textContent = config.details;
            
            document.getElementById('formatDesc').innerHTML = `
                <strong>${STATE.format === 32 ? 'Format R&D (32 modules)' : 'Format Standard (7 modules)'}</strong><br>
                <p style="margin-top:10px;">${CONFIG.format[STATE.format]}</p>
            `;
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PROCESSING WORKFLOW
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function calculateAdaptiveBatchSize() {
            const analysis = STATE.analysis;
            if (!analysis || !analysis.technical || !analysis.composition) {
                return STATE.format === 32 ? 30 : 50;
            }
            
            const base = CONFIG.BATCH_FACTORS.base_batch_size;
            const tech = analysis.technical.format;
            const weights = analysis.composition.weights;
            
            const techFactor = CONFIG.BATCH_FACTORS.technical[tech] || 1.0;
            
            let contentFactor = 0;
            for (const [type, weight] of Object.entries(weights)) {
                const factor = CONFIG.BATCH_FACTORS.content[type] || 1.0;
                contentFactor += factor * weight;
            }
            
            if (contentFactor === 0) contentFactor = 1.0;
            
            const batchSize = Math.round(base * techFactor * contentFactor);
            const finalBatch = Math.max(5, Math.min(50, batchSize));
            
            console.log('Batch size:', finalBatch);
            
            return finalBatch;
        }
        
        async function processFile() {
            document.getElementById('configSection').style.display = 'none';
            document.getElementById('phase2').style.display = 'block';
            
            await splitDocument();
            
            document.getElementById('phase2').scrollIntoView({ 
                behavior: 'smooth', 
                block: 'start' 
            });
        }
        
        async function splitDocument() {
            let maxPagesPerPart = calculateAdaptiveBatchSize();
            
            const numParts = Math.ceil(STATE.totalPages / maxPagesPerPart);
            STATE.parts = [];
            
            if (STATE.fileType === 'pdf') {
                const arrayBuffer = await STATE.file.arrayBuffer();
                const pdfDoc = await PDFLib.PDFDocument.load(arrayBuffer, {
                    ignoreEncryption: true
                });
                
                for (let i = 0; i < numParts; i++) {
                    const startPage = i * maxPagesPerPart + 1;
                    const endPage = Math.min((i + 1) * maxPagesPerPart, STATE.totalPages);
                    
                    const newPdf = await PDFLib.PDFDocument.create();
                    const pages = await newPdf.copyPages(pdfDoc, 
                        Array.from({length: endPage - startPage + 1}, (_, j) => startPage - 1 + j)
                    );
                    pages.forEach(page => newPdf.addPage(page));
                    
                    const pdfBytes = await newPdf.save();
                    const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                    
                    STATE.parts.push({
                        num: i + 1,
                        startPage,
                        endPage,
                        file: blob,
                        status: 'pending',
                        json: null
                    });
                }
            } else {
                STATE.parts.push({
                    num: 1,
                    startPage: 1,
                    endPage: 1,
                    file: STATE.file,
                    status: 'pending',
                    json: null
                });
            }
            
            displayParts();
        }
        
        function displayParts() {
            let html = '';
            STATE.parts.forEach((part, index) => {
                html += `
                    <div class="part-card" id="part-${index}">
                        <div class="part-header">
                            <div class="part-title">Partie ${part.num} â€¢ Pages ${part.startPage}-${part.endPage}</div>
                            <span class="status-badge status-pending" id="status-${index}">En attente</span>
                        </div>
                        
                        <div class="prompt-output" id="prompt-${index}">${generatePrompt(part)}</div>
                        
                        <div class="btn-group">
                            <button class="btn btn-small" onclick="copyAndDownload(${index})">
                                Copier Prompt & TÃ©lÃ©charger PDF
                            </button>
                        </div>
                        
                        <div style="margin-top:20px;">
                            <label style="font-weight:600;display:block;margin-bottom:10px;">
                                Collez ici le JSON gÃ©nÃ©rÃ© :
                            </label>
                            <textarea id="json-text-${index}" placeholder="Collez le JSON ici..."></textarea>
                            <div class="btn-group">
                                <button class="btn btn-secondary btn-small" onclick="validateJSON(${index})">
                                    Valider JSON
                                </button>
                                <button class="btn btn-small" onclick="acceptJSON(${index})">
                                    Accepter & Continuer
                                </button>
                            </div>
                            <div id="validation-${index}" style="margin-top:15px;"></div>
                        </div>
                    </div>
                `;
            });
            document.getElementById('partsContainer').innerHTML = html;
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PROMPT GENERATION (ADAPTIVE)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function generatePrompt(part) {
            const analysis = STATE.analysis || {};
            const tech = analysis.technical || { format: 'digital', quality: 'medium', ocr_required: false };
            const comp = analysis.composition || { primary: 'text_standard', secondary: [], weights: {} };
            
            let prompt = `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
CONTRAT R&D ANTHROPIC - PROMPT ADAPTATIF MULTI-DIMENSIONNEL
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Document : ${STATE.fileName}
Pages ${part.startPage}-${part.endPage}
Format : ${STATE.format === 32 ? 'R&D COMPLET 32 MODULES' : 'STANDARD 7 MODULES'}

VOUS AVEZ DÃ‰JÃ€ ACCEPTÃ‰ ET VALIDÃ‰ :
â€¢ Format : ${STATE.format} MODULES R&D ANTHROPIC
â€¢ Citations : Texte simple dans champ "citation"
â€¢ Compression : Intelligente AUTOMATIQUE
â€¢ Questions : ZÃ‰RO

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
CONTEXTE TECHNIQUE
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
`;
            
            const techModule = PROMPT_MODULES.technical[tech.format] || '';
            if (techModule) {
                prompt += techModule + '\n';
            }
            
            prompt += `
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
MODULES CONTENU (COMPOSITION ADAPTATIVE)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
`;
            
            const primaryModule = PROMPT_MODULES.content[comp.primary];
            const primaryWeight = comp.weights[comp.primary] || 1.0;
            
            if (primaryModule) {
                prompt += `
MODULE PRINCIPAL (${Math.round(primaryWeight * 100)}%)
${'â•'.repeat(80)}

${primaryModule}
`;
            }
            
            if (comp.secondary && comp.secondary.length > 0) {
                comp.secondary.forEach(type => {
                    const module = PROMPT_MODULES.content[type];
                    const weight = comp.weights[type] || 0;
                    
                    if (module && weight > 0) {
                        prompt += `
MODULE SECONDAIRE (${Math.round(weight * 100)}%)
${'-'.repeat(80)}

${module}
`;
                    }
                });
            }
            
            const jsonStructure = generateFusedJSONStructure(comp, STATE.format);
            
            prompt += `
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
STRUCTURE JSON FUSIONNÃ‰E ADAPTATIVE
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

${jsonStructure}

Remplir TOUTES les sections prÃ©sentes selon les modules activÃ©s.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
RÃˆGLE ABSOLUE - FORMAT JSON PUR
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

GÃ‰NÃ‰REZ JSON PUR UNIQUEMENT.
Commence EXACTEMENT par {
Termine EXACTEMENT par }
RIEN avant le {
RIEN aprÃ¨s le }

TOUS LES MODULES INDIQUÃ‰S SONT OBLIGATOIRES.
`;
            
            if (STATE.platform === 'chatgpt') {
                prompt += `
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
INSTRUCTIONS CHATGPT ANTI-PROCRASTINATION
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

CRITICAL RULES FOR CHATGPT:
1. Start IMMEDIATELY with JSON. NO preamble, NO explanation.
2. Complete ALL fields. Empty fields = FAILURE.
3. NO placeholders [TBD]. Extract actual data or use null.
4. NO questions, NO clarifications. Execute NOW.
5. Format already agreed. Do NOT ask for confirmation.

YOU ALREADY AGREED to this format in our previous contract.
PROCEED IMMEDIATELY.
`;
            }
            
            prompt += `
GÃ©nÃ©rez le JSON complet maintenant.`;
            
            return prompt;
        }
        
        function generateFusedJSONStructure(composition, formatLevel) {
            const types = Object.keys(composition.weights || {});
            
            let structure = {
                metadata: {
                    type_composition: types,
                    weights: composition.weights,
                    format_level: formatLevel
                }
            };
            
            structure.structure_hierarchique = {};
            structure.index_conceptuel = {};
            structure.contenu_enrichi = {};
            
            if (types.includes('partition_musicale') || types.includes('tablature')) {
                structure.morceaux = [];
                structure.grilles_accords = [];
            }
            
            if (types.includes('tablature')) {
                structure.tablatures = [];
            }
            
            if (types.includes('texte_pedagogique')) {
                structure.objectifs_apprentissage = [];
                structure.exercices = [];
                structure.progression = {};
            }
            
            if (types.includes('regles_jeu')) {
                structure.composants = [];
                structure.deroulement = {};
                structure.conditions_victoire = "";
            }
            
            if (types.includes('document_therapie')) {
                structure.cas_cliniques = [];
                structure.outils_therapeutiques = [];
            }
            
            if (types.includes('questionnaire_psy')) {
                structure.echelles = [];
                structure.items = [];
                structure.scoring = {};
            }
            
            if (types.includes('paper_scientifique')) {
                structure.abstract = "";
                structure.methodologie = {};
                structure.resultats = {};
                structure.bibliographie = [];
            }
            
            if (types.includes('manuel_technique')) {
                structure.specifications = [];
                structure.procedures = [];
            }
            
            if (formatLevel === 32) {
                structure.graphe_connaissances = {};
                structure.taxonomie = {};
                structure.semantique = {};
                structure.pedagogie = {};
                structure.multimodal = {};
                structure.evaluation = {};
                structure.references = {};
                structure.citations_semantiques = {};
                structure.contexte_historique = {};
                structure.applications_pratiques = {};
                structure.controverses = {};
                structure.glossaire = {};
                structure.donnees_statistiques = {};
                structure.comparaisons = {};
                structure.implementation = {};
                structure.public_cible = {};
                structure.ressources_complementaires = {};
                structure.validation_qualite = {};
                structure.meta_analyse = {};
                structure.liens_externes = {};
                structure.temporalite = {};
                structure.patterns = {};
                structure.insights = {};
                structure.analytics = {};
            } else {
                structure.graphe_connaissances = {};
                structure.taxonomie = {};
                structure.analytics = {};
            }
            
            return JSON.stringify(structure, null, 2);
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // COPY & DOWNLOAD
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        async function copyAndDownload(index) {
            const part = STATE.parts[index];
            const prompt = generatePrompt(part);
            
            try {
                await navigator.clipboard.writeText(prompt);
                showStatus('Prompt copiÃ© dans le presse-papiers !', 'success');
            } catch (error) {
                console.error('Erreur copie:', error);
                showStatus('Erreur copie presse-papiers', 'error');
            }
            
            const url = URL.createObjectURL(part.file);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${STATE.fileName.replace(/\.[^/.]+$/, '')}_part${part.num}.pdf`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // JSON VALIDATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function validateJSON(index) {
            const textarea = document.getElementById(`json-text-${index}`);
            const validationDiv = document.getElementById(`validation-${index}`);
            
            try {
                const text = textarea.value.trim();
                const json = JSON.parse(text);
                
                validationDiv.innerHTML = `
                    <div class="status-message status-success" style="display:block;">
                        JSON valide ! ${Object.keys(json).length} clÃ©s trouvÃ©es.
                    </div>
                `;
                
                STATE.parts[index].json = json;
                
            } catch (error) {
                validationDiv.innerHTML = `
                    <div class="status-message status-error" style="display:block;">
                        Erreur JSON : ${error.message}
                    </div>
                `;
            }
        }
        
        function acceptJSON(index) {
            const textarea = document.getElementById(`json-text-${index}`);
            
            try {
                const text = textarea.value.trim();
                const json = JSON.parse(text);
                
                STATE.parts[index].json = json;
                STATE.parts[index].status = 'completed';
                
                document.getElementById(`status-${index}`).textContent = 'TerminÃ©';
                document.getElementById(`status-${index}`).className = 'status-badge status-completed';
                
                showStatus(`Partie ${STATE.parts[index].num} acceptÃ©e !`, 'success');
                
                const allCompleted = STATE.parts.every(p => p.status === 'completed');
                if (allCompleted) {
                    showStatus('Toutes les parties terminÃ©es ! GÃ©nÃ©ration ZIP...', 'success');
                    setTimeout(() => {
                        downloadZIP();
                    }, 1000);
                }
                
            } catch (error) {
                showStatus('Erreur : JSON invalide', 'error');
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // EXPORT ZIP
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        async function downloadZIP() {
            if (typeof JSZip === 'undefined') {
                alert('BibliothÃ¨que JSZip non chargÃ©e');
                return;
            }
            
            const zip = new JSZip();
            const merged = mergeAllJSON();
            const folderName = STATE.fileName.replace(/\.[^/.]+$/, '');
            const folder = zip.folder(folderName);
            
            folder.file('knowledge_index.json', JSON.stringify(merged, null, 2));
            folder.file('README.md', generateREADME());
            folder.file(STATE.fileName, STATE.file);
            
            const blob = await zip.generateAsync({type: 'blob'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = folderName + '_OCR_v5.1.zip';
            a.click();
            URL.revokeObjectURL(url);
            
            showStatus('ZIP tÃ©lÃ©chargÃ© avec succÃ¨s !', 'success');
            
            showStatistics();
            showExportSection();
        }
        
        function mergeAllJSON() {
            if (STATE.parts.length === 1) return STATE.parts[0].json;
            
            const merged = JSON.parse(JSON.stringify(STATE.parts[0].json));
            
            for (let i = 1; i < STATE.parts.length; i++) {
                const part = STATE.parts[i].json;
                if (part.structure_hierarchique?.sections) {
                    merged.structure_hierarchique.sections.push(...part.structure_hierarchique.sections);
                }
            }
            
            return merged;
        }
        
        function generateREADME() {
            return `# ${STATE.fileName.replace(/\.[^/.]+$/, '')} - Base de Connaissances

## Document
- Nom : ${STATE.fileName}
- Pages : ${STATE.totalPages}
- Format : ${STATE.format} modules
- Plateforme : ${STATE.platform}

## Fichiers
- knowledge_index.json : Base de connaissances structurÃ©e
- README.md : Ce fichier
- ${STATE.fileName} : Document original

GÃ©nÃ©rÃ© avec OCR Universel V5.1 ULTIMATE
`;
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // STATISTICS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function showStatistics() {
            const stats = {
                totalPages: STATE.totalPages,
                totalWords: STATE.extractedText ? STATE.extractedText.split(/\s+/).length : 0,
                avgConfidence: STATE.analysis?.technical?.ocr_confidence || 1.0,
                processingTime: STATE.startTime ? (Date.now() - STATE.startTime) / 1000 : 0,
                format: STATE.fileType.toUpperCase(),
                size: (STATE.file.size / 1024 / 1024).toFixed(2) + ' MB'
            };
            
            const statsGrid = document.getElementById('statsGrid');
            statsGrid.innerHTML = `
                <div class="stat-card">
                    <div class="stat-value">${stats.totalPages}</div>
                    <div class="stat-label">Pages</div>
                </div>
                <div class="stat-card" style="background:linear-gradient(135deg, #11998e, #38ef7d);">
                    <div class="stat-value">${stats.totalWords.toLocaleString()}</div>
                    <div class="stat-label">Mots extraits</div>
                </div>
                <div class="stat-card" style="background:linear-gradient(135deg, #ee0979, #ff6a00);">
                    <div class="stat-value">${Math.round(stats.avgConfidence * 100)}%</div>
                    <div class="stat-label">Confiance</div>
                </div>
                <div class="stat-card" style="background:linear-gradient(135deg, #4568dc, #b06ab3);">
                    <div class="stat-value">${Math.round(stats.processingTime)}s</div>
                    <div class="stat-label">Temps</div>
                </div>
                <div class="stat-card" style="background:linear-gradient(135deg, #f093fb, #f5576c);">
                    <div class="stat-value">${stats.format}</div>
                    <div class="stat-label">Format</div>
                </div>
                <div class="stat-card" style="background:linear-gradient(135deg, #4facfe, #00f2fe);">
                    <div class="stat-value">${stats.size}</div>
                    <div class="stat-label">Taille</div>
                </div>
            `;
            
            document.getElementById('statsSection').style.display = 'block';
            document.getElementById('statsSection').scrollIntoView({ behavior: 'smooth' });
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // GÃ‰NÃ‰RATION PROMPT CONSOLIDÃ‰
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        let selectedStrategy = 'executive'; // StratÃ©gie par dÃ©faut
        
        function openConsolidatedPromptModal() {
            const completedItems = STATE.batch.queue.filter(item => item.status === 'completed');
            
            if (completedItems.length === 0) {
                showStatus('Aucun fichier complÃ©tÃ© pour gÃ©nÃ©rer un prompt', 'warning');
                return;
            }
            
            // Update modal doc count
            document.getElementById('modalDocCount').textContent = completedItems.length;
            
            // Select default strategy
            selectStrategy('executive');
            
            // Show modal
            document.getElementById('promptModal').classList.add('active');
        }
        
        function closeConsolidatedPromptModal() {
            document.getElementById('promptModal').classList.remove('active');
        }
        
        function selectStrategy(strategy) {
            selectedStrategy = strategy;
            
            // Remove selected class from all
            document.querySelectorAll('.prompt-strategy').forEach(el => {
                el.classList.remove('selected');
            });
            
            // Add selected class to chosen strategy
            document.getElementById('strategy-' + strategy).classList.add('selected');
            
            // Check radio button
            document.querySelector(`input[value="${strategy}"]`).checked = true;
            
            // Enable generate button
            document.getElementById('generatePromptBtn').disabled = false;
        }
        
        async function generateConsolidatedPrompt() {
            const completedItems = STATE.batch.queue.filter(item => item.status === 'completed');
            
            if (completedItems.length === 0) {
                showStatus('Aucun fichier complÃ©tÃ©', 'warning');
                return;
            }
            
            showStatus(`GÃ©nÃ©ration du prompt consolidÃ© (${selectedStrategy})...`, 'info');
            
            try {
                // Generate consolidated prompt
                const prompt = generatePromptContent(completedItems, selectedStrategy);
                
                // Create and download text file
                const blob = new Blob([prompt], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `prompt_consolidated_${selectedStrategy}_${new Date().toISOString().slice(0, 10)}.txt`;
                a.click();
                URL.revokeObjectURL(url);
                
                // Show stats
                const stats = getPromptStats(prompt);
                showStatus(
                    `Prompt gÃ©nÃ©rÃ© ! ${stats.words.toLocaleString()} mots, ~${stats.tokens.toLocaleString()} tokens`,
                    'success'
                );
                
                // Close modal
                closeConsolidatedPromptModal();
                
            } catch (error) {
                console.error('Error generating prompt:', error);
                showStatus('Erreur lors de la gÃ©nÃ©ration : ' + error.message, 'error');
            }
        }
        
        function generatePromptContent(items, strategy) {
            const now = new Date();
            const dateStr = now.toISOString().slice(0, 10);
            const timeStr = now.toTimeString().slice(0, 5);
            
            // Header
            let prompt = `${'â•'.repeat(70)}
CONTRAT R&D ANTHROPIC - ANALYSE MULTI-DOCUMENTS
${'â•'.repeat(70)}

ğŸ“š CORPUS ANALYSÃ‰ : ${items.length} documents
ğŸ“… Date : ${dateStr} ${timeStr}
ğŸ¯ ThÃ©matique : Documents multiples - Analyse consolidÃ©e

VOUS AVEZ DÃ‰JÃ€ ACCEPTÃ‰ ET VALIDÃ‰ :
â€¢ Format : 32 MODULES R&D ANTHROPIC par document
â€¢ Citations : Texte simple dans champ "citation"
â€¢ Compression : Intelligente AUTOMATIQUE
â€¢ Questions : ZÃ‰RO

${'â•'.repeat(70)}

`;

            // Document summary table
            prompt += '\n## ğŸ“‹ DOCUMENTS DU CORPUS\n\n';
            items.forEach((item, index) => {
                const result = item.result;
                const wordCount = result.extractedText ? result.extractedText.split(/\s+/).length : 0;
                const charCount = result.extractedText ? result.extractedText.length : 0;
                
                prompt += `${index + 1}. **${result.fileName}**\n`;
                prompt += `   - Mots : ${wordCount.toLocaleString()}\n`;
                prompt += `   - CaractÃ¨res : ${charCount.toLocaleString()}\n`;
                
                if (result.analysis && result.analysis.technical) {
                    const tech = result.analysis.technical;
                    if (tech.documentType) prompt += `   - Type : ${tech.documentType}\n`;
                    if (tech.language) prompt += `   - Langue : ${tech.language}\n`;
                }
                
                prompt += '\n';
            });
            
            prompt += `\n${'â•'.repeat(70)}\n\n`;
            
            // Content based on strategy
            if (strategy === 'executive') {
                items.forEach((item, index) => {
                    const result = item.result;
                    prompt += `\n## ğŸ“– DOCUMENT ${index + 1} : ${result.fileName}\n\n`;
                    prompt += '### EXTRAIT DU DÃ‰BUT\n\n';
                    
                    const excerpt = result.extractedText.substring(0, 2000);
                    prompt += excerpt;
                    
                    if (result.extractedText.length > 2000) {
                        const remaining = result.extractedText.length - 2000;
                        prompt += `\n\n[... document de ${result.extractedText.length.toLocaleString()} caractÃ¨res ...]\n`;
                    }
                    
                    prompt += '\n\n';
                });
                
            } else if (strategy === 'comprehensive') {
                items.forEach((item, index) => {
                    const result = item.result;
                    prompt += `\n## ğŸ“– DOCUMENT ${index + 1} : ${result.fileName}\n\n`;
                    prompt += '### TEXTE INTÃ‰GRAL\n\n';
                    prompt += `<document${index + 1}>\n`;
                    
                    // Limit to 100K chars per document
                    const text = result.extractedText.substring(0, 100000);
                    prompt += text;
                    
                    if (result.extractedText.length > 100000) {
                        const remaining = result.extractedText.length - 100000;
                        prompt += `\n\n[... TEXTE TRONQUÃ‰ - ${remaining.toLocaleString()} caractÃ¨res omis ...]\n`;
                    }
                    
                    prompt += `\n</document${index + 1}>\n\n`;
                });
                
            } else if (strategy === 'analysis_only') {
                items.forEach((item, index) => {
                    const result = item.result;
                    prompt += `\n## ğŸ“– DOCUMENT ${index + 1} : ${result.fileName}\n\n`;
                    
                    if (result.analysis) {
                        prompt += '### ANALYSE STRUCTURELLE\n\n';
                        prompt += '```json\n';
                        prompt += JSON.stringify(result.analysis, null, 2);
                        prompt += '\n```\n\n';
                    }
                });
            }
            
            // Final instructions
            prompt += `
${'â•'.repeat(70)}

## ğŸ¯ TÃ‚CHE R&D

Analyser ce corpus de documents en utilisant le format 32 MODULES R&D ANTHROPIC.

Pour CHAQUE document :
1. Identifier les concepts clÃ©s et leur interconnexion
2. Extraire les citations les plus significatives
3. Analyser la structure argumentative
4. DÃ©gager les patterns et mÃ©thodologies
5. CrÃ©er des liens transversaux entre les documents

SORTIE ATTENDUE :
- Format JSON structurÃ© selon les 32 modules
- Citations textuelles (pas de reformulation)
- Analyse comparative entre les documents
- SynthÃ¨se des approches complÃ©mentaires/contradictoires

CONTRAINTES :
- Exactitude maximale des citations
- Respect de la structure JSON
- Profondeur analytique R&D
- ZÃ©ro question, action directe

${'â•'.repeat(70)}
`;
            
            return prompt;
        }
        
        function getPromptStats(prompt) {
            const words = prompt.split(/\s+/).length;
            const chars = prompt.length;
            const tokens = Math.ceil(chars / 4); // Rough estimation
            
            return { words, chars, tokens };
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // INITIALIZATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        document.addEventListener('DOMContentLoaded', () => {
            console.log('OCR Universel V5.2 ULTIMATE - Ready!');
            console.log('21 formats supportÃ©s');
            console.log('OCR Workers parallÃ¨les activÃ©s');
            console.log('PROMPT_MODULES intÃ©grÃ©s');
            console.log('GÃ©nÃ©ration Prompt ConsolidÃ© activÃ©e');
            
            updateIndicators();
        });
    </script>
    
    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <!-- MODAL GÃ‰NÃ‰RATION PROMPT CONSOLIDÃ‰ -->
    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <div class="prompt-modal" id="promptModal">
        <div class="prompt-modal-content">
            <div class="prompt-modal-header">
                <h2>ğŸ¯ GÃ©nÃ©ration Prompt ConsolidÃ©</h2>
                <button class="prompt-modal-close" onclick="closeConsolidatedPromptModal()">Ã—</button>
            </div>
            
            <p style="color: var(--gris-secondaire); margin-bottom: 30px;">
                Choisissez une stratÃ©gie de consolidation pour gÃ©nÃ©rer un prompt optimisÃ© Ã  partir de vos <span id="modalDocCount">0</span> documents traitÃ©s.
            </p>
            
            <div class="prompt-strategy" onclick="selectStrategy('executive')" id="strategy-executive">
                <div class="prompt-strategy-header">
                    <input type="radio" name="promptStrategy" value="executive" class="prompt-strategy-radio">
                    <div class="prompt-strategy-title">
                        Version Executive
                        <span class="prompt-strategy-badge">RECOMMANDÃ‰</span>
                    </div>
                </div>
                <div class="prompt-strategy-description">
                    SynthÃ¨se concise avec extraits du dÃ©but de chaque document (2000 caractÃ¨res) + tableau rÃ©capitulatif. IdÃ©ale pour une premiÃ¨re analyse rapide et complÃ¨te.
                </div>
                <div class="prompt-strategy-specs">
                    <div class="prompt-strategy-spec">
                        <span class="prompt-strategy-spec-icon">ğŸ“Š</span>
                        <span>~2,000-5,000 tokens</span>
                    </div>
                    <div class="prompt-strategy-spec">
                        <span class="prompt-strategy-spec-icon">âš¡</span>
                        <span>RÃ©ponse rapide</span>
                    </div>
                    <div class="prompt-strategy-spec">
                        <span class="prompt-strategy-spec-icon">âœ¨</span>
                        <span>Analyse de synthÃ¨se</span>
                    </div>
                </div>
            </div>
            
            <div class="prompt-strategy" onclick="selectStrategy('comprehensive')" id="strategy-comprehensive">
                <div class="prompt-strategy-header">
                    <input type="radio" name="promptStrategy" value="comprehensive" class="prompt-strategy-radio">
                    <div class="prompt-strategy-title">Version Comprehensive</div>
                </div>
                <div class="prompt-strategy-description">
                    Texte intÃ©gral de chaque document (tronquÃ© Ã  100K caractÃ¨res par document si nÃ©cessaire). Pour une analyse en profondeur avec accÃ¨s au contenu complet.
                </div>
                <div class="prompt-strategy-specs">
                    <div class="prompt-strategy-spec">
                        <span class="prompt-strategy-spec-icon">ğŸ“Š</span>
                        <span>~50,000-150,000 tokens</span>
                    </div>
                    <div class="prompt-strategy-spec">
                        <span class="prompt-strategy-spec-icon">ğŸ”¬</span>
                        <span>Analyse approfondie</span>
                    </div>
                    <div class="prompt-strategy-spec">
                        <span class="prompt-strategy-spec-icon">ğŸ“–</span>
                        <span>Contenu intÃ©gral</span>
                    </div>
                </div>
            </div>
            
            <div class="prompt-strategy" onclick="selectStrategy('analysis_only')" id="strategy-analysis_only">
                <div class="prompt-strategy-header">
                    <input type="radio" name="promptStrategy" value="analysis_only" class="prompt-strategy-radio">
                    <div class="prompt-strategy-title">Version Analysis Only</div>
                </div>
                <div class="prompt-strategy-description">
                    Uniquement les analyses structurelles multidimensionnelles au format JSON. Pour examiner la dÃ©tection et classification automatique des documents.
                </div>
                <div class="prompt-strategy-specs">
                    <div class="prompt-strategy-spec">
                        <span class="prompt-strategy-spec-icon">ğŸ“Š</span>
                        <span>Variable</span>
                    </div>
                    <div class="prompt-strategy-spec">
                        <span class="prompt-strategy-spec-icon">ğŸ”</span>
                        <span>MÃ©tadonnÃ©es</span>
                    </div>
                    <div class="prompt-strategy-spec">
                        <span class="prompt-strategy-spec-icon">ğŸ“‹</span>
                        <span>Format JSON</span>
                    </div>
                </div>
            </div>
            
            <div class="prompt-modal-actions">
                <button class="btn btn-secondary" onclick="closeConsolidatedPromptModal()">
                    Annuler
                </button>
                <button class="btn" onclick="generateConsolidatedPrompt()" id="generatePromptBtn" disabled>
                    GÃ©nÃ©rer le Prompt
                </button>
            </div>
        </div>
    </div>
</body>
</html>
